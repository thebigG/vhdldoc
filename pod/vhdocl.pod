
=pod

=head1 NAME

vhdocl - a VHDL documentation and structure examination utility


=head1 SYNOPSIS

B<vhdocl> [options] E<lt>input files...E<gt> [ [-l E<lt>libraryE<gt>] E<lt>input files...E<gt>]

print_filenames | B<vhdocl> [options] -

B<vhdocl> [-f] E<lt>config.vhdoclE<gt>


=head1 DESCRIPTION

VHDocL is the pendant of doxygen, kdoc or javadoc for the hardware description
language VHDL.  It generates a set of interlinked HTML pages from a hardware
design.  Specially formatted comments in the VHDL code are read and
incorporated into the HTML pages (see L</MARKUP LANGUAGE> below).  For
undocumented designs, VHDocL can still help understanding by making the
structure of the design apparent.

An HTML page is generated for every entity, architecture, configuration and
package or package body.  Documented items include processes, instantiations,
ports, generic constants, component declarations, function and procedure
declarations.  Instances are bound to their matching entity and hyperlinked to
its HTML page.  See L</OUTPUT> below for more information on generated files.

Besides, VHDocL creates a global list of entities (with their architectures and
configurations) and packages and an instantiation hierarchy.  The hierarchy
results from the bindings of instantiations of components, entities and
configurations within architectures or configurations.  VHDocL takes for...use
statements, configurations and default bindings of components into account when
determining bindings of component instantiations.  Nested configurations (ie
configurations which configure sub-instances within instantiated modules) are
also supported.

VHDocL is not a VHDL syntax checker.  It tries to be as tolerant as possible
regarding coding style and as a consequence may occasionally accept incorrect
VHDL.  Usually, however, incorrect code will cause it to fail without any
useful error message.  VHDocL parses its input using regular expressions
designed to match those elements of VHDL which are relevant to its task and
will simply ignore what it does not recognise.


=head1 OPTIONS

=over

=item B<--benchmark>

Print how much time B<vhdocl> took for parsing each file and for subsequent
processing.  Only really useful to the author for identifying hot spots.
Requires the Perl module Time::HiRes.

=item B<--exclude>=I<glob>

Exclude files matching the I<glob> pattern from processing.  This is primarily
intended to qualify directory searches, but single file names from the command
line are also filtered.  The I<glob> argument is a list of shell glob patterns
separated by commas and/or spaces.  Each pattern has to match the complete file
name or (if it contains a directory separator) the last part of the path.
Matching is case insensitive.  This option can occur multiple time but is not
cumulative; rather, its current values applies to subsequent source files until
the next B<--exclude> option.  The I<glob> pattern will usually have to be
escaped from the shell, for example by enclosing it in single quotes.

=item B<-f> I<file.vhdocl>, B<--configfile>=I<file.vhdocl>

Tells VHDocL to interrupt command line argument processing and to read options
and input file names from the given configuration file.  If given, this will
usually be the only option (but need not be).  Processing of command-line
arguments will resume after the config file has been read.  See
L</CONFIGURATION FILE> below for the configuration file format.

=item B<--footer>

Footer string to be printed at the bottom of every documentation file.  This
will be put before the "Generated by VHDocL" notice which is also printed
at the bottom.  HTML entities and markup are allowed, for example to print a
copyright sign or to separate the text from the "Generated..." notice by a
horizontal rule.

=item B<-h>, B<--help>

Print brief usage message and the most important command-line options, then
exit.  No processing will be done if this option is encountered.

=item B<--homehtml>=I<file>

Insert the HTML document I<file> into the home page of the documentation.
I<file> may but need not be a complete HTML document.  If it is, only the part
within the body tags will be copied, and the header will be discarded.

=item B<--javasyntax>

Generate JavaScript for syntax highlighting of source HTML pages instead of
generating marked-up pages directly.  This will save some CPU time and may
therefore be faster for large designs.  On the downside, there will be a delay
loading the HTML pages of large source files as the browser processes them.

=item B<-j> I<n>, B<--jobs>=I<n>

Use I<n> tasks to parse source files in parallel.  I<n>=0 disables forking
worker tasks for parsing.  The default (when no B<-j> option is provided) is
the number of bits in the mask returned by C<taskset -p> on Linux, or 3 on
other systems.  This option is useful mainly when the VHDL sources are located
on a fast SSD or a RAM disk, so that parsing speed is limited by CPU speed, not
disk IO.

=item B<--leftlogo>=I<image>

File name or URL of an image to put in the top left of every HTML page
generated.  Intended for institute or company logos.  If this is a file, it
will be copied to the documentation folder.

=item B<-l> I<libname>, B<--library>=I<libname>

Indicates that the following source files belong to the VHDL design library
<libname>.  This will affect how components are bound.  The default library is
"work".  All file names given before the first (or in the absence of any)
library option are assigned to it.

=item B<-m>, B<--compatibility>

Vhdldoc compatibility mode.  DON'T USE this option when writing new
documentation.

=item B<-o> I<path>, B<--outputdir>=I<path>

Set the output directory.  It (and the required subdirectories) will be
created if it does not yet exist.  The default output directory is "./doc".

=item B<--parsedebug>

Switch on debugging of the VHDL parser.  Prints out every declarative item
found, and whether entering or returning from a nested block.  Only of interest
to the author.

=item B<-p> I<word>, B<--prefix>=I<word>

Set a prefix for all HTML file names generated in this run.  This allows to
generate documentation of several unrelated designs in the same output
directory without interference.

=item B<--psl>

Enable limited support for the Property Specification Language developed by
Accelera and formalised in IEEE standard 1850.  Some PSL definitions and most
verification directives occurring in architectures and packages will be
documented.  See the L</OUTPUT> section below for details.

=item B<-q>, B<--quiet>

Do not output what VHDocL is doing.  Parsing errors will still be reported,
though less verbosely than they would normally.

=item B<-r>, B<--recursive>

Search directories given after this option recursively for VHDL files.  The
negated form B<+r> or B<--norecursive> switches off recursion for the following
directories, until the next B<-r> option.

=item B<--rightlogo>=I<image>

File name or URL of an image to put in the top right of every HTML page
generated.  Intended for institute or company logos.  If this is a file, it
will be copied to the documentation folder.

=item B<--sourcelinks>

Insert hyperlinks to each VHDL source file into its HTML page and the source
overview.  This allows to edit the file with one click if you set your
browser's file associations accordingly.  This option is enabled by default,
but it may make sense to disable it, for example when the documentation is to
be put on a web server.

=item B<--stylesheet>=I<stylefile.css>

File name or URL of a CSS stylesheet to reference in the headers of all
generated HTML files.  This allows the user to influence the appearance of the
generated HTML.  If this is a file, it will be copied to the documentation
folder.

=item B<-t> I<"modules ...">, B<--topmodule>=I<"modules ...">

Designate some entities or entity-architecture/configuration combinations top
modules.  These top modules will be listed separately in the instantiation
hierarchy page.  The option argument is a list of space-separated strings.
Listing an entity name makes all architectures and configurations of this
entity top modules.  Specific architectures and configurations can be given in
the syntax C<entity(architecture)> and C<entity[configuration]>.  This option
is not affected by B<--library>, so you have to give the library explicitly (as
C<library.entity>) if it is something other than C<work>.

=item B<--tabsize>=I<width>

Set tab alignment four source markup pages.  A zero I<width>, the default,
omits tab expansion and leaves it to the browser to display tabs correctly.
This probably works only for a tab size of 8, however setting this option
incurs a small but measurable increase in processing time.  This option only
applies to source files it precedes, and may be present multiple times to set
different tab sizes for different files.

=item B<--title>=I<string>

Title string to be printed at the top of every documentation file.  Intended
to contain a brief description of the purpose of the design documented.  HTML
entities and markup are allowed, for example to print non-ASCII characters.

=item B<--toplink>=[I<text|>]I<file.html>

Gives a hyperlink to appear in the navigation bar of all generated HTML files.
That link replaces the one to the documentation home page, which will not be
generated.  Intended for "interfacing" with other local documentation of which
the generated design docs are part.  If present, the text before the vertical
bar is used for the text of the hyperlink reference (the default is "Home").
Be aware that your shell may try to interpret the vertical bar and escape it if
necessary.

=item B<--version>

Print version of VHDocL and exit.  No processing will be done if this option is
encountered.

=back

Long options may be abbreviated.  Their arguments may also be separated by
spaces instead of C<=>.  Boolean-valued short options can be negated by
replacing the "-" by a "+", long options by prepending "no" to the option name.
Options other than the B<-l>/B<--library>, B<--tabsize>, B<-r>/B<--recursive>
and B<--exclude> options can be mixed freely with input file names, and the
last of multiple occurrences overrides the others.


=head1 USAGE

The most immediately obvious way to use VHDocL is by giving the source files to
be parsed on the command line, like this:

    vhdocl submodule1.vhd topmodule.vhd submodule2.vhd

This will cause VHDocL to read the VHDL files, create the default output
directory "doc" and some subdirectories and generate HTML pages in these
directories.  The file extension .vhd/.vhdl may be omitted when specifying
source files.

It is not necessary to tell VHDocL every single source file name.  If all your
design files are located in a single directory, it is sufficient to say:

    vhdocl .

(Assuming you are currently in that directory.)  VHDocL will then process all
files with the extension .vhd or .vhdl in that directory.  To include files in
subdirectories, give the option B<-r>:

    vhdocl -r .

In order to exclude some source files, you can use the B<--exclude> option:

    vhdocl --exclude \*_tb.vhd -r .

For more sophisticated selection criteria, you can use the find command and
pipe its results in to VHDocL's stdin:

    find . -iname \*.vhd -a -mtime +7 | vhdocl -

The argument "-" causes VHDocL to suspend command-line processing and read
arguments from standard input.

It is not necessary to tell VHDocL which of the source files contains the top
module, as it will automatically resolve instantiations and treat those modules
which are instantiated nowhere as top modules.  (So unless you omit testbench
files from the source file list, they will be regarded as top modules.)  The
B<-t> option allows you to designate some top modules, which are then displayed
more prominently on the hierarchy page.  This allows you to separate your
design top modules from test benches, for example.

Arguments to VHDocL, both options and input file names, can be given in three
ways: on the command line, on standard input and in the configuration file (see
below).  These three possibilities can in principle be intermixed freely
(though in how far that is a good idea is a different matter).  Parsing of
command-line arguments will resume after parsing a configuration file or
standard input, and parsing of the remainder of a config file will continue
after parsing an included configuration file.

Assuming your design comprises two design libraries, work and play, and you are
currently in the directory of the play library, which does not have any
subdirectories and is located beside the directory containing the work library,
you can generate documentation with:

    find ../work -iname \*.vhd | vhdocl - -l play .

VHDocL will read all file names found by C<find> from standard input and assign
them to the default library work.  Then it encounters the library option and
the directory ".".  It finds all VHDL files in this directory and assigns them
to the library play.


=head1 CONFIGURATION FILE

Instead of on the command line, VHDocL options and input files can be given in
a configuration file.  This allows these arguments to be saved as part of a
design project.  A configuration file to be read is specified with the B<-f>
option.  As a special case, if only one file name is specified on the command
line and if that file has the extension .vhdocl, this is taken to be a
configuration file not a source file.

The configuration file is a plain text file containing VHDocL options, input
files and possibly comments.  An option is specified by the option name, which
is identical to the long command line option without the "--", an optional
equals sign and its value.

Boolean-valued options can be specified by just giving their name or its
negated form ("no...").  If a value is given, it may only be "1", "on", "yes",
"true", "0", "off", "no" or "false" (case insensitive).  The option
"configfile" serves as an include directive.

Input files and directories are specified like options, with "input" instead of
the option name.  File names are taken relative to the location of the
configuration file.  (So are the arguments of options like "outputdir",
"stylesheet" etc.)  Multiple "input"s are allowed, as are several files per
"input", separated by spaces.  File  names containing any of *?[]{}~ are
interpreted as glob patterns for searching for source files (but not
directories).  File names which contain any of these characters have to be
quoted by single quotes.   File names containing white space can be quoted by
single or double quotes (which do not quote glob characters).  As on the
command line, the source files are assigned to the library given with the
latest "library" option, or the work library if no "library" option was
encountered.

The configuration file is line-oriented.  Every option or input file
specification has to be contained in a single line.  However, lines may be
continued in the following text line by putting a backslash at the end of the
previous line.  The backslash may be followed by white space and a comment.
Comments start with the "#" character and extend up to the end of the text
line.  To avoid ambiguities, "#" characters are not allowed in comments, and if
a "#" is contained in an option value, a comment must be present.  In other
words, VHDocL removes anything from the last "#" to the end of the line.

A configuration file could for example look like this:

    ######################################################
    #  Contrived VHDocL config file for non-existent design
    ######################################################
    
    quiet= true
    noparsedebug
    leftlogo= http://www.bigbucks.inc.biz/logo.png
  
    # These go into library work:
    input topmodule.vhd submodule1.vhd \  # comment allowed here
          submodule2.vhd
    
    library play
    input= fun.vhd songndance.vhd

As on the command line, directories may be given instead of files, and all VHDL
files in those directories will be parsed, subdirectories included if the
"recursive" option is in force.  The special input file "-" for reading file
names from standard input is not allowed in config files.


=head1 MARKUP LANGUAGE

Though VHDocL helps to understand undocumented designs, its primary purpose is
as a documentation tool.  Most VHDL declarative items can have a description
associated with them, which will be printed in the relevant HTML page.  These
descriptions are given in comments in the VHDL code which start with --*
instead of --.  They have to directly precede the declarative item to which
they refer or be located on the same line.  Documentation comments preceding
statements or declarations which are not documented are discarded.  Empty lines
(just --* and white space) serve to separate paragraphs in the documentation
text.

Here is an example:

    --* This process defines an up-counter.  This would not normally warrant
    --* much of a description, but this is to demonstrate that VHDocL
    --* documentation comments can extend over several comment lines.
    --*
    --* Here is an equally contrived second paragraph, again designed to show
    --* how to write documentation for VHDocL.
    upctr : process( reset, clk ) is
    begin
      if reset = '1' then
        count <= (others => '0');
      elsif rising_edge(clk) then
        count <= std_logic_vector(unsigned(count) + 1);
      end if;
    end process upctr;

To prevent separators from being misinterpreted as documentation, --* may not
be immediately followed by a further "*", or the comment will be ignored.  If
you want to create a separator in the documentation, insert a space between --*
and the row of asterisks.

The description text in the documentation comments can contain certain HTML
tags.  The original plan was to allow just any tags, but certain people I<have>
to use < and > for other purposes...  The following tags are allowed without
attributes: C<b>, C<i>, C<tt>, C<u>, C<big>, C<small>, C<sub>, C<sup>, C<em>,
C<strong>, C<code>, C<var>, C<ul>, C<ol>, C<li>, C<br>, C<center>, C<pre>,
C<table>, C<tr>, C<td>, and C<th>.  The tags C<a>, C<span> and C<img> are
allowed with attributes.  Note that the URLs in the C<a> and C<img> tags will
not be transformed in any way, so they have to be either an absolute URL or a
path relative to the future location of the documentation HTML file in which
they will appear.

For instance, the C<pre> tag can be used to create ASCII graphics:

    --* This entity represents an adder tree with four inputs:
    --*
    --* <pre>
    --*           +
    --*      ,---' `--.
    --*     +          `+
    --*    / \         / \
    --* in1   in2   in3   in4
    --* </pre>
    
    entity adder4 is
      port (
        --+ Inputs to be added up
        in1    : in std_logic_vector(7 downto 0);
        in2    : in std_logic_vector(7 downto 0);
        in3    : in std_logic_vector(7 downto 0);
        in4    : in std_logic_vector(7 downto 0);
        --* Output giving the addition result.  This is two bits wider than the
        --* inputs to avoid overflow.
        result : out std_logic_vector(9 downto 0)
      );
    end entity adder4;

The example demonstrates another feature of VHDocL:  If a documentation comment
starts with --+ instead of --*, the given description is added not just to the
following declaration, but to all following declarations of the same type
(ports in this case), until a different description is encountered.  --+ is
intended and will work only for "simple" declarations such as ports, constants
and so on, not for declarations like processes or functions which are followed
by a block of code.  Analogously as --*, --+ may not be immediately followed by
a further "+".

This brings us to the question which declarations can be documented.  First,
the "big five" top-level declarations (entities, architectures, configurations,
packages and package bodies) can have descriptions.  (They, and only they, may
contain special markup codes described below.)  So can ports, generics,
library and use statements.  Within architectures and packages, constants,
functions, procedures and component and type declarations (including records
and units) can be documented.  Likewise generate and block statements,
processes and instantiations inside architectures and for ...  use statements
in architectures and configurations.  Local declarations of constants,
functions etc. within other functions, generate statements of similar
declarations with their own declarative part cannot be documented and will not
be output to the generated HTML pages.  See L</OUTPUT> below for a description
of what VHDocL generates.

The description of entities, architectures, configurations, packages and
package bodies can contain the following markup codes, which are similar to
vhdldoc, kdoc and javadoc.  Their arguments extend up to the next empty line or
the next markup code.  Markup codes have to be preceded by white space or the
beginning of a line, so e-mail addresses can be given without risk of
misinterpretation.

=over

=item B<@author> I<name>, ...

Author or list of authors separated by commas.  May occur several times.

=item B<@brief> I<description> or B<@short> I<description>

Brief description to be printed at the top of the item's HTML page and in the
global lists.  Don't use both @short and @brief for the same item.  In places
where only one of these two can be used (such as the entity list), @brief takes
precedence.

=item B<@date> I<date>

Modification date of this item.

=item B<@deprecated>, B<@internal>, B<@simulation>, B<@synthesis>, B<@testbench>

Causes that word to be printed prominently in the top region of the item's HTML
file.

=item B<@id> I<ID>

Revision control system ID of the item.

=item B<@see> I<reference1>, I<reference2>, ...

Cross reference.  This markup code may occur several times, and every time
multiple cross references may be given separated by commas.  If the reference
is the name of an entity, architecture, configuration or package, the reference
will be hyperlinked to its HTML page.

=item B<@version> I<version>

Revision of the item.

=back


@date, @id and @version tally nicely with keywords automatically substituted by
revision management systems such as Subversion
(L<http://subversion.tigris.org/>).  (@author is a different matter since
Subversion merely substitutes the author who did the last commit.)  If you use
Subversion, you can enable keyword substitution for your VHDL file with the
following command:

    svn propset svn:keywords "Date Id Rev" source.vhd

You can then write in the description of an entity:

    --* @date $Date$
    --* @id $Id$
    --* @version $Rev$

The date, ID and version number of the last change to source.vhd will then be
inserted into the documentation comments by Subversion.  VHDocL strips the
Subversion keywords and dollar signs, leaving only the information substituted
by Subversion.  This is in fact done for all Subversion keywords in all
documentation comments, so you may also use them in your documentation text if
you like.  Note that VHDocL descriptions relate to an entity or an architecture
(or other declarative item), whereas Subversion keywords relate to files.  So a
changed date does not necessarily mean that something changed in the entity
declaration.  But if you have a separate file for each entity/architecture and
package/package body pair, having Subversion data in their description is still
meaningful.

Recent versions of VHDocL support a similar feature for sources stored in a git
repository.  If the text after a @date, @version, @id or @author markup is just
"$git$", VHDocL runs a git command on the source file to obtain that
information.  The date, version and author is from the most recent revision of
the file according to C<git whatchanged>; the version is made more readable by
C<git describe>.  The file ID is determined by C<git hash-object>.  The same
caveats as for SVN apply: The author of the most recent revision is not
necessarily what you want, and a design unit may not be modified even if its
file was.


=head1 OUTPUT

VHDocL generates five top-level documentation pages which are located in the
output directory: A list of entities (with their architectures and
configurations), a list of packages, an instantiation overview, an
instantiation hierarchy and a list of source files.  They are named
entities.html, packages.html, instantiations.html, hierarchy.html and
sources.html, possibly preceded by the prefix.  The difference between the
instantiation overview and hierarchy is that the overview merely shows the
first-level instantiations in each architecture and configuration, while the
hierarchy recursively shows all instantiations in sub-(sub-...)modules.  Both
list every instantiated module only once, even when it is instantiated several
times in the same parent module.  The hierarchy stops at recursive
instantiations, if applicable.

There is also a home page C<index.html> in the output directory which links to
the five pages mentioned above.  The B<--homehtml> option allows to insert an
existing HTML document into this page, for example a general description of the
project.  If a top-level URL is given  with the B<--toplink> option, this is
supposed to replace the home page, and C<index.html> will not be generated.
The top-level declarations listed in the top-level HTML files are hyperlinked
to the HTML files which describe them in detail, located in the accordingly
named subdirectory of the output directory.  If a @brief/@short description is
available, the top-level HTML files display it.

All entities, architectures, configurations, packages and package bodies are
described in HTML files of their own located in the respective subdirectory.
(Packages and their package body share the same file.)  It contains their
description, with special markup codes such as @author displayed prominently
near the top.  The name of the source file which contains their definition is
displayed, and the source HTML page is hyperlinked.  The top-level library and
use clauses in that source file are documented.  The documentation of other
sub-declarations follows.

An entity's HTML page documents its ports and generics and links to the pages
of its architectures and configurations.  Architecture pages contain all of
the following as applicable: declarations of functions, procedures, types,
constants and components, instantiations, processes and generate and block
statements.  Instantiations are hyperlinked to the instantiated component,
entity or configuration.  Use statements referring to component instantiations
are not printed separately, but expressed implicitly in the binding of the
instances.  Attributes are mentioned in the documentation of the declarative
items they refer to.  Similarly, generate and block statements are documented
along with the instantiation or process they enclose.  If they do not contain
either, they are ignored, like use statements or attributes which refer to
nothing.

Here is an example of how an instantiation which is inside three nested
generate statements is documented:

    Comparator : RankCmp
        Compare centre pixel to each other pixel in the neighbourhood
        Generic map:
            DataWidth   => 8
        Binding: work.RankCmp (combinatorial)
        This instantiation is inside the following constructs:
            RankRows : for row in 1 to WindowHeight generate
            RankCols : for col in 1 to WindowWidth generate
            SkipCentre : if row /= WindowHeight/2+1 or col /= WindowWidth/2+1 generate

The first line gives the name of the instance and the name of the component,
which is hyperlinked to its declaration.  This is followed by the instance's
description and its generic map.  Next, the component's binding is given, with
links to the appropriate entity and architecture.  Last comes a list of the
generate statements enclosing this instantiation.  If they had descriptions,
they would be printed under the generate statement they refer to.

If the option B<--psl> is enabled, some PSL statements in architectures are
documented.  This includes definitions of named sequences, endpoints,
properties and a default clock, and the verification statements C<assert>,
C<assume>, C<assume_guarantee>, C<restrict>, C<restrict_guarantee> and
C<cover>.

Pages of configurations display the prescribed bindings in a hierarchical
manner similar to the global instantiation hierarchy.  The use statements are
hyperlinked to the pages of the selected entities, architectures and/or other
configurations.

Packages and their package bodies are documented in the same HTML page.  It
contains the declarations of types, constants, functions, procedures and
components.  With B<--psl>, PSL sequence, endpoint and property definitions are
also included.  The documentation of corresponding declarations in the package
and its package body is merged, and the package body section is omitted unless
it contains unique declarative items.

Source files are converted to HTML files with syntax highlighting and line
numbering.  This is done by assigning CSS classes to words and expressions in
the code.  Their appearance is determined by a default CSS file and can be
overridden in the user CSS file.  (The same applies to source code quoted in
the documentation pages.)  The source file itself is hyperlinked from the
source pages (unless you choose B<--nosourcelinks>), so you can edit it by
clicking on the link if you have the file associations of your browser set
accordingly.

The following CSS classes are available for syntax markup:

=over

=item B<vhdlcode>

Encloses all code quotes, allowing for example to set a monospace font.

=item B<nocode>

Non-code words inside quoted code, such as the "unnamed" notice for nameless
processes.  Not used in source pages.

=item B<doccom>

VHDocL documentation comments.

=item B<vhdlcom>

Other comments.

=item B<vhdlieee>

Identifier from IEEE standard package.

=item B<typeid>

Type identifier.  Standard IEEE types belong to both this class and
B<vhdlieee>.  The C<!important> directive can be used in the CSS style file to
choose which its appearance will be.

=item B<declid>

Identifier of a declarative item documented by VHDocL.  Applies to entities,
architectures, packages, configurations, functions, procedures, components,
and instances.  In most cases, the style file will treat this as B<identifier>.

=item B<pslid>

Identifier of PSL named sequence, endpoint or property.  Only if B<--psl> was
enabled.

=item B<identifier>

Other identifier.

=item B<vhdlio>

I/O direction indicator such as C<in>, C<out> and C<inout>.

=item B<vhdlvar>

VHDL declaration keyword C<variable>, C<signal>, C<constant>, C<attribute> or
C<file>.

=item B<vhdldecl>

VHDL keyword denoting a declaration documented by VHDocL.

=item B<vhdlword>

Other VHDL reserved word.

=item B<vhdlstr>

Quoted VHDL (bit) string or character or bit.

=item B<pslword>

Keyword of PSL (Property Specification Language).  Only if B<--psl> was
enabled.

=back

The assignment of classes is based solely on word recognition, and as a
consequence is not perfect.  For example, the word C<in> occurring in
C<for...generate> statements will be misidentified as belonging to the
B<vhdlio> class.

In addition to syntax markup, the indentation of most lists (of entities,
instances, processes etc.) can also be controlled by CSS.  Indentation is
created by the use of layout tables.  The following two CSS classes determine
their size:

=over

=item B<vhdoclind>

Class to which table cells used for indentation belong.  Indentation is
proportional to their width.  The default value is 50 pixels.

=item B<vhdocltab>

Class of layout tables.  Their cell padding is set to 3 pixels by VHDocL and
can be modified by setting the padding CSS property on their cells (not on the
tables themselves).

=back

The default VHDocL style file vhdocl.css contains examples of all the available
CSS classes.


=head1 MACHINE-READABLE OUTPUT

The instantiation hierarchy is also output to a machine-readable text file in
JSON format that is compatible with YAML 1.2.  This allows other tools to make
use of the information VHDocL extracts.

The top-level data structure is an array with three elements, the hierarchy
itself, an array of designated top modules and an array of other uninstantiated
modules.  The hierarchy itself is an object (called a dictionary or hash in
other languages) that maps the names of nodes to objects describing their
instantiations and other properties.  Node names are constructed from the
template "library.entity-architecture[-configuration]".  Each node object has
the entries "entity", "architecture" and possibly "configuration" as well as
"file" (the file name where it is defined).  The "instantiations" entry has as
its value an array of node names instantiated in it.


=head1 BUGS AND LIMITATIONS

VHDL is acknowledged to be a hard language to parse, and it offers many
freedoms which lead to large differences in coding style.  VHDocL performs a
basic parsing of the declarative elements in the input files by trying to
identify them using regular expressions.  The parsing has now been tested on a
largish number of designs, most of them not coded by the author.  Still, it is
possible that your design may be incorrectly parsed.  If so, you can help me
greatly by sending me a copy of the VHDL file which failed to be parsed.

Purely syntactical issues aside, the more advanced features of VHDocL (such as
support for multiple libraries and for configurations) could not be tested as
thoroughly as its more frequenly used features.  If something breaks there, I
would also be interested in your design, or even better a simple test case.

Instantiations without either a port map or a generic map are not supported.
Positional association for generic maps is not supported.

Nested declarations, such as functions inside functions, constants inside
processes, etc. are parsed but not documented.

The home page of VHDocL is L<http://www.volkerschatz.com/hardware/vhdocl.html>.
Backfeed is welcome to the e-mail vhdocl at that domain.


=head1 COPYRIGHT

VHDocL is (c) 2007-2013 Volker Schatz.  Credits to Minh Cuong Tran for
providing a first implementation of the clickable hierarchy view and syntax
highlighting, and for much efficiency testing.  Thanks to several other users
for smaller fixes, bug reports and helpful feature requests.
    
VHDocL is free software and may be redistributed and/or modified under the
terms of the GNU General Public License, version 3 or later.

=cut


