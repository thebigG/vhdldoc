#!/usr/bin/perl -w

#    This is VHDocL, a VHDL documentation utility.
#    Copyright (c) 2007-13 Volker Schatz (vhdocl at volkerschatz dot com).
#
#    VHDocL is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 3 of the License, or
#    (at your option) any later version.
#
#    VHDocL is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with VHDocL; if not, see <http://www.gnu.org/licenses/>.


use strict;
use warnings;
use File::Spec;
use File::Path;
use File::Glob;
use File::Find;
use File::Copy;
use Text::Tabs;
use Digest::MD5;
use Cwd 'abs_path';
use Socket;
use Storable;
# use Data::Dumper;

# Obtaining the modules:
# Cwd and File::Spec from http://search.cpan.org/~smueller/PathTools/
# File::Path from http://search.cpan.org/~dland/File-Path/
# Digest::MD5 from http://search.cpan.org/~gaas/Digest-MD5/
# Socket from http://search.cpan.org/~pevans/Socket/
# File::Copy and Text::Tabs from Perl distribution
# Time::HiRes (for --benchmark) from http://search.cpan.org/~zefram/Time-HiRes/

my $version= "? (use mkvhdocldist.sh and install-vhdocl.pl to install properly)";

my %config= ( "outputdir" => "doc", "prefix" => "", "libname" => "work",
  "compat" => 0, "cwd" => "", "psl" => 0, "parsedebug" => 0, "quiet" => 0, 
  "stylesheet" => "", "leftlogo" => "", "rightlogo" => "", "toplink" => "",
  "homehtml" => "", "title" => "", "footer" => "", "topmodules" => [],
  "sourcelinks" => 1, "tabsize" => 0 );

my %requisites= ( "treestyle" => "treeview.css", "treejava" => "treeview.js",
    "nodeimg" => "node.png", "subtrimg" => "subtree.png",
    "leafimg" => "leaf.png", "basestyle" => "vhdocl.css" );


##############################################################################
##############################################################################
####                    Auxiliary functions
##############################################################################
##############################################################################

# Return the first element of a list which matches a criterion.
# -> Anonymous test subroutine operating on $_ and returning a true value for
#    matches
#    List to search
# <- The first matching element, or undef
sub elem(&@)
{
  my $test= shift @_;
  for (@_) {
    return $_ if &$test;
  }
  return undef;
}


# Reverse a hash to a hash of arrays.  The values of the result hash are
# references to arrays containing all keys of the original hash having the same
# value (which becomes the corresponding key in the new hash).
# -> Original hash
# <- Resulting hash of arrays
sub revhash(\%)
{
  my ($orighash)= @_;
  my %result;

  for my $key (keys %$orighash) {
      push @{$result{$$orighash{$key}}}, $key;
  }
  return ( %result );
}


# Remove duplicates from a sorted array (or successive duplicates from any
# array).  The != operator is used for comparisons, suitable for numbers and
# references.
# -> List of values or references
# <- List of unique values or references
sub uniq
{
    return @_ if @_ < 2;
    my $prev= shift;
    my @uniques= ( $prev );
    for (@_) {
        next unless $_ != $prev;
        push @uniques, $_;
        $prev= $_;
    }
    return @uniques;
}


# Find the shortests prefix of a string that is unique compared to a set of
# other strings.  The strings must be equal in length and only contain ASCII
# characters.
# -> String for which to deterine the prefix
#    List of other strings
# <- Prefix, or undef if one of the others is equal to the target string
sub uniqueprefix
{
    my ($target, @others)= @_;

    my $prelen= -1;
    for (@others) {
        $_ = $_ ^ $target;
        /^(\x00*)/;
        $prelen= length($1) if length($1) > $prelen;
    }
    ++$prelen;
    return $prelen > length($target) ? undef : substr($target, 0, $prelen);
}


# An auxiliary function for obtaining the canonical form of a file name.
# Required to work around Cwd::abs_path()'s intolerance towards non-existing
# files and directories.
# -> File name including path
# <- File name made canonical with Cwd::abs_path() if possible, with
#    File::Spec->canonpath() otherwise.  The latter does not consult the file
#    system and therefore cannot resolve symbolic links.
sub mycanonpath
{
  my ($file)= @_;
  my $canonfile= eval { Cwd::abs_path($file) };
  return $canonfile unless $@ || !defined($canonfile);
  return File::Spec->canonpath($file);
}


# Run a command after changing the current working directory.  Before
# returning, the working directory is changed back to $config{"cwd"}.
# -> Directory
#    Command
# <- Output of the command, or undef if chdir failed
sub runat
{
    my ($dir, $cmd)= @_;

    chdir $dir or return undef;
    my $result= `$cmd`;
    chdir $config{"cwd"};
    return $result;
}


# Transforms a file name which is relative to a different directory to one
# which is relative to the current working directory.  Absolute file names and
# URLs are left unchanged.
# -> File name
#    Directory path
# <- Transformed file name
sub fixpath
{
  my ($file, $dir)= @_;

  if( $file =~ /^\w+:\/\//i || File::Spec->file_name_is_absolute($file) ) {
    return $file;
  }
  else {
    $file= File::Spec->rel2abs($file, $dir);
    $file= mycanonpath($file);          # get rid of interior /../ if possible
    $file= File::Spec->abs2rel($file, $config{"cwd"});
    $file ||= ".";              # some versions of abs2rel return "" for "."
    return $file;
  }
}


my $pathsep;

BEGIN {
  $pathsep= File::Spec->catdir("","") || "/";
}


# Return a hyperlink to a source file from a top-level HTML file.
# -> File name (absolute or relative to current directory)
# <- Hyperlink to file relative to output directory
sub sourcelink
{
  my ($filename)= @_;

  # We convert non-"/" path separators to slashes.  This will work for Windoze,
  # for other systems we would probably have to use URI::file.
  if( File::Spec->file_name_is_absolute($filename) ) {
    $filename =~ s!\Q$pathsep\E!/!g unless $pathsep eq "/";
    return "file://$filename";
  }
  else {
    $filename= File::Spec->abs2rel($filename, $config{"absoutputdir"});
    $filename =~ s!\Q$pathsep\E!/!g unless $pathsep eq "/";
    return $filename;
  }
}


# Return the file extension of a file name (i.e. the portion after the last
# ".").
# -> File name
# <- Extension (without the ".")
sub fileext
{
  my ($fname)= @_;

  (undef, undef, $fname)= File::Spec->splitpath($fname);
  $fname =~ /\.([^\.]*)$/;
  return $1 || "";
}


# Quote glob characters in a string by prepending '\x01'.
# -> String
# <- Quoted string
sub quoteglob
{
  my ($str)= @_;

  $str =~ s/([\[\]\?\*\{\}\~])/\x01$1/g;
  return $str;
}


# Split a string containing file names at white space, allowing quoting by
# single and double quotes.  Single quotes quote glob characters *?[]{} and ~;
# double quotes do not.
# -> String
#    Optional reference to scalar that will be set to the unmatched quote
#    character if one is encountered, undef otherwise
# <- List of substrings

my $QUOTWORD= qr/[^'"\s]*(?:(?:"[^"]*"|'[^']*')[^'"\s]*)*/;

sub splitfilenames
{
  my ($str, $unmatched)= @_;

  $str =~ s/^\s+//;
  my @words= ( $str =~ /\G($QUOTWORD)(?:\s+|$)/ogc );
  ($$unmatched)= $str =~ /\G.*?(["'])/ if $unmatched;
  pop @words unless length $words[-1];
  map { s/"([^"]*)"|'([^']*)'/defined($1)? $1 : quoteglob($2)/eg; } @words;
  return @words;
}


# Convert a glob pattern given with --exclude to a regex fragment for use on
# file paths.
# -> Glob pattern frmo --exclude
# <- Regex fragment for testing file paths
sub glob2re
{
  my $gl= shift;
  $gl =~ s/^(?:\Q$pathsep\E)+//;
  $gl =~ s/(?<!\\)(?=[]\*\?\[\{\}])/\x01/g;
  $gl= quotemeta($gl);
  $gl =~ s/(?:\\\x01\\\*)+/[^\Q$pathsep\E]*/go;
  $gl =~ s/\\\x01\\\?/[^\Q$pathsep\E]/go;
  $gl =~ s/\\\x01\\([][])/$1/g;
  1 while $gl =~ s/(\\\x01\\\{[^{},])\\,/$1|/g;
  $gl =~ s/\\\x01\\{/(/g;
  $gl =~ s/\\\x01\\}/)/g;
  return "$gl";
}


# Compare two code snippets.  White space is compressed to one space character
# between words and completely removed elsewhere.  The contents of strings are
# not treated specially, so if two snippets differ only by the amount of white
# space in strings, they will erroneously compare as equal.
# -> Strings to compare
# <- 0 if equivalent
sub codecmp
{
  my ($a, $b)= @_;

  return 0 if $a eq $b;
  $a =~ s/\s+/ /g;
  $a =~ s/^ //;
  $a =~ s/ $//;
  $a =~ s/ (?=\W)//g;
  $a =~ s/(?<=\W) //g;
  $b =~ s/\s+/ /g;
  $b =~ s/^ //;
  $b =~ s/ $//;
  $b =~ s/ (?=\W)//g;
  $b =~ s/(?<=\W) //g;
  return $a cmp $b;
}


# Copy a file.  Uses File::Copy->copy() but prevents croaking.
# -> Source file name
#    Destination file name or target directory
# <- 1 if successful, 0 on error
sub copyfile
{
  my ($from, $to)= @_;
  my $status;

  $status= eval { File::Copy::copy($from, $to); };
  return !$status || $@? 0 : 1;
}


# Read an HTML file and cut out the HTML within <body> tags.
# -> File name
# <- HTML text
sub gethtml
{
  my ($fname)= @_;
  my $content;

  return "" unless $fname;
  if( !open(IN, "<$fname") ) {
    print STDERR "Error: Could not open `$fname' for reading.  Ignoring --homehtml and generating empty home page.\n";
    return "";
  }
  {
    local $/;
    $content= <IN>;
  }
  close IN;
  $content =~ s/^.*<\s*body\b[^>]*>//is;
  $content =~ s/<\/\s*body\b[^>]*>.*$//is;
  return $content;
}


# Print file error messages at most three times, and print a note when
# suppressing further error messages.
# -> Error message
#    Reference to scalar for counting errors (incremented up to 4)
sub limitfileerr
{
  my ($msg, $errcount)= @_;
  my $limit= $config{"quiet"}? 1 : 3;

  return if $$errcount > $limit;
  if( $$errcount < $limit ) {
    print STDERR "$msg - $!\n";
  }
  else {
    print STDERR "(additional errors suppressed)\n";
  }
  ++$$errcount;
}


# Concatenate a word list, separated by a comma and a space, but with the last
# two words separated by a given string instead.
# -> String between last two words, including surrounding spaces if applicable
#    List of words
sub cswordlist
{
  my ($conj, @words)= @_;

  if( @words > 1 ) {
    return join(", ", @words[0..$#words-1]) . $conj . $words[-1];
  }
  elsif( @words ) {
    return $words[0];
  }
}


# Another auxiliary function which exits the program with return value 1 after
# optionally printing a message to STDERR.  Akin to die but without the silly
# line number output which users don't have any use for.
# -> Error message
sub croak
{
  my ($msg)= @_;

  print STDERR "$msg\n" if defined($msg) && "$msg";
  exit 1;
}


my %digitbits= ( "1" => 1, "2" => 1, "3" => 2, "4" => 1, "5" => 2, "6" => 2,
        "7" => 3, "8" => 1, "9" => 2, "a" => 2, "b" => 3, "c" => 2, "d" => 3,
        "e" => 3, "f" => 4 );

# Count the 1 bits in an integer represented as a hexadecimal string.
# -> Hex string
# <- Bit count
sub counthexbits
{
  my $str= shift;
  my $count= 0;

  for (split "", lc($str)) {
    $count += $digitbits{$_} || 0;
  }
  return $count;
}


# Send data structure over a socket after serialising it using Storable.  Large
# data are split into multiple transmissions to be suitable for datagram
# sockets.
# -> Socket handle reference
#    Hash or array references (no non-ref scalars, since Storable does not
#    work on those)
# <- 1 OK, 0 error
sub senddata
{
  my ($sock, @refs)= @_;
  my $msg;
  my $sent;

  for my $dataref (@refs) {
    $msg= Storable::freeze($dataref);
    while( length($msg) >= $config{"maxmsgsize"} ) {
      $sent= send($sock, substr($msg, 0, $config{"maxmsgsize"}), 0);
      return 0 unless defined($sent) && $sent == $config{"maxmsgsize"};
      substr($msg, 0, $config{"maxmsgsize"})= "";
    }
    $sent= send($sock, $msg, 0);
    return 0 unless defined($sent) && $sent == length($msg);
  }
  return 1;
}


# Receive data from a (datagram) socket, reassemble large data split by
# senddata and deserialise it using Storable::thaw().
# -> Socket handle reference
# <- Reference to deserialised data structure or undef if an error occurred or
#    if the socket has been set to non-blocking operation and no data was
#    available
sub recvdata
{
  my ($sock)= @_;
  my ($data, $newdata, $status);

  $status= recv($sock, $newdata, $config{"maxmsgsize"}, 0);
  return undef unless defined($status);
  $data= $newdata;
  while( length($newdata) == $config{"maxmsgsize"} ) {
    $status= recv($sock, $newdata, $config{"maxmsgsize"}, 0);
    return undef unless defined($status);
    $data .= $newdata;
  }
  return Storable::thaw($data);
}


{
my $starttime;

sub benchmark
{
  my ($msg, $lines)= @_;

  if( !$msg ) {
    $starttime= [ Time::HiRes::gettimeofday() ];
  }
  else {
    my $secs= Time::HiRes::tv_interval($starttime);
    my $perline= "";
    $perline= ", " . sprintf("%g", $secs / $lines) . " s per line"
        if $lines;
    $secs= sprintf "%g", $secs;
    print "Took $secs s $msg$perline.\n";
  }
}

}


##############################################################################
##############################################################################
####                    Command line parsing functions
##############################################################################
##############################################################################

# Format of option table: Each option array contains the short option letter,
# the long option name, the option type and the %config hash key (or a
# subroutine reference for some).  The option types are: "*" string, "#"
# decimal integer, "w" word (=~ /^\w*$/), "/" pathname, "?" boolean, "<" config
# file name, "@" array of strings, "&" call subroutine.
my @options= (
[ "h", "help", "&", \&printhelp ],
[ "", "version", "&", \&printversion ],
[ "o", "outputdir", "/", "outputdir" ],
[ "f", "configfile", "<", 0 ],
[ "p", "prefix", "w", "prefix" ],
[ "l", "library", "w", "libname" ],
[ "", "tabsize", "#", "tabsize" ],
[ "r", "recursive", "?", "recursive" ],
[ "", "exclude", "*", "exclude" ],
[ "t", "topmodule", "@", "topmodules" ],
[ "", "psl", "?", "psl" ],
[ "", "parsedebug", "?", "parsedebug" ],
[ "", "benchmark", "?", "benchmark" ],
[ "q", "quiet", "?", "quiet" ],
[ "c", "cellpadding", "#", "cellpadding" ],
[ "i", "indentation", "#", "indentation" ],
[ "j", "jobs", "#", "jobs" ],
[ "m", "compatibility", "?", "compat" ],
[ "", "stylesheet", "/", "stylesheet" ],
[ "", "leftlogo", "/", "leftlogo" ],
[ "", "rightlogo", "/", "rightlogo" ],
[ "", "title", "*", "title" ],
[ "", "footer", "*", "footer" ],
[ "", "toplink", "/", "toplink" ],
[ "", "homehtml", "/", "homehtml" ],
[ "", "javasyntax", "?", "javasyntax" ],
[ "", "sourcelinks", "?", "sourcelinks" ],
);

# Options that apply only to files following them and may be present multiple
# times:
my @fileopts= qw(libname tabsize);


# Parse command line argument arrray.
# -> Reference to array of command-line arguments.
# <- Reference to array of source files.  Options values are written to %config.
sub parseargv
{
  my ($argv)= @_;
  my $files= [];
  my $status;

  # Don't use File::Spec->curdir(), it takes 1 second (!)
  $config{"cwd"}= Cwd->cwd();
  while( @$argv ) {
    $status= parseopt($argv, $files);
    next if $status;
    if( $$argv[0] eq "-" ) {
      shift @$argv;
      while( <STDIN> ) {
        my @inargs= split;
        while( @inargs && parseopt(\@inargs, $files) ) {}
      }
    }
    else {
      print STDERR "The option ", $$argv[0], " requires an argument.  ",
                        "Aborting.\n";
      croak;
    }
  }
  if( $#$files == 0 && $files->[0]->{"name"} =~ /\.vhdocl$/i ) {
    my $cfile= $files->[0]->{"name"};
    $files= [];
    parsecfgfile($cfile, $files, $config{"cwd"});
  }
  parsetopmods();
  return $files;
}


# Parse one option or input file from an array.  The parsed option (and
# possibly its argument) is removed from the array.  A parsed option is entered
# into %config, an input file name generates a new entry in the file list.
# Hashes representing files have the entries "type" (= "file"), "name" (the
# file name) and "libname" (the library name).
# -> Reference to array containing options, their arguments and input files
#    Reference to array containing references to hashes representing input
#    files
# <- 1 if something could be parsed, 0 if an argument is missing or the option
#    was "-" (read from stdin).
sub parseopt
{
  my ($arglist, $filelist)= @_;
  my $nextarg= shift @$arglist;
  my $opt;
  my $value;

  if( $nextarg =~ /^--/ ) {
    $nextarg =~ /^--([^=]*)(?:=(.*))?$/;
    my $optname= lc($1);
    my $onoff= 1;
    $value= $2;
    croak "Unknown long option $nextarg.  Aborting."
        unless $optname =~ /^\w+$/;
    my @opts= grep($_->[1] =~ /^$optname/i, @options);
    if( !@opts && $optname =~ s/^no(.)/$1/i ) {
      @opts= grep($_->[2] eq "?" && $_->[1] =~ /^$optname/i, @options);
      $onoff= 0;
    }
    croak "Unknown long option $nextarg.  Aborting."
        unless @opts;
    if( @opts > 1 ) {
      print STDERR "Ambiguous long option $nextarg.  (Could be --",
                join(", --", map($_->[1], @opts[0..$#opts-1])), " or --",
                $opts[$#opts]->[1], ".)  Aborting.\n";
      croak;
    }
    if( $opts[0]->[2] eq "?" ) {
      $config{$opts[0]->[3]}= $onoff;
      return 1;
    }
    elsif( $opts[0]->[2] eq "&" ) {
      &{$opts[0]->[3]}();
      return 1;
    }
    $opt= $opts[0];
  }
  elsif( $nextarg =~ /^[+-]\S/ ) {
    $nextarg =~ /^([+-])(\S)(.*)$/;
    my $onoff= $1 eq "-";
    my $firstchar= $2;
    my $remainder= $3;
    my ($thisopt)= grep($_->[0] eq $firstchar, @options);
    croak "Unknown short option -$firstchar.  Aborting."
      unless $thisopt;
    if( $thisopt->[2] eq "?" || $thisopt->[2] eq "&" ) {
      if( $thisopt->[2] eq "?" ) {
        $config{$thisopt->[3]}= $onoff;
      }
      elsif( $thisopt->[2] eq "&" ) {
        &{$thisopt->[3]}();
      }
      my @optchars= split(//, $remainder);
      for my $optchar (@optchars) {
        ($thisopt)= grep($_->[0] eq $optchar, @options);
        croak "Unknown short option -$optchar.  Aborting."
          unless $thisopt;
        if( $thisopt->[2] eq "?" ) {
          $config{$thisopt->[3]}= $onoff;
        }
        elsif( $thisopt->[2] eq "&" ) {
          &{$thisopt->[3]}();
        }
        else {
          print STDERR "Cannot bundle short options with arguments (-",
                       $thisopt->[0], ").  Aborting.\n";
          croak;
        }
      }
      return 1;
    }
    elsif( $remainder =~ /^=/ ) {
      $value= substr($remainder, 1);
    }
    elsif( length($remainder) ) {
      print STDERR "Cannot bundle short options with arguments (-",
                   $thisopt->[0], ").  Aborting.\n";
      croak;
    }
    else {
      $value= undef;
    }
    # $value= $remainder if $remainder; # value without space
    $opt= $thisopt;
  }
  elsif( $nextarg eq "-" ) {
    unshift @$arglist, $nextarg;
    return 0;
  }
  elsif( -d $nextarg ) {
    my @vhdl= searchdirectory($nextarg);
    my @newfiles= map +{ "type", "file", "name", $_ }, @vhdl;
    map { @$_{@fileopts}= @config{@fileopts}; } @newfiles;
    push @$filelist, @newfiles;
    return 1;
  }
  elsif( $nextarg !~ /\.vhdl?$/i && !-e $nextarg ) {
    my ($fname)= grep -f, File::Glob::bsd_glob("$nextarg.[vV][hH][dD]{,[lL]}");
    $fname ||= $nextarg;
    return 1 unless defined filterfiles($fname);
    push @$filelist, { "type", "file", "name", $fname };
    @{$$filelist[-1]}{@fileopts}= @config{@fileopts};
    return 1;
  }
  else {
    return 1 unless defined filterfiles($nextarg);
    push @$filelist, { "type", "file", "name", $nextarg };
    @{$$filelist[-1]}{@fileopts}= @config{@fileopts};
    return 1;
  }
  # Now take care of options with arguments.  Their value may already have been
  # assigned to $value if it was in the same command line argument as the
  # option.
  unless( defined($value) ) {
    $value= shift @$arglist;
    unless( defined($value) ) {
      unshift @$arglist, $nextarg;
      return 0;
    }
  }
  if( $opt->[2] eq "w" ) {
    unless( $value =~ /^\w*$/ ) {
      print STDERR "The argument of", ($opt->[0]? " -".$opt->[0]." /": ""),
                   " --", $opt->[1], " may only contain letters, digits and ",
                   "the underscore.  Aborting.\n";
      croak;
    }
  }
  elsif( $opt->[2] eq "#" ) {
    unless( $value =~ /^\d+$/ ) {
      print STDERR "The argument of", ($opt->[0]? " -".$opt->[0]." /": ""),
                   " --", $opt->[1], " must be numerical.  Aborting.\n";
      croak;
    }
  }
  if( $opt->[2] eq "<" ) {
    parsecfgfile($value, $filelist);
  }
  elsif( $opt->[2] eq "@" ) {
    push @{$config{$opt->[3]}}, split /\s+/, $value;
  }
  else {
    $config{$opt->[3]}= $value;
  }
  return 1;
}


# Parse options and input files from a config file
# <- Configuration file name
#    Reference to array containing references to hashes representing input
#    files
#    Directory from which the config file was included
#    (optional) Reference to array of config file names from which this one was
#    included, to avoid include loops
sub parsecfgfile
{
  my ($fname, $filelist, $track)= @_;
  my ($vol, $dir)= File::Spec->splitpath($fname);
  my $basedir= File::Spec->catpath($vol, $dir, "") || ".";
  $basedir= mycanonpath($basedir);
  my $line;

  $track ||= [];
  open(CFG, "<$fname") or croak "Could not open config file $fname - $!";
  while( <CFG> )
  {
    s/\s*(?:#[^#]*)?$//;
    next unless $_;
    $line .= " " . $_;
    next if $line =~ s/\s*\\$//;
    $line =~ /^\s*([^\s=]+)\s*=?\s*([^=]*?)\s*$/
        or croak "Cannot understand line $. in $fname: $line";
    my $optname= $1;
    my $value= $2;
    my $onoff= 1;
    croak "Unknown option $optname in $fname, line $..  Aborting."
        unless $optname =~ /^\w+$/;
    $line= "";
    $value =~ s/^\s+//;
    $value =~ s/\s+$//;
    if( lc($optname) eq "input" ) {
      my $unmatched;
      my @fileargs= splitfilenames $value, \$unmatched;
      croak "Unmatched " . ($unmatched eq '"'? "double" : "single") .
            " quote in $fname, line $..  (Verbatim quote characters have to be quoted now, see the manual.)  Aborting."
          if $unmatched;
      for my $farg (@fileargs) {
        $farg= fixpath($farg, $basedir);
        my $globarg= $farg;
        $globarg =~ s/\\/\\\\/g;  # escape backslashes (windoze)
        $globarg =~ tr/\x01/\\/;  # escape glob characters (see quoteglob())
        my @files;
        if( $farg =~ /(?<!\x01)(?:\?|\*|\[|\]|\{|\}|\~)/ ) {
          @files= grep -f, File::Glob::bsd_glob($globarg);
          if( ! @files ) {
            print STDERR "Warning: No matches for glob pattern `$globarg'.\n"
                unless $config{"quiet"};
          }
          @files= map fixpath($_), @files;
        }
        else {
          $farg =~ tr/\x01//d;      # remove glob char escape markers
          if( -e $farg ) {
            @files= ( $farg );
          }
          else {      # glob for .vhd(l) files if verbatim file name not found
            @files= grep -f, File::Glob::bsd_glob("$globarg.[vV][hH][dD]{,[lL]}")
                unless $farg =~ /\.vhdl?$/i;
            croak "Input file `$farg' does not exist.  Aborting."
                unless @files;
          }
        }
        for my $file (@files) {
          if( -d $file ) {
            my @dirfiles= searchdirectory($file);
            my @newfiles= map +{ "type", "file", "name", $_ }, @dirfiles;
            map { @$_{@fileopts}= @config{@fileopts}; } @newfiles;
            push @$filelist, @newfiles;
          }
          elsif( defined filterfiles($file) ) {
            push @$filelist, { "type", "file", "name", $file };
            @{$$filelist[-1]}{@fileopts}= @config{@fileopts};
          }
        }
      }
      next;
    }
    my @opts= grep($_->[1] =~ /^$optname/i, @options);
    if( !@opts && $optname =~ s/^no(.)/$1/i ) {
      @opts= grep($_->[2] eq "?" && $_->[1] =~ /^$optname/i, @options);
      $onoff= 0;
    }
    croak "Unknown option $optname in $fname, line $..  Aborting."
        unless @opts;
    if( @opts > 1 ) {
      print STDERR "Ambiguous option $optname in $fname, line $..  (Could be ",
                   join(", ", map($_->[1], @opts[0..$#opts-1])), " or ",
                   $opts[$#opts]->[1], ".)  Aborting.\n";
      croak;
    }
    if( $opts[0]->[2] eq "&" ) {
      print STDERR "Ignoring option $optname in $fname.\n";
    }
    elsif( $opts[0]->[2] eq "<" ) {     # configfile option
      push @$track, $fname;
      $value= fixpath($value, $basedir);
      if( grep($_ eq $value, @$track) ) {
        print STDERR "Ignoring recursive include in $fname, line $..\n";
      }
      else {
        parsecfgfile($value, $filelist, $track);
      }
      pop @$track;
    }
    elsif( $opts[0]->[2] eq "?" ) {
      if( $value ) {
        if( !$onoff ) {
          croak "Cannot give value for negated option $optname in $fname, line $..  Aborting.";
        }
        elsif( $value =~ /^(?:1|yes|on|true)$/i ) {
          $config{$opts[0]->[3]}= 1;
        }
        elsif( $value =~ /^(?:0|no|off|false)$/i ) {
          $config{$opts[0]->[3]}= 0;
        }
        else {
          croak "Illegal value for boolean option $optname in $fname, line $..  Aborting.";
        }
      }
      else {
        $config{$opts[0]->[3]}= $onoff;
      }
    }
    elsif( $opts[0]->[2] eq "@" ) {
      push @{$config{$opts[0]->[3]}}, split /\s+/, $value;
    }
    else {
      if( $opts[0]->[2] eq "w" ) {
        unless( $value =~ /^\w*$/ ) {
          print STDERR "The argument of option $optname may only contain ",
                       "letters, digits and the underscore in $fname, line ",
                       "$..  Aborting.\n";
          croak;
        }
      }
      elsif( $opts[0]->[2] eq "#" ) {
        unless( $value =~ /^\d+$/ ) {
          print STDERR "The argument of option $optname must be numerical ",
                       "in $fname, line $..  Aborting.\n";
          croak;
        }
      }
      elsif( $opts[0]->[2] eq "/" ) {
        $value= fixpath($value, $basedir);
      }
      $config{$opts[0]->[3]}= $value;
    }
  }
  close CFG;
}


# Filter a list of file paths according to the --exclude option currently in
# effect.  A regex is created out of the option value on demand and a reference
# to it stored in place of the option value.  If called in scalar context and
# the single argument is filtered out, a warning message is output.
# -> List of file paths
# <- List of filtered file paths
sub filterfiles
{
  my $excludes= $config{"exclude"};
  return @_ if !@_ || !defined($excludes) || !length($excludes);
  if( !ref($excludes) ) {
    my $exclre= "(?i:(?:^|\Q$pathsep\E)(?:" . join("|", map glob2re($_), split /[,\s]+/, $excludes) . ")\$)";
    eval { "foo" =~ /$exclre/; };
    if( $@ ) {
      croak "Error trying regex derived from --exclude glob pattern \`$excludes':\n$@\n";
    }
    $excludes= $config{"exclude"}= \$exclre;
  }
  if( ! wantarray ) {
    return $_[0] unless $_[0] =~ /$$excludes/;
    print STDERR "Warning: Explicit file name $_[0] filtered by --exclude.\n"
        unless $config{"quiet"};
    return;
  }
  return ( grep ! /$$excludes/, @_ );
}


# Search a directory for VHDL files.  The search is recursive if the recursive
# option is on (but symlinks are not followed).
# -> Path to directory
# <- List of VHDL files
sub searchdirectory
{
    my ($dir)= @_;
    my @files;

    if( $config{"recursive"} ) {
        File::Find::find( sub { push @files, $File::Find::name
                                    if -f && /\.vhdl?$/i; },    $dir);
    }
    else {
        my $pattern= File::Spec->catfile($dir, "*.[vV][hH][dD]{,[lL]}");
        @files= grep -f, File::Glob::bsd_glob($pattern);
    }
    return filterfiles(@files);
}


# Print version
sub printversion
{
  print "This is VHDocL version $version.\n";
  exit;
}


# Print brief usage message
sub printhelp
{
  print <<EOF;
VHDocL is a VHDL documentation and structure examination utility.
Usage:
    vhdocl [options] input files... [ [-l <library>] input files...]
VHDocL generates HTML documentation for hardware designs written in VHDL.  It
outputs an HTML page for each entity, architecture, configuration and package
and a list of entities and of packages and the design's instantiation
hierarchy.
The most important command-line options are:
    -o, --outputdir     Output directory (default: "doc")
    -l, --library       Library to which the following source files belong
    -r, --recursive     Process following source directories recursively
    -q, --quiet         Reduce verbosity of progress reporting
    --stylesheet=stylefile.css  CSS style file to reference
Long options may be abbreviated.

VHDocL's manual is contained in the file vhdocl.pod in its distribution package
in POD format and can be extracted using pod2man, pod2html and similar programs
which come with Perl.  For instance, a manual page can be generated and viewed
as follows:
  pod2man vhdocl.pod > vhdocl.1
  man ./vhdocl.1
It can also be read online at http://www.volkerschatz.com/hardware/vhdocl.html.

In order to install VHDocL on your system, obtain the distribution package from
http://www.volkerschatz.com/hardware/vhdocl.html and execute the perl script
install-vhdocl.pl.  Run it with the option -h first to view available options.
You will need administrator privileges to install vhdocl for all users.  On
non-UNIX systems, a target directory has to be provided.
EOF
  exit;
}


##############################################################################
##############################################################################
####                    VHDL parsing functions
##############################################################################
##############################################################################

# Parse documentation (--*) comment.  Escape HTML's reserved characters but
# leave some tags untouched which are allowed in descriptions.
# -> String containing documentation with --* already removed
# <- Reference to hash containing extracted documentation items
sub parsedoccom
{
  my %doc;
  my $dcom= shift;
  my $tags= qr/b|i|tt|u|big|small|sub|sup|em|strong|code|var|ul|ol|li|
                br|center|pre|table|tr|td|th|(?:a|span|img)(?:\s+[^>]+)?/ix;
  my $svnkeys= qr/(?:LastChanged)?(?:Date|Revision)|Rev|Id|Author|(?:Head)?URL/;

  $dcom =~ s/<(\/?$tags)>/\x01$1\x02/go;
  $dcom =~ s/&/&amp;/g;
  $dcom =~ s/</&lt;/g;
  $dcom =~ s/>/&gt;/g;
  $dcom =~ s/"/&quot;/g;
  $dcom =~ tr/\x01\x02/<>/;
  my @doclines= split /\s+(?=\@)|\n[ \t\r]*\n/, $dcom;
  chomp(@doclines);
  # Remove supported Subversion keywords:
  map { $_ =~ s/\$$svnkeys:\s*(.*?)\s*\$/$1/go; } @doclines;
  for my $line ( @doclines )
  {
    next if $line =~ /^$/;
    if( $line =~ /^\@/ ) {
      if( $line =~ /^\@(short|brief|date|version|id)\s+(.*)$/is ) {
        $doc{$1}= $2;
      }
      elsif( $line =~ /^\@author\s+(.*)$/is ) {
        push @{$doc{"author"}}, $1;
      }
      elsif( $line =~ /^\@see\s+(.*)$/is ) {
        push @{$doc{"see"}}, map( [ $_ ], split(/\s*,\s*/, $1));
      }
      elsif( $line =~ /^\@(deprecated|internal|simulation|synthesis|testbench)\b/is ) {
        $doc{$1}= 1;
      }
      elsif( $config{"compat"} && $line =~ /^\@li\s/is ) {
        push @{$doc{"description"}}, $line;
      }
      elsif( $config{"compat"} && $line =~ /^\@(generic|port)\s+(\S*)\s+(.*)$/is ) {
        $doc{$1}->{$2}= $3;
      }
      elsif( !$config{"quiet"} ) {
        $line =~ /^(\@\w+)\b/;
        print STDERR "Unknown markup code $1 on or before line $..\n";
      }
    }
    else {
      push @{$doc{"description"}}, $line;
    }
  }
  $doc{"author"}= join(", ", @{$doc{"author"}}) if $doc{"author"};
  return \%doc;
}


{
my @gitfiles;

# Add a file to the list @gitfiles if the doc comment hash of one of the
# top-level design units has a version, date, id or author entry containing
# only "$git$".  References to the places to insert the git data are collected.
# -> Reference to file hash
# (<-) Updated @gitfiles array if applicable
sub markgit
{
  my ($file)= @_;
  my %places;     # ...where git metadata is wanted

  for my $unit (@{$file->{"children"}}) {
    next unless $unit->{"doc"};
    for my $key (qw(version date id author)) {
      push @{$places{$key}}, \$unit->{"doc"}->{$key}
        if defined($unit->{"doc"}->{$key}) && $unit->{"doc"}->{$key} =~ /^\s*\$git\$\s*$/;
    }
  }
  return unless keys %places;
  push @gitfiles, { "fname" => $file->{"name"}, "places" => \%places };
}


# Efficiently find git revision, author and date of files that contain the
# markup code $git$.  Git repositories containing all files are identified by
# searching for the .git directory.  Then "git whatchanged --name-only" is run
# once for each repository and the revision of last change is determined for
# each file that belongs to it.  "git describe" is emulated with the help of
# uniqueprefix() to obtain the revision.
# (->) List of files with $git$ placeholder in the documentation, generated by
#      markgit()
# (<-) Git version, date, id or author information inserted into doc hashes of
#      top-level design units where requested
sub getgitmeta
{
  return unless @gitfiles;
  my @repos;
  my $nocasefiles= File::Spec->case_tolerant();

repofilename:
  for my $file (@gitfiles) {
    my $fname= File::Spec->rel2abs($file->{"fname"});
    $fname= mycanonpath($fname);
    $fname= lc($fname) if $nocasefiles;
    for my $repo (@repos) {
      if( substr($fname, 0, length($repo->{"dir"})) eq $repo->{"dir"} ) {
        push @{$repo->{"files"}}, [ File::Spec->abs2rel($fname, $repo->{"dir"}), $file ];
        $file->{"haverepo"}= 1;
        next repofilename;
      }
    }
    my ($vol, $alldirs)= File::Spec->splitpath($fname);
    my @dirs= File::Spec->splitdir($alldirs);
    while( 13 ) {
      my $basedir= File::Spec->catfile(@dirs);
      $basedir= "" unless defined $basedir;
      my $trydir= File::Spec->catpath($vol, $basedir, ".git");
      if( -d $trydir ) {
        push @repos, { "dir" => File::Spec->catfile(@dirs, ""),
            "files" => [ [ File::Spec->abs2rel($fname, $basedir), $file ] ] };
        $file->{"haverepo"}= 1;
        last;
      }
      # assumes git repos are never at the top level of a drive on
      # windoze, or in the root directory on UNIX:
      last unless @dirs;
      pop @dirs;
    }
  }
  my $devnull= "";
  $devnull= " 2> /dev/null"
        unless $config{"parsedebug"} || $^O eq "MSWin32" || $^O eq "MacOS";
  for my $repo (@repos) {
    my $history= runat $repo->{"dir"}, "git whatchanged --name-only$devnull";
    my @commits= split /\n(?=commit [\da-fA-F]{40})/, $history;
    my %needdescribe;
    for my $commit (@commits) {
      my ($hash, $tag) = $commit =~ /^commit ([\da-fA-F]{40})(?:\s+\((?:[^,]*, )*tag:\s+([^ ,]+)(?:, [^,]*)*\))?/;
      my $comrev;
      for my $repofile (@{$repo->{"files"}}) {
        next if $repofile->[2];
        next unless $commit =~ /^$repofile->[0]$/m;
        $repofile->[2]= $comrev, next if $comrev;
        my ($author)= $commit =~ /^Author:\s+(.*)$/m;
        my ($date)= $commit =~ /^Date:\s+(.*)$/m;
        $repofile->[2]= $comrev= { "hash" => $hash,
              "author" => html_esc($author), "date" => html_esc($date) };
        $needdescribe{$hash}= 1
            if $repofile->[1]->{"places"}->{"version"};
      }
    }
    my $descriptions= runat($repo->{"dir"}, "git describe --tags --always " . join(" ", keys %needdescribe));
    @needdescribe{keys %needdescribe}= split /\s+/, $descriptions;
    for my $repofile (@{$repo->{"files"}}) {
      my $places= $repofile->[1]->{"places"};
      my $frev= $repofile->[2];
      map { $$_= $frev->{"author"} || "??"; } @{$places->{"author"}}
          if $places->{"author"};
      map { $$_= $frev->{"date"} || "??"; } @{$places->{"date"}}
          if $places->{"date"};
      map { $$_= $needdescribe{$frev->{"hash"}} || "??"; } @{$places->{"version"}}
          if $places->{"version"};
    }
  }
  for my $nogitf (@gitfiles) {
    next if $nogitf->{"haverepo"};
    map { $$_= "?? (no git repo found)"; }
        ( @{$nogitf->{"places"}->{"author"} || []},
          @{$nogitf->{"places"}->{"date"} || []},
          @{$nogitf->{"places"}->{"version"} || []} );
  }
  my @needid= grep $_->{"places"}->{"id"}, @gitfiles;
  my $cmd= "git hash-object " . join(" ", map $_->{"fname"}, @needid) . $devnull;
  my @ids= split /\s+/, `$cmd`;
  for my $file (@needid) {
    map { $$_= $ids[0]; } @{$file->{"places"}->{"id"}};
    shift @ids;
  }
  @gitfiles= ();
}

}


# VHDL identifier:
my $ID= qr/\b[a-zA-Z](?:\w*[a-zA-Z0-9])?\b/;
# List of identifiers for variable, signal and other declarations:
my $IDLIST= qr/$ID(?:\s*,\s*$ID)*/o;
# Operator name for overloading etc.:
my $OP= qr!"(?:\W|[/<>]=|[a-zA-Z]+)"!;
# Selected name for use clause and others:
my $SID= qr/(?:$ID\s*\.\s*)*(?:$ID|$OP|'.')/o;
# Selected name list:
my $SIDLIST= qr/$SID(?:\s*,\s*$SID)*/o;
# Block type for parsing "end...":
my $BLK= qr/(?:entity|architecture|configuration|package|packagebody|process|postponedprocess|if|loop|block|units|record)/;
# Item in an attribute specification:
my $AI= qr/(?:$ID|$OP|'.')(?:\s*\[[^]]*\])?/o;
# List of attribute spec items:
my $AILIST= qr/$AI(?:\s*,\s*$AI)*/o;

# Quoted strings and chars (or bit vectors and bits) have to be treated
# separately:
my $QUOT= qr/"[^"\n]*"|'[^'\n]'/;
# Quoted strings or chars or single apostrophe:
my $QUOTA= qr/"[^"\n]*"|'[^'\n]'|'/;
# A non-empty expression without a semicolon:
my $STUFF= qr/(?:$QUOT|[^;"])[^;"']*(?:$QUOTA[^;"']*)*/o;
# Same, but not greedy:
my $MSTUFF= qr/(?:$QUOT|[^;"])[^;"']*?(?:$QUOTA[^;"']*?)*?/o;
# Possibly empty expression containing anything at all, with matched quotes (if
# any):
my $ANY= qr/[^"']*(?:$QUOTA[^"']*)*/o;
# Same, but not greedy:
my $MANY= qr/[^"']*?(?:$QUOTA[^"']*?)*?/o;
# Possibly nested parenthetical expression:
my $PAREN;
# This needs Perl 5.10:
eval { $PAREN= qr/(\([^()"']*(?:(?:(?-1)|$QUOTA)[^()"']*)*\))/o; };
if( $@ ) {      # fallback for older Perls
  use re 'eval';
  $PAREN= qr/\([^()"']*(?:(?:(??{$PAREN})|$QUOTA)[^()"']*)*\)/o;
  print "" if "foo" =~ /$PAREN/;
};
# Code containing no parentheses outside quotes: (currently unused)
# my $NOPAREN= qr/[^()"']*(?:$QUOTA[^()"']*)*/o;
# Entry in a comma-separated list, accounting for quotes and parentheses:
my $COMMAENTRY= qr/[^,()"']*(?:(?:$PAREN|$QUOTA)[^,()"']*)*/o;
# Same for semicolon-separated list:
my $SEMIENTRY= qr/[^;()"']*(?:(?:$PAREN|$QUOTA)[^;()"']*)*/o;

# Regexes for reading PSL statements:
# Possibly nested brace expression:
my $PSLBRACE;
# This needs Perl 5.10:
eval { $PSLBRACE= qr/({[^{}"']*(?:(?:(?-1)|$QUOTA)[^{}"']*)*})/o; };
if( $@ ) {      # fallback for older Perls
  use re 'eval';
  $PSLBRACE= qr/{[^{}"']*(?:(?:(??{$PSLBRACE})|$QUOTA)[^{}"']*)*}/o;
  print "" if "foo" =~ /$PSLBRACE/;
};
# PSL statement:
my $PSL= qr/[^;{}"']*(?:(?:$PSLBRACE|$QUOTA)[^;{}"']*)*/o;


{   # Start of scope of parsing variables

my $vhandle;
my $vline;
my ($doccomment, $aheaddoccom, $keepdoccom, $keepaheaddoc);


# Read and preprocess next line from VHDL file.
# -> Flag indicating readahead
# <- 0 on end of file, otherwise 1
sub getnextline
{
  my ($ahead)= @_;

  my $new= <$vhandle>;
  return 0 unless defined($new);
  preprocessline($new, $ahead);
  return 1;
}


# Preprocess next line from VHDL file.
# -> New (single) line of VHDL code
#    Flag indicating readahead
sub preprocessline
{
  my ($new, $ahead)= @_;

  $new =~ s/^\s*//;
  $new =~ s/^($MANY)--(.*)$/$1/o;
  if( $2 && $2 =~ /^([+*])([^+*].*|)$/ ) {
    ($ahead ? $keepaheaddoc : $keepdoccom) = $1 eq "+" unless $config{"compat"};
    ($ahead ? $aheaddoccom : $doccomment) .= $2 . "\n";
  }
  chomp $new;
  $vline .= " " . $new;
  # Simplifications to facilitate parsing
  $vline =~ s/\bpackage\s+body\b/packagebody/ig;
  $vline =~ s/\bprotected\s+body\b/protectedbody/ig;
  $vline =~ s/\bpostponed\s+process\b/postponedprocess/ig;
}


# Skip until first semicolon outside string literals and comments.
# (<->) $vline: Remainder of current code line
# <- 0 on end of file, otherwise 1
sub skipstatement
{
  my $comment;

  while( defined($vline) ) {
    if( $vline =~ /;/ ) {
      chomp $vline;
      $vline =~ s/^($MANY)(--.*)$/$1/o;
      $comment= $2;
      if( $vline =~ s/^(?:|$STUFF);//o ) {
        $vline .= $comment if $vline !~ /^\s*$/ && defined($comment);
        return 1;
      }
    }
    $vline= <$vhandle>;
  }
  $vline= "";
  return 0;
}


# Skip part of a statement until a given regex matches outside quotes.  If no
# match is found, the whole statement until `;' is skipped unless EOF is
# encountered.
# -> Regex indicating when to stop skipping
# <- 1 if match was found before `;' ending the statement or EOF, 0 otherwise
# (<-) $vline contains the read text
sub skipuntil
{
  my ($until)= @_;

  while( 13 ) {
    $vline =~ s/^$MSTUFF(?:$until|(;))// and return !defined($1);
    getnextline(0) or return 0;
  }
}


# Read part of a statement until a given regex matches outside quotes.
# -> Regex indicating when to stop reading
# <- 1 if match was found before `;' ending the statement, 0 otherwise, undef
#    on EOF
# (<-) $vline contains the read text
sub readuntil
{
  my ($until)= @_;

  while( 13 ) {
    $vline =~ /^(?:$MSTUFF)?(?:$until|(;))/ and return !defined($1);
    getnextline(0) or return undef;
  }
}


# Read part of a statement until a given regex matches a prefix.  Return the
# matching prefix and remove it from $vline.  Potentially dangerous: reads
# whole file increasingly slowly if regex never matches.
# -> Regex indicating when to stop reading (leading ^ need not be included)
# <- Prefix string matching the regex if match was found, undef on EOF
sub readcomplete
{
  my ($re)= @_;

  while( 13 ) {
    $vline =~ s/^($re)// and return $1;
    getnextline(0) or return undef;
  }
}


# Read generic or port declaration list.  Nested parentheses are tracked.
# Documentation comments are assigned to individual ports or generics.  Before
# returning, the doc comment variables are cleared to avoid reuse at the end of
# the main loop in parsefile().
# -> String to write to the "type" entry of the resulting hashes, "port" or
#    "generic"
# <- List of hashes representing ports or generics
sub readportlist
{
  my ($type)= @_;
  my ($port, @ports);
  my $lastdoccom;

  while( 13 ) {
    $port= "";
    while( 13 ) {
      $vline =~ s/^($SEMIENTRY)//o;
      $port .= $1;
      last if $vline =~ /^[;)]/;
      my $new= <$vhandle>;
      return unless defined($new);
      $new =~ s/^\s*//;
      $new =~ s/^($MANY)--(.*)$/$1/o;
      if( $2 && $2 =~ /^([+*])([^+*].*|)$/ ) {
        $keepdoccom= $1 eq "+" unless $config{"compat"};
        $doccomment .= $2 . "\n";
      }
      chomp $new;
      $vline .= " " . $new;
    }
    $vline =~ s/^([;)])//;
    my $delimiter= $1;
    if( $type eq "recordelement" && $port =~ /^\s*end\b/i ) {
      $vline= $port . $delimiter . $vline;
      last;
    }
    if( $port =~ /^\s*($IDLIST)\s*:\s*(?:(in|out|inout)\b)?\s*
                                  ($MSTUFF)(?:\s*:=\s*($STUFF))?\s*$/iox ) {
      $doccomment ||= $lastdoccom if $keepdoccom;
      my $doc= $doccomment? parsedoccom($doccomment) : undef;
      my @newports= map +{ "type", $type, "name", $_, "doc", $doc,
                          "direction", $type eq "port" ? lc($2 || "in") : "",
                          "subtype", $3, "value", $4 }, split(/\s*,\s*/, $1);
      push @ports, @newports;
      if( $config{"parsedebug"} ) {
        print "$.: found $type";
        print "s" if $#newports;
        print " ", join(", ", map($_->{"name"}, @newports)), "\n";
      }
    }
    last if $delimiter eq ")";
    $lastdoccom= $doccomment if $keepdoccom;
    $doccomment= "";
  }
  $doccomment= "";
  $keepdoccom= 0;
  return @ports;
}


# Read function or procedure declaration argument list.  Nested parentheses are
# tracked.
# -> optional: Reference to array for hashes representing arguments
# <- String containing complete argument list
sub readarglist
{
  my ($list)= @_;
  my ($arg, $allargs);

  $allargs= "";
  while( 13 ) {
    $arg= "";
    while( 13 ) {
      $vline =~ s/^($SEMIENTRY)//o;
      $arg .= $1;
      last if $vline =~ /^[;)]/;
      my $new= <$vhandle>;
      return undef unless defined($new);
      chomp $new;
      $new =~ s/^($MANY)--.*$/$1/;
      $vline .= " " . $new;
    }
    $allargs .= $arg;
    $vline =~ s/^([;)])//;
    my $delimiter= $1;
    if( $list ) {
      $arg =~ /^\s*(?:(constant|signal|variable|file)\s+)?($IDLIST)\s*:\s*
                  (?:(in|out|inout|buffer|linkage)\s+)?($MSTUFF)
                  (?:\s*:=\s*(\S.*?\S))?\s*$/iox
      and
      push @$list, (map +{ "name", $_, "type", $4, "subtype", lc($1 || ""), 
            "direction", lc($3 || ""), "value", $5 }, split(/\s*,\s*/, $2));
    }
    last if $delimiter eq ")";
    $allargs .= ";";
  }
  return $allargs;
}


# Read a comma-separated list such as a process sensitivity list or a generic
# map.  Nested parentheses are tracked.
# -> optional: Reference to array for two-element arrays representing generic
#    associations.  The first element is the generic name, the second the value.
# <- Complete comma-separated list
sub readcommalist
{
  my ($map)= @_;
  my ($entry, $allentries);

  $allentries= "";
  while( 13 ) {
    $entry= "";
    while( 13 ) {
      $vline =~ s/^($COMMAENTRY)//o;
      $entry .= $1;
      last if $vline =~ /^[,)]/;
      my $new= <$vhandle>;
      return undef unless defined($new);
      chomp $new;
      $new =~ s/^($MANY)--.*$/$1/;
      $vline .= " " . $new;
    }
    $allentries .= $entry;
    $vline =~ s/^([,)])//;
    my $delimiter= $1;
    if( $map && $entry =~ /^\s*($ID)\s*=>(.*)$/io ) {
      my ($key, $val)= ($1, $2);
      $val =~ s/^\s+//;
      $val =~ s/\s+$//;
      push @$map, [ $key, $val ];
    }
    last if $delimiter eq ")";
    $allentries .= ",";
  }
  return $allentries;
}


# Parse the sub-unit statements of a unit declaration.  The occurring sub-units
# are arranged in one or several chains of equations in their order of
# dependency.  Definitions of sub-units occurring in several chanins are not
# repeated.
# -> Reference to hash of units declaration
# (<-) The "chains" entry is assigned an array ref containing the equation
# chains.
sub readunitlist
{
  my ($unitsdecl)= @_;
  my %subunits;
  my @order;
  my %nothead;

  while( 13 ) {
    last unless readuntil( qr/;/ );
    last if $vline =~ /^\s*\bend\b/;
    last unless $vline =~ s/^\s*($ID)\s*=\s*(?:(\d(?:[^;]*[^;\s])?)\s+)?($ID)\s*;//o;
    $subunits{$1}= [ defined($2)? $2 : "", $3 ];
    push @order, $1;
    $nothead{$3}= 1;
  }
  @{$unitsdecl->{"chains"}}= map [ $_ ], grep !$nothead{$_}, @order;
  for my $chain (@{$unitsdecl->{"chains"}}) {
    my $u= $chain;
    while( $subunits{$$u[0]} ) {
      push @$u, $subunits{$$u[0]}->[0], [ $subunits{$$u[0]}->[1] ];
      undef $subunits{$$u[0]};
      $u= $$u[2];
    }
  }
}


# Parse VHDL file (to some extent).
# -> Reference to hash representing file.  It has to have a "type" entry and a 
#    "name" entry giving the file name.
#    Optional IO reference to use instead of STDERR (used to prevent
#    interleaving of messages from different files when parallel parsing)
# (<-) All top-level declarative items found in the file are entered into the
#    file object's "children" entry which is an array reference.  All children
#    receive entries "file" and "filename" which contain a reference to the
#    file hash and the file name, respectively.
#
# Format of the data structure representing declarative items:
# Each VHDL declarative item is represented by a hash.  These hashes all have a
# "type" entry representing the declaration, such as "entity", "architecture",
# "if" for an if clause, "generate" for a generate statement and so on.  Those
# declarations which have identifiers or labels give rise to a "name" entry.
# Sub-declarations such as an entity's ports and generics, nested if clauses,
# loops or generate statements are stored in an array the reference to which is
# the "children" entry in the hash of the parent object.  Other common entries
# are "subtype" (the definition part of a type declaration, a function's return
# type, the type of loop or generate, or type of a variable or constant),
# "objname" (entity or component of an architecture or instantiation) and
# "architecture" (of an instance).  If documentation comments (--*) relating to
# a declarative item are found, they are parsed with parsedoccom(), and the
# resulting array reference is stored in the item's "doc" entry.
sub parsefile
{
  my ($file, $err)= @_;

  my $fname= $file->{"name"};
  my $errflag= 0;
  my $parsdbg= $config{"parsedebug"};
  my @parsestack;
  my @topuses;
  my $parent= $file;
  my $inconfiguration= 0;
  my $label= "";
  my ($prevlevel, $lastdoccom, $keepdoctype);

  $err ||= *STDERR{IO};
  ($vline, $doccomment, $aheaddoccom, $lastdoccom, $keepdoctype)= ("") x 5;
  ($keepdoccom, $keepaheaddoc)= (0, 0);
  open($vhandle, $fname) or croak "Could not open $fname!  Aborting.";
  benchmark() if $config{"benchmark"};
vhdlline:
  while( 13 )
  {
    my $newchild;
    my @newentries;

    while( 13 ) {
      $vline =~ s/^\s+//;
      if( $vline =~ s/^($ID)\s*:\s*// ) {
        $label= $1;
      }
      unless( $vline ) {
        getnextline(0) or last vhdlline;
        next;
      }
      if( $vline =~ /\b(?:protected|postponed|package)\s*$/i ) {
        getnextline(0) and next;
      }
      last;
    }
#    print "investigating $vline\n";
    if( $vline =~ /^(?:end|library|constant|attribute)\b/i ) {
      readuntil( qr/;/ ) or last vhdlline;
      if( $vline =~ s/^end(?:\s+($ID))?(?:\s+($ID|$OP))?\s*;//io ) {
        my ($endtype, $endname, $enditem);
        if( $1 && $2 ) {
          $endtype= lc($1);
          $endname= lc($2);
          $enditem= "$endtype $endname";
        }
        else {
          $enditem= lc($1 || $2 || "");
        }
        if( !@parsestack ) {
          $errflag= 1;
          unless( $config{"quiet"} ) {
            print $err "Spurious \"end";
            print $err " $enditem" if $enditem;
            print $err "\" on or before line $..\n";
          }
        }
        else {
          my $lastlevel= pop(@parsestack);
          if( $enditem && ($endtype ?  $endtype ne $lastlevel->{"type"} || 
                            $endname ne lc($lastlevel->{"name"} || "") :
                            $enditem ne $lastlevel->{"type"} &&
                            $enditem ne lc($lastlevel->{"name"} || "") ) ) {
            $errflag= 1;
            unless( $config{"quiet"} ) {
              print $err "\"end $enditem\" does not match beginning of block \"",
                            $lastlevel->{"type"};
              print $err " ", $lastlevel->{"name"} if $lastlevel->{"name"}; 
              print $err "\" on or before line $. in $fname.";
            }
            # Try to find declaration matching current end statement in parsing
            # stack and previous (deeper) level.  Resynchronise the stack if
            # the result is unique.
            my @matchinds= grep $parsestack[$_]->{"type"} eq $enditem || lc($parsestack[$_]->{"name"} || "") eq $enditem, (0..$#parsestack);
            if( !@matchinds && $prevlevel &&
                ($prevlevel->{"type"} eq $enditem || lc($prevlevel->{"name"} || "") eq $enditem) ) {
              push @parsestack, $lastlevel;
              $lastlevel= $prevlevel;
              print $err "  Resynchronising to previous \"end $enditem\".\n"
                unless $config{"quiet"};
            }
            elsif( @matchinds == 1 ) {
              ($lastlevel)= splice(@parsestack, $matchinds[0]);
              print $err "  Resynchronising to outer $$lastlevel{type} block.\n"
                unless $config{"quiet"};
            }
            else {
              print $err "\n" unless $config{"quiet"};
            }
          }
          $inconfiguration= 0 if $parent->{"type"} eq "configuration";
          $parent= $lastlevel->{"backtrack"};
          $prevlevel= $lastlevel;
          if( $parsdbg ) {
            print "$.: backtracking to ", $parent->{"type"};
            print " ", $parent->{"name"} if $parent->{"name"};
            print "\n";
          }
        }
      }
      elsif( $vline =~ s/^library\s+($IDLIST)\s*;//io ) {
        @newentries= map +{ "type", "library", "name", $_ },
                            split(/\s*,\s*/, $1);
      }
      elsif( $vline =~ s/^attribute\s+($ID)\s+of\s+($AILIST)\s*:\s*
                        ($ID)\s+is\s+($STUFF)\s*;//iox ) {
        my $template= { "type", "attrspec", "name", $1,
                        "objtype", lc($3), "value", $4 };
        my $ailist= $2;
        while( $ailist =~ s/^($AI)(?:\s*,\s*)?//o ) {
          $template->{"objname"}= $1;
          push @newentries, { %$template };
        }
      }
      elsif( $vline =~ s/^(constant|attribute)\s+($IDLIST)\s*:($MSTUFF)
                        (?::=($STUFF))?;//iox ) {
        my ($type, $ids, $subtype, $val)= (lc($1), $2, $3, $4 || "");
        $subtype =~ s/^\s+//;   $subtype =~ s/\s+$//;
        $val =~ s/^\s+//;   $val =~ s/\s+$//;
        @newentries= map +{ "type", $type, "name", $_, 
                "subtype", $subtype, "value", $val }, split(/\s*,\s*/, $ids);
      }
      else {
        $vline =~ s/^$STUFF;//o;
      }
    }
    elsif( !$label && $vline =~ s/^(entity|component|package|packagebody)\b//i ) {
      my $type= lc($1);
      while( $vline !~ /\S/ ) {
        getnextline(0) or last vhdlline;
      }
      if( $vline =~ s/\s+($ID)(?:\s+is\b)?//io  ) {
        $newchild= { "type", $type, "name", $1 };
      }
      else {
        goto skipnext;
      }
    }
    elsif( !$label && $vline =~ /^(?:architecture|configuration|case)\b/i ) {
      last vhdlline unless defined(readuntil( qr/\sis\b/i ));
      if( $vline =~ s/^(architecture|configuration)\s+($ID)\s+
                                of\s+($SID)\s+is\b//iox  ) {
        $newchild= { "type", lc($1), "name", $2, "objname", $3 };
        $newchild->{"objname"} =~ s/\s+//g;
      }
      elsif( $vline =~ s/^case\b$MSTUFF\bis\b//io ) {
        $newchild= { "type", "case", "name", $label };
      }
      else {
        goto skipnext;
      }
    }
    elsif( $vline =~ s/^(?:(procedure|function)|((?:im)?pure))\b//i ) {
      my ($type, $pure)= (lc($1 || ""), lc($2 || "pure"));
      my ($is, $return, $parlist, $params)= ("", "", "", []);
      if( ! $type ) {   # if this started with "pure" or "impure"
        while( $vline !~ /\S/ ) {
          getnextline(0) or last vhdlline;
        }
        goto skipnext unless $vline =~ s/^\s*function\b//i;
        $type= "function";
      }
      last vhdlline unless defined(readuntil( qr/\(|\b(?:is)\b/i ));
      goto skipnext unless $vline =~ s/^\s*($ID|$OP)\s*//o;
      my $name= $1;
      while( 13 ) {
        goto skipnext unless $vline =~ s/^\s*(\(|\b(?:is|return)\b|;)//i;
        if( $1 eq "(" && !$parlist ) {
          $parlist= readarglist($params);
          last vhdlline unless defined(readuntil( qr/\bis\b/i ));
        }
        elsif( lc($1) eq "return" ) {
          goto skipnext if $type eq "procedure";
          $vline =~ s/^($MSTUFF)(?:\b(is)\b|;)//io;
          ($return, $is)= ($1, $2);
          $return =~ s/^\s+//;
          $return =~ s/\s+$//;
          last;
        }
        elsif( lc($1) eq "is" || $1 eq ";" ) {
          $is= $1 ne ";";
          next vhdlline if $type eq "function";
          # We will get here for a function only if no return type is present.
          # We do not use "goto skipnext" because the ";" may already have been
          # removed.
          last;
        }
      }
      $newchild= { "type", $type, "name", $name, "parlist", $parlist,
                    "parameters", $params };
      @$newchild{qw(subtype pure)}= ($return, $pure) if $type eq "function";
      if( !$is ) {
        @newentries= ( $newchild );
        $newchild= undef;
      }
      if( @parsestack == 1 ) {
        push @{$parent->{"childtype"}->{"funcproc"}}, @newentries;
        push @{$parent->{"childtype"}->{"funcproc"}}, $newchild if $newchild;
      }
    }
    elsif( $vline =~ s/^((?:postponed)?process|block)\b//i &&
            ($label || lc($1) ne "block") ) {
      my ($name, $type, $post)= ($label, lc($1) eq "block"? "block":"process",
                                    lc($1) eq "postponedprocess");
      my $list= "";
      while( 13 ) {
        if( $vline =~ s/^\s*(\S)// ) {
          if( $1 eq "(" ) {
            $doccomment .= $aheaddoccom;
            $keepdoccom ||= $keepaheaddoc;
            $aheaddoccom= "";
            $keepaheaddoc= 0;
            $list= readcommalist();
          }
          else {
            $vline= $1 . $vline;
          }
          last;
        }
        getnextline(1) or last vhdlline;
      }
      $newchild= { "type", $type, "name", $name };
      if( $type eq "block" ) {
        $newchild->{"guard"}= $list;
      }
      else {
        @$newchild{qw(postponed sensitivity)}= ($post, $list);
        if( @parsestack && $newchild->{"type"} eq "process" ) {
          # List all processes to avoid recursive searches later
          my $top= @parsestack > 1? $parsestack[1]->{"backtrack"} : $parent;
          push @{$top->{"allprocesses"}}, $newchild;
        }
      }
    }
    elsif( $vline =~ s/^if\b//i ) {
      last vhdlline unless defined(readuntil( qr/\b(?:generate|then)\b/i ));
      if( $vline =~ s/^($MSTUFF)(\b(?:generate|then)\b|;)//io )  {
        my ($stuff, $keyword)= ($1, lc($2));
        if( $keyword eq "then" ) {
          $newchild= { "type", "if", "name", $label };
        }
        elsif( $label ) {
          $stuff =~ s/^\s+//;
          $stuff =~ s/\s+$//;
          $newchild= { "type", "generate", "subtype", "if", "name", $label,
                      "parameters", $stuff };
        }
      }
    }
    elsif( $vline =~ s/^(while|loop)\b//i ) {
      $newchild= { "type", "loop", "name", $label, "subtype", lc($1) };
      if( $newchild->{"subtype"} ne "loop" ) {
        skipuntil( qr/\bloop\b/i );
      }
    }
    elsif( $vline =~ s/^((?:sub)?type)\b//i ) {
      my $sub= lc($1);
      last vhdlline unless
       defined(readuntil( qr/\b(?:record|protected|protectedbody)\b/i ));
      if( $vline =~ s/^\s*($ID)\s+is\b\s*
            (?:\b(record|protected|protectedbody)\b|($MSTUFF);)//iox ) {
        my ($name, $sub2, $typedef)= ($1, $2, $3);
        $newchild= { "type", "type", "subtype", lc($sub2 || $sub),
                     "name", $name };
        if( $sub2 ) {
          $newchild->{"type"}= lc($sub2);
          # This "type" serves only for recognising "end", will be undone later
          if( $newchild->{"subtype"} eq "record" ) {
            $newchild->{"doc"}= parsedoccom($doccomment) if $doccomment;
            $doccomment= "";
            @newentries= readportlist("recordelement");
          }
        }
        else {
          $typedef =~ s/^\s+//;
          $typedef =~ s/\s+$//;
          $newchild->{"definition"}= $typedef;
          if( $newchild->{"definition"} =~ s/\s*\bunits\s+($ID)$//i ) {
            $newchild->{"type"}= $newchild->{"subtype"}= "units";
            $newchild->{"baseunit"}= $1;
            $newchild->{"doc"}= parsedoccom($doccomment) if $doccomment;
            readuntil( qr/;/ ) && $vline =~ s/^\s*;//;
            readunitlist($newchild);
            $doccomment= "";
          }
          else {
            @newentries= ( $newchild );
            $newchild= undef;
          }
        }
      }
      else {
        goto skipnext;
      }
    }
    elsif( $vline =~ s/^for\b//i ) {
      while( 13 ) {
        if( $inconfiguration && $vline =~ s/^\s*($ID)\s*(for)/$2/io ) {
          $newchild= { "type", "for", "subtype", "architecture", "objname", $1 };
          # leave $aheaddoccom as it is
          last;
        }
        elsif( $vline =~ s/^$MSTUFF\bloop\b//io ) {
          $newchild= { "type", "loop", "name", $label, "subtype", "for" };
        }
        elsif( $label && $vline =~ s/^\s*($MSTUFF)\s*\bgenerate\b//io ) {
          $newchild= { "type", "generate", "subtype", "for", "name", $label,
                      "parameters", $1 };
        }
        elsif( $vline =~ s/^\s*($IDLIST)\s*:\s*($ID)//io ) {
          $newchild= { "type", "for", "subtype", "instance", "objtype", $2,
                                         "objnames", [split(/\s*,\s*/, $1)] };
          unless( $inconfiguration ) {
            @newentries= ( $newchild );
            undef $newchild;
          }
        }
        elsif( $vline =~ s/^$STUFF;//o ) {
          last;
        }
        else {
          getnextline(1) or last vhdlline;
          next;
        }
        $doccomment .= $aheaddoccom;
        $keepdoccom ||= $keepaheaddoc;
        $aheaddoccom= "";
        $keepaheaddoc= 0;
        last;
      }
    }
    elsif( $vline =~ s/^use\b//i ) {
      last vhdlline unless defined(readuntil( qr/\b(?:generic|port)\b/i ));
      if( $vline =~ s/^\s*(?:(entity)\s+($SID)(?:\s*\(\s*($ID)\s*\))?|
                        (configuration)\s+($SID)|(open)\b)//iox ) {
        @newentries= ( { "type", "use", "subtype", lc($1 || $4 || $6), 
                            "name", $2 || $5, "archname", $3 } );
        $newentries[0]->{"name"} =~ s/\s+//g;
        $newentries[0]->{"for"}= $parent->{"children"}->[-1]
              if $parent->{"children"} && @{$parent->{"children"}}
                && $parent->{"children"}->[-1]->{"type"} eq "for"
                && $parent->{"children"}->[-1]->{"subtype"} eq "instance";
      }
      elsif( $vline =~ s/^\s*($SIDLIST)\s*;//o ) {
        @newentries= map +{ "type", "use", "subtype", "package", "name", $_ },
                                                  split(/\s*,\s*/, $1);
        map { $_->{"name"} =~ s/\s+//g; } @newentries;
      }
      else {
        goto skipnext;
      }
    }
    elsif( $vline =~ s/^(generic|port)\b//i ) {
      my $type= lc($1);
      last vhdlline unless defined(readuntil( qr/\(/ ));
      if( $vline =~ s/^\s*\(//i ) {
        @newentries= readportlist($type);
      }
      elsif( $type eq "generic" && $vline =~ s/^\s*map\s*\(//i ) {
        my $genmap= [];
        readcommalist($genmap);
        @newentries= ( { "type", "genericmap", "map", $genmap } );
        skipstatement() or last vhdlline;
        if( $parent->{"children"} && @{$parent->{"children"}} ) {
          $parent->{"children"}->[-1]->{"genericmap"}= $newentries[0];
        }
        else {
          $parent->{"genericmap"}= $newentries[0];
        }
      }
      else {
        goto skipnext;
      }
    }
    elsif( $config{"psl"} && $vline =~ s/^(property|sequence|endpoint)\b//i ) {
      @newentries= ( { "type", "psl", "subtype", lc($1) } );
      defined(readuntil( qr/\(/ )) or last vhdlline;
      $vline =~ s/^\s*($ID)\s*//o or next vhdlline;
      $newentries[0]->{"name"}= $1;
      if( $vline =~ /^\(/ ) {
        while( 13 ) {
          if( $vline =~ s/^($PAREN)//o ) {
              $newentries[0]->{"parlist"}= $1;
              $newentries[0]->{"parlist"} =~ s/^\(\s*//;
              $newentries[0]->{"parlist"} =~ s/\s*\)$//;
              last;
          }
          getnextline(0) or last vhdlline;
        }
      }
      my $psl;
      while( 13 ) {
        if( $vline =~ s/^($PSL);//o ) {
          $newentries[0]->{"value"}= $1;
          $newentries[0]->{"value"} =~ s/^\s*is\b\s*//i;
          $newentries[0]->{"value"} =~ s/\s*$//;
          last;
        }
        getnextline(0) or last vhdlline;
      }
      if( @parsestack ) {
        # List all PSL definitions to avoid recursive searches
        my $top= @parsestack > 1? $parsestack[1]->{"backtrack"} : $parent;
        push @{$top->{"allpsldefs"}}, @newentries;
      }
    }
    elsif( $config{"psl"} && $vline =~ s/^default\b//i ) {
      defined(readuntil(qr/;/)) or last vhdlline;
      $vline =~ s/^\s*clock\s+is\b\s*($MSTUFF)\s*;//i or next vhdlline;
      @newentries= ( { "type", "psl", "subtype", "default clock", "value", $1 } );
    }
    elsif( $config{"psl"} && $vline =~ s/^(assert|assume|assume_guarantee|
                                  restrict|restrict_guarantee|cover)\b//ix ) {
      my $subtype= lc($1);
      my $psl;
      while( 13 ) {
        if( $vline =~ s/^($PSL);//o ) {
          $psl= $1;
          last;
        }
        getnextline(0) or last vhdlline;
      }
      @newentries= ( { "type", "psl", "subtype", $subtype, "name", $label } );
      if( $subtype =~ /^(?:assert|assume_guarantee|restrict_guarantee|cover)$/
          && $psl =~ s/\breport\s+($MSTUFF)\s*$//io ) {
        $newentries[0]->{"report"}= $1;
      }
      $psl =~ s/^\s+//;
      $psl =~ s/\s+$//;
      if( $subtype =~ /^(?:assert|assume|assume_guarantee)$/ ) {
        $newentries[0]->{"property"}= $psl;
      }
      else #  elsif( $subtype =~ /^(?:restrict|restrict_guarantee|cover)$/ )
      {
        $newentries[0]->{"sequence"}= $psl;
      }
    }
    # Instantiations
    elsif( $label && $vline =~ /^$SID/o ) {
      last vhdlline unless defined(readuntil( qr/\bmap\s*\(/i ));
      goto skipnext unless
          $vline =~ s/^(?>(?:(component|configuration|entity)\s+)?)
            ($SID)(?:\s*\(\s*($ID)\s*\))?\s*(generic|port)\s+map\s*\(//iox;
      my $genmap= [];
      my $firstmap= lc($4);
      @newentries= ( { "type", "instance", "name", $label, "objname", $2,
                          "subtype", lc($1 || "component"), "archname", $3,
                          "genericmap", $genmap, "uses",
                      [ @parsestack ? @{$parsestack[-1]->{"uses"}} : () ] } );
      $newentries[0]->{"objname"} =~ s/\s+//g;
      readcommalist($genmap) if $firstmap eq "generic";
      if( @parsestack ) {
        # List all instances to avoid recursive searches later
        my $top= @parsestack > 1? $parsestack[1]->{"backtrack"} : $parent;
        push @{$top->{"allinstances"}}, @newentries;
      }
    }
    elsif( $vline =~ s/^(?:(?:else|begin|is)\b|;)//i ) {}
    elsif( $vline =~ s/^elsif\b//i ) {
      skipuntil(qr/\bthen\b/i);
    }
    elsif( $vline =~ s/^when\b//i ) {
      skipuntil(qr/=>/i);
    }
    else {
skipnext:
      skipstatement() or last vhdlline;
      $keepdoccom= 0;
      next vhdlline;
    }
    if( $newchild ) {
      $keepdoccom= 0;
      $newchild->{"doc"}= parsedoccom($doccomment) if $doccomment;
      push @{$parent->{"children"}}, $newchild;
      if( @parsestack == 0 ) {
        $newchild->{"uses"}= [ @topuses ];
      }
      elsif( @parsestack == 1 ) {
        # List children by type for top-level constructs
        push @{$parent->{"childtype"}->{$newchild->{"type"}}}, $newchild;
      }
      push @parsestack, { "backtrack", $parent, 
              "type", $newchild->{"type"}, "name", $newchild->{"name"},
              "uses" => [ @parsestack ? @{$parsestack[-1]->{"uses"}} : () ] };
      $prevlevel= undef;
      $inconfiguration= 1 if $newchild->{"type"} eq "configuration";
      $parent= $newchild;
      if( $parsdbg ) {
        print "$.: descending into ", $newchild->{"type"};
        print " ", $newchild->{"name"} if $newchild->{"name"};
        print "\n";
      }
    }
    if( @newentries ) {
      if( !$doccomment && $keepdoccom ) {
        $keepdoccom= 0 unless $newentries[0]->{"type"} eq $keepdoctype;
        $doccomment= $lastdoccom if $keepdoccom;
      }
      if( $doccomment && !($config{"compat"} && !@parsestack) ) {
        if( $keepdoccom ) {
          $lastdoccom= $doccomment;
          $keepdoctype= $newentries[0]->{"type"};
        }
        $doccomment= parsedoccom($doccomment);
        foreach (@newentries) { $_->{"doc"}= $doccomment; }
        # non-empty $aheaddoccom occurs only for $newchild blocks
        $doccomment= "";
      }
      push @{$parent->{"children"}}, @newentries;
      if( @parsestack == 1 ) {
        # List children by type for top-level constructs.  This relies on all
        # new entries having the same type.
        push @{$parent->{"childtype"}->{$newentries[0]->{"type"}}}, @newentries;
      }
      if( $newentries[0]->{"type"} eq "use" ) {
        # List all use clauses to avoid recursive searches later
        if( @parsestack ) {
          my $top= @parsestack > 1? $parsestack[1]->{"backtrack"} : $parent;
          push @{$top->{"alluses"}}, @newentries;
          push @{$parsestack[-1]->{"uses"}}, @newentries;
        }
        else {
          push @topuses, @newentries;
        }
      }
      if( $parsdbg && $newentries[0]->{"type"} !~ /^(?:port|generic)$/ ) {
        # "found..." message already output in readportlist() for ports/gens
        print "$.: found ", $newentries[0]->{"type"};
        print "s" if $#newentries;
        print " ", join(", ", map($_->{"name"}, @newentries))
              if $newentries[0]->{"name"};
        print "\n";
      }
    }
  }
  continue {
    $doccomment= "" unless $config{"compat"} && !@parsestack;
    $doccomment .= $aheaddoccom;
    $keepdoccom ||= $keepaheaddoc;
    $aheaddoccom= "";
    $keepaheaddoc= 0;
    $label= "";
  }
done:
  benchmark("to parse", $.) if $config{"benchmark"};
  close $vhandle;
  if( @parsestack ) {
    print $err "Not all blocks were closed - missing one or more \"end\"s.\n";
    $errflag= 1;
  }
  $file->{"uses"}= \@topuses;
  # Remove the declarative blocks we are not interested in, which we parsed
  # only to keep track of nesting:
  prune_all($file, "type", "loop");
  prune_all($file, "type", "if");
  prune_all($file, "type", "case");
  map { $_->{"filename"}= $fname; $_->{"file"}= $file; } @{$file->{"children"} ||= []};
  print $err "There were errors parsing $fname.  Continuing regardless.\n"
        if $errflag;
}

}   # End of scope of parsing variables


# Compare the hash representations of two functions or procedures for finding
# equivalent declarations in a package and its package body.  The types of the
# two declarations (function or procedure) are not compared and are assumed to
# be equal.
# -> Two references to hashes representing declarative items
# <- 1 if equal, 0 otherwise
sub packsubeq
{
  my ($a, $b)= @_;

  return 0 if lc($a->{"name"}) ne lc($b->{"name"});
  if( $a->{"type"} eq "function" ) {
    return 0 if $a->{"pure"} ne $b->{"pure"} ||
                codecmp($a->{"subtype"}, $b->{"subtype"});
  }
  return 0 if @{$a->{"parameters"}} != @{$b->{"parameters"}};
  for my $ind (0..$#{$a->{"parameters"}}) {
    my $pa= $a->{"parameters"}->[$ind];
    my $pb= $b->{"parameters"}->[$ind];
    return 0 if lc($pa->{"name"}) ne lc($pb->{"name"}) ||
                $pa->{"subtype"} ne $pb->{"subtype"} ||
                $pa->{"direction"} ne $pb->{"direction"} ||
                codecmp($pa->{"type"}, $pb->{"type"}) ||
                defined($pa->{"value"}) != defined($pb->{"value"}) ||
          (defined($pa->{"value"}) && codecmp($pa->{"value"}, $pb->{"value"}));
  }
  return 1;
}


# Set maximum message size and default number of tasks for parallel parsing.
# Returns immediately if parallel parsing is disabled.
sub prepareparallel
{
  my $msg="x" x 256;
  my $sent;

  return if defined($config{"jobs"}) && !$config{"jobs"};

  # Find maximum message size for socketpair by trial and error:
  if( ! eval { socketpair(SEND, RECV, AF_UNIX, SOCK_DGRAM, PF_UNSPEC) } ) {
    print STDERR "Cannot use multiple parsing tasks because the socketpair function is not available.  Parsing sequentially.\n"
      if $config{"jobs"} && !$config{"quiet"};
    $config{"jobs"}= 0;
    return;
  }
  while( length($msg) < 0x1000000 && 
      defined($sent= send(SEND, $msg, 0)) && $sent == length($msg) ) {
    recv(RECV, $_, length($msg), 0);
    $msg .= $msg;
  }
  my $eighth= length($msg) / 4;
  substr($msg, -$eighth)= "";
  for (1, 2, 3)  {
    $sent= send(SEND, $msg, 0);
    if( defined($sent) && $sent == length($msg) ) {
      recv(RECV, my $dummy, length($msg), 0);
      last;
    }
    substr($msg, -$eighth)= "";
  }
  $config{"maxmsgsize"}= length($msg);

  if( !defined($config{"jobs"}) ) {
    if( $^O ne "MSWin32" && $^O ne "MacOS" ) {
      my $tsbits= `taskset -p $$`;
      $tsbits =~ s/^.*:\s+//;
      $config{"jobs"}= $? == 0 ? counthexbits($tsbits) : 3;
      $config{"jobs"}= 0 if $config{"jobs"} <= 1;
    }
    else {
      $config{"jobs"}= 3;
    }
  }
}


# Worker task used when parallelising parsing.  Receives serialised file hashes
# containing the file name, calls parsefile() and serialises the completed file
# hashes and transmits them back.
# -> Task index (unused, possibly usable for error messages)
#    Socket connected to main task (controller)
sub parsetask
{
  my ($taskind, $sock)= @_;
  my ($errhandle, $errmsg);

  open $errhandle, ">", \$errmsg;
  while( 13 ) {
    my $file= recvdata($sock);
    last if $file->{"die"} && $file->{"die"} eq "yes, really";
    $errmsg= "";
    parsefile($file, $errhandle);
    $file->{"errmsg"}= $errmsg;
    senddata($sock, $file);
  }
  close $errhandle;
}


{
my @parsetasks;
my $recvsockmask;

# Fork parsing tasks.  Hash references containing the process ID and
# communication socket are added to @parsetasks.
sub createtasks
{
  $recvsockmask= "";
  for my $ind (0..$config{"jobs"}-1)
  {
    my ($workersock, $controlsock);
    if( !eval { socketpair($workersock, $controlsock, AF_UNIX, SOCK_DGRAM, PF_UNSPEC) } ) {
      print STDERR "Could not create socketpair for communication with parsing task $ind.  Terminating.\n";
      killslaves();
      exit 1;
    }
    my $pid= fork();
    if( !defined($pid) ) {
      print STDERR "Could not fork parsing task $ind.  Terminating.\n";
      killslaves();
      exit 1;
    }
    if( !$pid ) {       # forked slave process
      close $controlsock;
      @parsetasks= ();
      parsetask($ind, $workersock);
      exit(0);
    }
    close $workersock;
    push @parsetasks,
      { "socket" => $controlsock, "fileno" => fileno($controlsock), "pid" => $pid };
    vec($recvsockmask, $parsetasks[-1]->{"fileno"}, 1)= 1;
  }
}


# Send a value to all worker tasks to tell them to terminate.
sub destroytasks
{
  for my $ind (0..$#parsetasks) {
    senddata($parsetasks[$ind]->{"socket"}, { "die" => "yes, really" });
  }
  @parsetasks= ();
}


# Test whether any of the parsing tasks has finished its current file by
# checking if the socket file descriptors are readable.
# <- Index of the first task that has completed parsing its file, or undef
sub parsedone
{
  my $donemask= $recvsockmask;

  return undef unless select($donemask, undef, undef, undef);
  for my $ind (0..$#parsetasks) {
    return $ind if vec($donemask, $parsetasks[$ind]->{"fileno"}, 1);
  }
  return undef;
}


my $parsefileind;

# Parse a list of VHDL files and return them one at a time.
sub parsenext
{
  my ($files)= @_;

  if( $config{"jobs"} == 0 ) {
    $parsefileind= 0 unless defined $parsefileind;
    return undef if $parsefileind > $#$files;
    print "Parsing $$files[$parsefileind]->{name}...\n" unless $config{"quiet"};
    parsefile($$files[$parsefileind]);
    markgit($$files[$parsefileind]);
    ++$parsefileind;
    return $parsefileind - 1;
  }
  else {
    if( !defined($parsefileind) ) {
      createtasks();
      $parsefileind= 0;
    }
    my $inprogress= 0;
    for my $task (@parsetasks) {
      if( !defined($task->{"fileind"}) && $parsefileind < @$files ) {
        senddata($task->{"socket"}, $$files[$parsefileind]);
        $task->{"fileind"}= $parsefileind;
        ++$parsefileind;
      }
      ++$inprogress if defined $task->{"fileind"};
    }
    return undef unless $inprogress;
    my $donetaskind;
    do { $donetaskind= parsedone(); } while( ! defined $donetaskind );
    my $donefileind= $parsetasks[$donetaskind]->{"fileind"};
    $$files[$donefileind]= recvdata($parsetasks[$donetaskind]->{"socket"});
    my $file= $$files[$donefileind];
    print "Parsed $file->{name}", ($file->{"errmsg"}? ":\n" : ".\n")
        unless $config{"quiet"};
    print STDERR $file->{"errmsg"} if $file->{"errmsg"};
    delete $file->{"errmsg"};
    markgit($file);
    $parsetasks[$donetaskind]->{"fileind"}= undef;
    return $donefileind;
  }
}

}


##############################################################################
##############################################################################
####                    Data handling functions
##############################################################################
##############################################################################


# Make list of source file unique.  A warning message is output if duplicates
# are found, and all but one of them are removed from the file list.
# -> Reference to array of references to hashes representing files
# <- 1 if duplicates were found and removed.
sub uniq_files
{
  my ($files)= @_;
  my $removed= 0;
  # Don't use File::Spec->curdir(), it takes 1 second (!)
  my $cwd= $config{"cwd"};

  for my $elem (@$files) {
    my $absname= mycanonpath(File::Spec->rel2abs($elem->{"name"}, $cwd));
    for my $elem2 (@$files) {
      next unless defined($elem2);
      last if $elem2 == $elem;
      if( $absname eq
                mycanonpath(File::Spec->rel2abs($elem2->{"name"}, $cwd)) ) {
        unless( $config{"quiet"} ) {
          print STDERR "Duplicate source file ", $elem2->{"name"};
          if( $elem->{"libname"} ne $elem2->{"libname"} ) {
            print STDERR ", in libraries ", $elem2->{"libname"}, " and ",
                      $elem->{"libname"}, ".  Discarding the one in library ",
                      $elem->{"libname"}, ".\n";
          }
          else {
            print STDERR " in library ", $elem->{"libname"}, ".\n";
          }
        }
        $elem= undef;
        $removed= 1;
        last;
      }
    }
  }
  @$files= grep defined($_), @$files;
  return $removed;
}


# Find children of a declarative item which fulfil a condition
# -> Reference to declarative item represented as hash
#    Key to compare
#    Requested value of that key in a (direct) child of the decl. item
# <- Array of matching children
sub find_children
{
  my ($obj, $key, $val)= @_;

  return () unless $obj->{"children"};
  return grep lc($_->{$key}) eq lc($val), @{$obj->{"children"}};
}


# Returns the maximal depth of a part of the declaration hierarchy
# -> Reference to the hash which is the root of the appropriate part of the
#    hierarchy
# <- Depth (0 if the root has no children, and so on)
sub max_depth
{
  my ($root)= @_;
  my $maxd= 0;

  if( !$root->{"children"} || !@{$root->{"children"}} ) {
    return 0;
  }
  for my $child (@{$root->{"children"}}) {
    my $childd= max_depth($child);
    $maxd= $childd if $maxd < $childd;
  }
  return $maxd+1;
}


# Finds all nodes of a certain type in a subtree
# -> Reference to hash representing root node
#    Key of entry to be compared
#    Value of that key in the searched-for nodes (case insensitive string 
#    comparison)
# <- Array of hash (node) references
sub find_all
{
  my ($root, $key, $val)= @_;
  my @all;

  $val= lc($val);
  push @all, $root if lc($root->{$key}) eq $val;
  for my $child (@{$root->{"children"}}) {
    push @all, (find_all($child, $key, $val));
  }
  return @all;
}


# Finds all nodes of a certain type in a subtree and returns their paths in the
# tree
# -> Reference to hash representing root node
#    Key of entry to be compared
#    Value of that key in the searched-for nodes (case insensitive string 
#    comparison)
# <- Array of references to arrays of hash (node) references
sub trace_all
{
  my ($root, $key, $val)= @_;
  my @all;

  $val= lc($val);
  push @all, [ ] if lc($root->{$key}) eq $val;
  for my $child (@{$root->{"children"}}) {
    my @new= trace_all($child, $key, $val);
    map { unshift @$_, $child } @new;
    push @all, @new;
  }
  return @all;
}


# Deletes all nodes of a certain type in a subtree, including their children
# -> Reference to hash representing root node
#    Key of entry to be compared
#    Value of that key in the nodes to be pruned (string comparison)
sub prune_all
{
  my ($root, $key, $val)= @_;

  return unless $root->{"children"};
  $val= lc($val);
  @{$root->{"children"}}= grep(lc($_->{$key}) ne $val, @{$root->{"children"}});
  for my $child (@{$root->{"children"}}) {
    prune_all( $child, $key, $val );
  }
}


# Remove equivalent objects (references to their hashes) from an array.  All
# objects in the array have to be of the same type and situated in the same
# library.  They are considered equivalent if their names are equal and (for
# architectures and configurations) if their entity has the same name.  A
# warning is printed if there are duplicates and unless $config{"quiet"}.
# -> Reference to the array of objects
# <- 1 if elements were removed
sub uniq_objs
{
  my ($ary)= @_;
  return 0 unless @$ary;
  my $type= $ary->[0]->{"type"};
  my %byname;
  my $removed= 0;

  if( $type eq "architecture" || $type eq "configuration" ) {
    my $ind= 0;
    for my $elem (@$ary) {
      push @{$byname{lc($elem->{"name"})}->{lc($elem->{"objname"})}}, $ind;
      ++$ind;
    }
    for my $name (keys %byname) {
      for my $objname (keys %{$byname{$name}}) {
        my @all= @{$byname{$name}->{$objname}};
        next unless @all > 1;
        print STDERR ucfirst($type), " ", $$ary[$all[0]]->{"name"},
             " of ", $$ary[$all[0]]->{"objname"}, " was found ",
             @all > 2 ? (0+@all)." times" : "twice", ", in:\n   ",
             join("\n   ", map $$ary[$_]->{"filename"}, @all),
             "\nKeeping the one from ", $$ary[$all[0]]->{"filename"}, ".\n"
            unless $config{"quiet"};
        @$ary[@all[1..$#all]]= (undef) x $#all;
        $removed= 1;
      }
    }
  }
  else {
    my $ind= 0;
    for my $elem (@$ary) {
      push @{$byname{lc($elem->{"name"})}}, $ind;
      ++$ind;
    }
    for my $name (keys %byname) {
      my @all= @{$byname{$name}};
      next unless @all > 1;
      print STDERR ucfirst($type), " ", $$ary[$all[0]]->{"name"}, " was found ",
           @all > 2 ? (0+@all)." times" : "twice", ", in:\n   ",
           join("\n   ", map $$ary[$_]->{"filename"}, @all),
           "\nKeeping the one from ", $$ary[$all[0]]->{"filename"}, ".\n"
          unless $config{"quiet"};
      @$ary[@all[1..$#all]]= (undef) x $#all;
      $removed= 1;
    }
  }
  @$ary= grep defined($_), @$ary;
  return $removed;
}


# Finds the corresponding declarations for each attribute specification, and
# assigns the specifications to their targets.  The targets receive a new entry
# "attributes" in their hash which references a hash in which the keys are
# references to the attribute declarations and the values to the
# specifications.
# -> Hash reference representing top-level declarative item.  Only its
#    (first-level) children are considered when searching for attributes, and
#    only its children and itself are candidates for targets.
sub match_attributes
{
  my ($top)= @_;
  my @aspecs= @{$top->{"childtype"}->{"attrspec"} || []};
  my @adecls= @{$top->{"childtype"}->{"attribute"} || []};

  for my $aspec (@aspecs) {
    for my $adecl (@adecls) {
      if( lc($adecl->{"name"}) eq lc($aspec->{"name"}) ) {
        $aspec->{"attribute"}= $adecl;
        last;
      }
    }
  }
  for my $aspec (@aspecs) {
    if( $top->{"type"} eq $aspec->{"objtype"} && 
        lc($top->{"name"}) eq lc($aspec->{"objname"}) ) {
      $top->{"attributes"}->{$aspec->{"name"}}= $aspec;
      next;
    }
    my @targets;
    if( $aspec->{"objtype"} eq "label" ) {
      @targets= ( @{$top->{"allinstances"}}, @{$top->{"allprocesses"}} );
      # Many other labels can have attributes but only those of instances and
      # processes are of interest to us
    }
    elsif( $aspec->{"objtype"} =~
        /^(?:entity|architecture|configuration|package|packagebody)$/ ) {
      @targets= ( $top )
        if $aspec->{"objtype"} eq $top->{"type"};
    }
    else {
      @targets= @{$top->{"childtype"}->{$aspec->{"objtype"}} || []};
    }
    next unless @targets;
    if( lc($aspec->{"objname"}) eq "all" ) {
      map { $_->{"attributes"}->{$aspec->{"name"}}= $aspec; } @targets;
    }
    elsif( lc($aspec->{"objname"}) eq "others" ) {
      for my $target (@targets) {
        $target->{"attributes"}->{$aspec->{"name"}}= $aspec
                unless $target->{"attributes"}->{$aspec->{"name"}};
      }
    }
    else {
      my $truncname= $aspec->{"objname"};
      $truncname =~ s/\s*\[.*$//;
      $truncname= lc($truncname);
      @targets= grep lc($_->{"name"}) eq $truncname, @targets;
      next unless @targets;
      if( ($aspec->{"objtype"} eq "function" || 
        $aspec->{"objtype"} eq "procedure") && $aspec->{"objname"} =~ /\[/ ) {
        my @argtypes;
        my $arglist;
        $arglist= $aspec->{"objname"};
        $arglist =~ s/^.*\[\s*//;
        $arglist =~ s/\s*\]\s*$//;
        @argtypes= split /\s*(?:,|\breturn\b)\s*/i, $arglist;
        my $returntype= pop @argtypes if $arglist =~ /\breturn\b/i;
tryfunctarget:
        for my $target (@targets) {
          next if $returntype && $target->{"subtype"} !~ /\b$returntype\b/i;
          next if $#argtypes != $#{$target->{"parameters"}};
          for my $ind (0..$#argtypes) {
            my $type= $argtypes[$ind];
            next tryfunctarget
                if $target->{"parameters"}->[$ind]->{"type"} !~ /\b$type\b/i;
          }
          $target->{"attributes"}->{$aspec->{"name"}}= $aspec;
        }
      }
      else {
        map { $_->{"attributes"}->{$aspec->{"name"}}= $aspec; } @targets;
      }
    }
  }
}


# Blacklist to avoid false positives when searching type expressions for
# user-defined types: (this is merely an optimisation)
my %no_usertypes= map { $_ => 1; } qw( array of to downto range integer
positive natural boolean real string character time std_ulogic
std_ulogic_vector std_logic std_logic_vector signed unsigned );

# Resolve type identifiers of user-defined types.  This is deliberately less
# sophisticated than the resolving of component instances below, because typed
# declarations are more numerous and hence the impact on runtime is likely to
# be larger, and less important.  Only type declarations accessible within the
# same top-level construct or via package use statements are taken into
# account.  And it is assumed that each type designation can only contain one
# user-defined type.
# -> Top-level construct containing the following declarations
#    List of typed declarations possibly referencing user-defined types
sub resolve_types
{
  my ($obj)= shift;
  my %resolved;
  my %unresolved= %no_usertypes;
  my $typedef;

  my @puses= reverse grep $_->{"package"}, @{$obj->{"uses"}};
  my @puses2= grep $_->{"name"} =~ tr/././ == 1, @puses;
  my @puses3= grep $_->{"name"} =~ tr/././ == 2, @puses;
  @puses= ();
  for my $typed (@_) {
    my $typeexpr= $typed->{$typed->{"type"} eq "type" ? "definition" : "subtype"};
    next unless $typeexpr;
    my @ids= $typeexpr =~ /$SID/g;
typeexprid:
    for my $id (@ids) {
      $id= lc($id);
      next if $unresolved{$id};
      $typed->{"typedef"}= $resolved{$id}, last if $resolved{$id};
      my $numdots= $id =~ tr/././;
      if( $numdots > 2 ) {
        $unresolved{$id}= 1;
        next;
      }
      elsif( $numdots == 2 ) {
        $typedef= find_selname($id, "type");
      }
      elsif( $numdots == 1 ) {
        for my $use (@puses2) {
          my $selname= merge_selname($use->{"name"}, $id);
          next unless $selname;
          $typedef= find_selname($selname, "type");
          next unless $typedef;
          $resolved{$selname}= $typedef if $typedef;
          last;
        }
        unless( $typedef ) {
          my $selname= $obj->{"libname"}.".".$id;
          $typedef= find_selname($selname, "type");
          $resolved{$selname}= $typedef if $typedef;
        }
      }
      else {
        ($typedef)= grep lc($_->{"name"}) eq $id, @{$obj->{"childtype"}->{"type"}};
        unless( $typedef ) {
          for my $use (@puses3) {
            my $selname= merge_selname($use->{"name"}, $id);
            next unless $selname;
            $typedef= find_selname($selname, "type");
            next unless $typedef;
            $resolved{$selname}= $typedef if $typedef;
            last;
          }
        }
      }
      if( $typedef ) {
        if( !ref($typedef) ) {
            print "typedef is >$typedef< for $id\n";
        }
        $resolved{$id}= $typedef;
        $typed->{"typedef"}= $typedef;
        last;
      }
      else {
        $unresolved{$id}= 1;
      }
    }
  }
}


# Try to merge the selected name in a package use clause with the selected name
# describing an entity, component, configuration or similar.  The rightmost
# part of the use clause name has to be the same as the leftmost part of the
# entity selected name, or the rightmost part of the use clause name has to be
# "all" for this to succeed.  The total number of components (separated by ".")
# of the result must be at most 3.
# -> Selected name from use clause
#    Selected name of object
# <- Merged name or undef
sub merge_selname
{
  my ($suse, $sobj)= @_;
  my $selname;

  $suse =~ s/\.all$//i;
  $selname= $suse . "." . $sobj;
  $selname =~ s/\.([^.]+)\.\1\./.$1./i;
  return ($selname =~ tr/././) <= 2 ? $selname : undef;
}


{

# Table of selected names.  Those tables which will be searched are initialised
# up-front to avoid "can't use undef as hash ref" errors.
my %selnames= map { $_ => {}; }
  qw(entity architecture configuration package packagebody component type psl);
# Dummy scalar the reference to which indicates that multiple objects with that
# name and type exist.
my $multiple;

# Add objects to the table of selected names applicable for their type.
# -> Prefix (for top-level constructs, this is the library name, for
#    declarations in packages, this is "library.package")
#    List of objects
sub add_selnames
{
  my $prefix= shift;

  for (@_) {
    my $table= $selnames{$_->{"type"}};
    if( $table->{lc($_->{"name"})} ) {
      $table->{lc($_->{"name"})}= \$multiple;
    }
    else {
      $table->{lc($_->{"name"})}= $_;
    }
    $table->{lc($prefix . "." . $_->{"name"})}= $_;
  }
}

# Find the object denoted by a selected name.
# -> Name of the object
#    Type of the object (if empty or undef, all tables will be searched)
#    optional: Prefix (such as library of a top-level object or
#    "library.package" for declarations in a package)
# <- Reference to object hash if found; undef if not found; defined but false
#    (0) if ambiguous and no prefix given
sub find_selname
{
  my ($name, $type, $prefix)= @_;

  if( $type ) {
    return undef unless $selnames{$type};
    my $obj= $selnames{$type}->{lc($name)};
    return $obj if $obj && $obj != \$multiple;
    return ($obj ? 0 : undef) if !$prefix;
    return $selnames{$type}->{lc($prefix . "." . $name)};
  }
  # Try all types if type is not given:
  for my $t (keys %selnames) {
    my $obj= find_selname($name, $t, $prefix);
    return $obj if $obj;
  }
  return undef;
}

}



# Try to resolve @see cross references.  This function should only be called
# when the "docfilename" and "doclink" entries of various possible reference
# targets have already be defined.
# -> Reference to array of references to arrays containing the cross reference
#    in their first element
#    Reference to hash mapping library names to references of arrays of their
#    declarative items
#    (optional) Name of the current library
# (<-) For those references which are resolved, the second element of the array
#    will contain a reference to the target object's hash.  The third element
#    will contain a hyperlink to the target's description.
sub resolve_seealso
{
  my ($seeary, $libhash, $libname)= @_;

  for my $see (@$seeary) {
#TODO: search for types in intelligent order rather than using type ""
    my $candidate= find_selname($see->[0], "", $libname);
    next unless $candidate;
    $see->[1]= $candidate;
    if( $candidate->{"type"} eq "entity" ) {
      $see->[2]= "../entities/" . $candidate->{"docfilename"};
    }
    elsif( $candidate->{"type"} eq "architecture" ) {
      $see->[2]= "../architectures/" . $candidate->{"docfilename"};
    }
    elsif( $candidate->{"type"} eq "configuration" ) {
      $see->[2]= "../configurations/" . $candidate->{"docfilename"};
    }
    elsif( $candidate->{"type"} =~ /^package(?:body)?$/ ) {
      $see->[2]= "../packages/" . $candidate->{"docfilename"};
    }
    elsif( $candidate->{"doclink"} ) {  # declarative item in a package
      $see->[2]= $candidate->{"doclink"};
    }
  }
}


# Assign references to corresponding declarative items to the "for" and "use"
# statements in a configuration.
# -> Reference to hash representing configuration
#    Reference to hash mapping library names to references to arrays of their
#    declarations
sub resolve_configuration
{
  my ($conf, $libhash)= @_;
  my $ent;
  my $libname;
  my @topfors;
  my @todo;
  my @forothers;

  return unless $ent= $conf->{"entity"};
  $libname= $conf->{"file"}->{"libname"};
  @topfors= grep $_->{"type"} eq "for" && $_->{"subtype"} eq "architecture",
                        @{$conf->{"children"}};
  @topfors= grep { my $for= $_;
                  ($for->{"object"})= grep $_->{"name"} eq $for->{"objname"},
                                        @{$ent->{"architectures"}};
                } @topfors;
  for my $for (@topfors) {
    push @todo, map( [ $_, $for->{"object"}, $for ],
                        find_children($for, "type", "for"));
  }
  while( @todo )
  {
    my $triplet;
    my $for;
    my $parentdecl;

    $triplet= pop @todo;
    ($for, $parentdecl)= @$triplet;
    if( $for->{"subtype"} eq "architecture" ) {
      # Configuration of an architecture or of a generate or block statement
      if( $parentdecl->{"type"} eq "architecture" && 
                        $for->{"objname"} eq $parentdecl->{"name"} ) {
        $for->{"object"}= $parentdecl;
      }
      else {
        my @candidates= grep $_->{"type"} =~ /^(?:generate|block)$/,
                find_children($parentdecl, "name", $for->{"objname"});
        $for->{"object"}= $candidates[0];
      }
      my @newfors= find_children($for, "type", "for");
      push @todo, map( [ $_, $for->{"object"}, $for ], @newfors);
    }
    else {
      my @candidates= find_all($parentdecl, "type", "instance");
      @candidates= grep $_->{"subtype"} eq "component", @candidates;
      @candidates= grep lc($_->{"objname"}) eq lc($for->{"objtype"}), @candidates;
      if( lc($for->{"objnames"}->[0]) eq "others" ) {
        push @forothers, $triplet;
      }
      elsif( lc($for->{"objnames"}->[0]) ne "all" ) {
        @candidates= grep { my $cand= $_;
                    grep lc($_) eq lc($cand->{"name"}), @{$for->{"objnames"}};
                      } @candidates;
      }
      $for->{"objects"}= \@candidates;
      my ($use)= find_children($for, "type", "use");
      $for->{"use"}= $use;
      if( $use && $use->{"subtype"} ne "open" ) {
        $for->{"bindname"}= $use->{"name"};
        $use->{"object"}= find_selname($use->{"name"}, $use->{"subtype"},
                                          $libname);
        $for->{"binding"}= $use->{"object"};
        if( $use->{"subtype"} eq "entity" && $for->{"binding"} ) {
          $for->{"bindname"}= $for->{"binding"}->{"fullname"};
          if( $use->{"archname"} ) {
            $for->{"archname"}= $use->{"archname"};
            ($for->{"bindarch"})= ($use->{"architecture"})=
                grep lc($_->{"name"}) eq lc($use->{"archname"}),
                      @{$for->{"binding"}->{"architectures"}};
          }
          elsif( @{$for->{"binding"}->{"architectures"}} ) {
            ($for->{"bindarch"})= @{$for->{"binding"}->{"architectures"}};
            $for->{"archname"}= $for->{"bindarch"}->{"name"};
          }
          if( $for->{"bindarch"} ) {
            my @newfors= find_children($for, "type", "for");
            push @todo, map( [ $_, $for->{"bindarch"}, $for ], @newfors);
          }
        }
        $for->{"bindgen"}= $use->{"genericmap"};
      }
      else {
        $for->{"bindgen"}= $for->{"genericmap"};
      }
    }
  }
  for my $triplet (@forothers) {
    my ($for, undef, $parent)= @$triplet;
    my @siblings= find_children($parent, "type", "for");
    for my $sibl (@siblings) {
      next if $sibl == $for;
      for my $obj (@{$for->{"objects"}}) {
        $obj= undef if grep($_ == $obj, @{$sibl->{"objects"}});
      }
    }
    @{$for->{"objects"}}= grep defined($_), @{$for->{"objects"}};
  }
}


# Search for an equivalent of a child hierarchy node in an array of other child
# or top-level nodes.  This is used to prevent duplicate instantiations in the
# instantiation hierarchy.  The comparison performed is slightly asymmetrical
# as required in the situations where this function is used: Child nodes
# representing configuration instantiations need not have been resolved yet (=
# have an entity and architecture assigned to them), but top-level
# configuration nodes in the array may have.  (See the third argument, though.)
# -> Reference to the hash representing the child node
#    Reference to the array of hash references representing the other nodes
#    optional: if 1, the "confname" and "configuration" entries of the first
#    argument are ignored, and the comparison is based solely on the
#    entity and architecture to which the configuration node has been resolved.
# <- The hash reference of the node from the array if an equivalent node has
#    been found; otherwise undef
sub grep_hier
{
  my ($child, $ary, $ignoreconf)= @_;
  my $result;

  if( !$ignoreconf && $child->{"confname"} ) {
    if( $child->{"configuration"} ) {
      ($result)= grep $_->{"configuration"} &&
                    $_->{"configuration"} == $child->{"configuration"}, @$ary;
    }
    else {
      ($result)= grep !$_->{"configuration"} && $_->{"confname"} &&
                      lc($_->{"confname"}) eq lc($child->{"confname"}), @$ary;
    }
  }
  elsif( $child->{"architecture"} ) {
    ($result)= grep $_->{"architecture"} && !$_->{"confname"} &&
                    $_->{"architecture"} == $child->{"architecture"}, @$ary;
  }
  elsif( $child->{"entity"} ) {
    ($result)= grep $_->{"entity"} && !$_->{"architecture"} &&
                !$_->{"confname"} && $_->{"entity"} == $child->{"entity"} &&
          lc($_->{"archname"} || "") eq lc($child->{"archname"} || ""), @$ary;
  }
  else {
    ($result)= grep !$_->{"entity"} && !$_->{"architecture"} &&
         !$_->{"confname"} && lc($_->{"entname"}) eq lc($child->{"entname"}) &&
         lc($_->{"archname"} || "") eq lc($child->{"archname"} || ""), @$ary;
  }
  return $result;
}


# Compares two sub-hierarchies of instantiations.  Children are compared in
# order, which is sufficient if equal subtrees were generated by the same
# algorithm.
# -> Two hierarchy nodes which are the roots of the sub-hierarchies to be
#    compared.
# <- 1 if equal, 0 otherwise
sub hier_equal
{
  my ($node1, $node2)= @_;

  return 1 if $node1 == $node2;
  return 0
      if ($node1->{"configuration"} || 0) != ($node2->{"configuration"} || 0);
  return 0 if lc($node1->{"confname"} || "") ne lc($node2->{"confname"} || "");
  return 1 if $node1->{"proxy"} && $node2->{"proxy"} &&
                $node1->{"proxy"} == $node2->{"proxy"};
  return 0
        if ($node1->{"architecture"} || 0) != ($node2->{"architecture"} || 0);
  return 0 if ($node1->{"entity"} || 0) != ($node2->{"entity"} || 0);
  return 0 if lc($node1->{"archname"} || "") ne lc($node2->{"archname"} || "");
  return 0 if lc($node1->{"entname"} || "") ne lc($node2->{"entname"} || "");
  return 0 if $#{$node1->{"children"}} != $#{$node2->{"children"}};
  for my $ind (0..$#{$node1->{"children"}}) {
    return 0 unless hier_equal($node1->{"children"}->[$ind],
                                $node2->{"children"}->[$ind]);
  }
  return 1;
}


# Comparison between instantiation hierarchy nodes for use with the sort
# function.  The comparison criteria in descending order of priority are entity
# name, architecture name and configuration name.
# (->) Global variables $a and $b, provided by sort, are interpreted as
#      references to hashes representing instantiation hierarchy nodes.
# <- <0 if $a "<" $b etc.
sub hier_sort_cmp
{
  my $last= "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz";
  my $result;

  if( $result= (lc($a->{"entname"} || $last) cmp
                lc($b->{"entname"} || $last)) ) {
    return $result;
  }
  if( $result= (lc($a->{"archname"} || $last) cmp
                lc($b->{"archname"} || $last)) ) {
    return $result;
  }
  return lc($a->{"confname"} || $last) cmp lc($b->{"confname"} || $last);
}


# Find all for statements referring to an instance at the current level of a
# configuration.
# -> Reference to hash representing a configuration or a for statement in a
#    configuration
# <- Reference to array containing references to hashes representing the for
#    statements.  Only the next-level instance for statements are returned, no
#    nesting.  But intermediate for statements referring to block or generate
#    statements are searched.
sub find_forinsts
{
  my ($root)= @_;
  my @results;

  for my $for (grep $_->{"type"} eq "for", @{$root->{"children"}}) {
    if( $for->{"subtype"} eq "instance" ) {
      push @results, $for;
    }
    else {
      push @results, find_forinsts($for);
    }
  }
  return @results;
}


# Build a part of the instantiation hierarchy from a configuration
# instantiation
# -> Reference to the hierarchy node corresponding to a configuration
#    instantiation which has been resolved
#    Reference to array of all hierarchy nodes representing architectures
#    Reference to array of all hierarchy nodes representing configurations
# (<-) Nodes corresponding to bindings given in the configuration are entered
#    into the hierarchy and equal existing nodes marked as instantiated
sub configure_hierarchy
{
  my ($node, $ahier, $chier)= @_;
  my $conf= $node->{"configuration"};

  $node->{"entity"}= $conf->{"entity"}, 
  $node->{"entname"}= $conf->{"objname"};
  my ($topfor)= @{$conf->{"childtype"}->{"for"} || []};
  unless( $topfor && $topfor->{"subtype"} eq "architecture" ) {
    # Pathological case #1: empty configuration body - bind entity to its
    # first architecture.
    if( $node->{"entity"}->{"architectures"}->[0] ) {
      $node->{"architecture"}= $node->{"entity"}->{"architectures"}->[0];
      $node->{"archname"}= $node->{"architecture"}->{"name"};
      if( my ($anode)= grep_hier($node, $ahier, 1) ) {
        $node->{"proxy"}= $anode;
        $anode->{"instantiated"}= 1;
      }
    }
    return;
  }
  $node->{"archname"}= $topfor->{"objname"};
  $node->{"architecture"}= $topfor->{"object"};
  configure_hierarchy_arch($topfor, $node, $ahier, $chier);
}


# Build part of the instantiation hierarchy from one architecture-related for
# statement in a configuration
# -> Reference to hash representing the for statement (which has been resolved)
#    Reference to the hierarchy node representing the architecture (either the
#    topmost architecture node in the configuration or the parent node
#    representing an instance for statement)
#    Reference to array of all hierarchy nodes representing architectures
#    Reference to array of all hierarchy nodes representing configurations
# (<-) Nodes representing instance-related for statements of this
#    architecture-related for statement are created recursively, and other
#    instantiated entities and configurations are also listed as children.
sub configure_hierarchy_arch
{
  my ($for, $node, $ahier, $chier)= @_;

  my @nextfors= grep($_->{"use"}, find_forinsts($for));
  unless( @nextfors ) {
    # Pathological case #2: empty architecture for statement - bind entity to
    # this architecture.
    if( my ($anode)= grep_hier($node, $ahier, 1) ) {
      $node->{"proxy"}= $anode;
      $anode->{"instantiated"}= 1;
    }
    return;
  }
  my $arch= $node->{"architecture"};
  unless( $arch ) {
    for my $nfor (@nextfors) {
      push @{$node->{"children"}}, 
                configure_hierarchy_for($nfor, $node, $ahier, $chier);
    }
    return;
  }
  $node->{"children"}= [];
  my @archildren;
confarchinst:
  for my $inst (@{$arch->{"allinstances"}}) {
    my $new;
    for my $ind (0..$#nextfors) {
      my $nfor= $nextfors[$ind];
      if( grep($_ == $inst, @{$nfor->{"objects"}}) ) {
        next confarchinst if $nfor->{"hier_done"};
        $nfor->{"hier_done"}= 1;
        $new= configure_hierarchy_for($nfor, $node, $ahier, $chier);
        push @{$node->{"children"}}, $new
                unless grep hier_equal($new, $_), @{$node->{"children"}};
        next confarchinst;
      }
    }
    if( $inst->{"subtype"} eq "configuration" || ($inst->{"binding"} &&
        $inst->{"binding"}->{"type"} eq "configuration") ) {
      if( $inst->{"binding"} ) {
        ($new)= grep $_->{"configuration"} == $inst->{"binding"}, @$chier;
        $new->{"instantiated"}= 1;
      }
      else {
        $new= { "confname" => $inst->{"objname"} };
      }
    }
    else {
      if( $inst->{"binding"} ) {
        if( $inst->{"bindarch"} && (my ($anode)=
            grep($_->{"architecture"} == $inst->{"bindarch"}, @$ahier)) ) {
          $new= $anode;
          $anode->{"instantiated"}= 1;
        }
        else {
          $new= { "entity" => $inst->{"binding"},
                  "entname" => $inst->{"bindname"},
                  "architecture" => $inst->{"bindarch"}, 
                  "archname" => $inst->{"archname"} };
        }
      }
      else {
        $new= { "entname" => $inst->{"bindname"} || $inst->{"objname"},
                "archname" => $inst->{"archname"} };
      }
    }
    unless( grep_hier($new, \@archildren) ) {
      push @{$node->{"children"}}, $new;
      push @archildren, $new;
    }
  }
  for (@nextfors) {
    undef $_->{"hier_done"};
  }
}


# Build a part of the instantiation hierarchy from one instance-related for
# statement in a configuration
# -> Reference to hash representing the for statement (which has been resolved)
#    Reference to the hierarchy node representing the configuration or a
#    different node with the right confname and configuration entries
#    Reference to array of all hierarchy nodes representing architectures
#    Reference to array of all hierarchy nodes representing configurations
# <- Node (reference to hash) representing the instantiation bound by this for
#    statement
sub configure_hierarchy_for
{
  my ($for, $confnode, $ahier, $chier)= @_;
  my $use= $for->{"use"};
  my $node;

  if( $use->{"subtype"} eq "configuration" ) {
    $node= { "confname" => $use->{"name"},
              "configuration" => $for->{"binding"} };
    if( my ($cnode)= grep_hier($node, $chier) ) {
      $cnode->{"instantiated"}= 1;
      return $cnode;
    }
  }
  else {
    my $arch= $for->{"bindarch"};
    $node= { "entity" => $for->{"binding"},
             "entname" => $for->{"bindname"} || $use->{"name"},
             "architecture" => $arch, "archname" => $for->{"archname"},
             "configuration" => $confnode->{"configuration"},
             "confname" => $confnode->{"confname"} };
    my ($archfor)= grep lc($_->{"objname"}) eq lc($node->{"archname"}),
                                find_children($for, "type", "for");
    if( $archfor ) {
      configure_hierarchy_arch($archfor, $node, $ahier, $chier);
    }
    else {
      if( my ($anode)= grep_hier($node, $ahier, 1) ) {
        $node->{"proxy"}= $anode;
        $anode->{"instantiated"}= 1;
      }
    }
  }
  return $node;
}


# Returns the maximal depth of a part of the instantiation hierarchy
# -> Reference to the hash which is the root of the part-hierarchy
# <- Depth (0 if the root has no children, and so on).  Recursive instantiation
#    is cut off after the first node which indicates it.
sub hier_max_depth
{
  my ($root, $trace)= @_;
  my $maxd= 0;
 
  $trace ||= [];
  if( $root->{"proxy"} ) {
    return hier_max_depth($root->{"proxy"}, $trace);
  }
  if( !$root->{"children"} || !@{$root->{"children"}} ||
                                grep($_==$root, @$trace) ) {
    return 0;
  }
  push @$trace, $root;
  for my $child (@{$root->{"children"}}) {
    my $childd= hier_max_depth($child, $trace);
    $maxd= $childd if $maxd < $childd;
  }
  pop @$trace;
  return $maxd+1;
}


# Parse the strings from the --topmodule option.
# (->) $config{"topmodules"}
# (<-) $config{"topmodhash"} has (selected) entity names as keys and  a scalar
#      1 or an array ref of two hashes as value.  These hashes contain the
#      names of architectures and configurations as keys, respectively.
sub parsetopmods
{
  my %topmods;

  for (@{$config{"topmodules"}}) {
    if( /^([\w\.]+)(?:\((\w+)\)|\[(\w+)\])?$/ ) {
      my ($ent, $arch, $conf)= (lc($1), lc($2 || ""), lc($3 || ""));
      $ent= "work.$ent" unless $ent =~ /\./;
      next if $topmods{$ent} && !ref($topmods{$ent});
      if( $arch ) {
        $topmods{$ent}->[0]->{$arch}= 1;
      }
      elsif( $conf ) {
        $topmods{$ent}->[1]->{$conf}= 1;
      }
      else {
        $topmods{$ent}= 1;
      }
    }
    else {
      print STDERR "Warning: Ignoring invalid top module specification \`$_'.\n",
      "The format is: <entity>(<architecture>) or <entity>[<configuration>].\n"
            unless $config{"quiet"};
    }
  }
  $config{"topmodhash"}= \%topmods;
}


# Generate lists of user-designated top modules and other uninstantiated
# hierarchy nodes.
# -> Reference to array of hierarchy nodes
# <- List of two array references containing designated top modules and other
#    uninstantiated modules, respectively
sub topmodules
{
  my ($hier)= @_;
  my (@tops, @uninst);

  for my $node (@$hier) {
    my $topflag= $config{"topmodhash"}->{lc($node->{"entname"})};
    if( ref $topflag ) {
      $topflag= ($topflag->[0] && $node->{"archname"} && $topflag->[0]->{lc($node->{"archname"})}) ||
                ($topflag->[1] && $node->{"confname"} && $topflag->[1]->{lc($node->{"confname"})});
    }
    if( $topflag ) {
      push @tops, $node;
    }
    elsif( !$node->{"instantiated"} ) {
      push @uninst, $node;
    }
  }
  return (\@tops, \@uninst);
}


##############################################################################
##############################################################################
####                    Output functions
##############################################################################
##############################################################################

# classes and <span> tags for VHDL language elements:
my $SPDOC= "<span class=\"doccom\">";       # documentation comment text
my $SPDO= "<span class=\"vhdlcom\">";       # other comment text
my $SPID= "<span class=\"identifier\">";    # identifier
my $SPTYID= "<span class=\"typeid\">";      # type identifier
my $SPDID= "<span class=\"declid\">";       # identifier of this declaration
my $SPPID= "<span class=\"pslid\">";        # PSL identifier
my $SPSTR= "<span class=\"vhdlstr\">";      # quoted (bit) string or bit
my $SPIO= "<span class=\"vhdlio\">";        # in, out, inout
my $SPVA= "<span class=\"vhdlvar\">";       # signal, constant, variable, attr.
my $SPDCL= "<span class=\"vhdldecl\">";     # declarative item
my $SPWD= "<span class=\"vhdlword\">";      # other VHDL reserved word
my $SPPSL= "<span class=\"pslword\">";      # PSL reserved word
my $SPIE= "<span class=\"vhdlieee\">";      # standard package word
my $SPIET= "<span class=\"vhdlieee typeid\">"; # standard package type
my $CCO= " class=\"vhdlcode\"";
my $SPCO= "<span class=\"vhdlcode\">";      # encloses all VHDL code
my $SPNC= "<span class=\"nocode\">";        # non-code within class vhdlcode
my $SP_= "</span>";

# other tags that allow CSS customisation:
my $TDI= "<td class=\"vhdoclind\" width=\"50\"></td>";  # indentation in tables
my $STDTAB= "<table class=\"vhdocltab\" border=\"0\" cellpadding=\"3\">";   # major layout table


# Search for data directory containing style folder in standard locations and
# at the environment variable VHDOCL_DATADIR if available.
# <- Path to style directory or undef if not found
sub getstyledatadir
{
  my @locations;

  if( $^O ne "MSWin32" && $^O ne "MacOS" ) {
    @locations= ("/usr/local/share/vhdocl/style", "/usr/share/vhdocl/style");
  }
  unshift @locations, File::Spec->catdir($ENV{"VHDOCL_DATADIR"}, "style")
      if $ENV{"VHDOCL_DATADIR"};
  my ($firstex)= grep -d $_, @locations;
  return $firstex;
}


# Try to create output directories if they do not yet exist, and localise the
# file name of style sheet and logos relative to the output directory if
# applicable.  The function dies if it cannot create the directories.
# (<->) %config
sub prepareoutput
{
  my $dir= $config{"absoutputdir"};

  eval { File::Path::mkpath( $dir ); };
  croak "Cannot create output directory `$dir' - $@" if $@;
  for my $d ("entities", "architectures", "configurations", "packages",
            "sources", "style")
  {
    my $subdir= File::Spec->catdir($dir, $d);
    if( opendir(DIR, $subdir) ) {
      closedir DIR;
      next;
    }
    if( open(FILE, $subdir) ) {
      close FILE;
      croak "Cannot create output directory `$subdir' - a file of the same name exists!";
    }
    if( !mkdir($subdir) ) {
      croak "Cannot create output directory `$subdir' - $!";
    }
  }
  my $styledir= File::Spec->catdir($dir, "style");
  my $styledatadir= getstyledatadir();
  if( $styledatadir ) {
    my $copyerr= 0;
    while( my ($key, $file)= each(%requisites) ) {
      $copyerr ||= ! copyfile(File::Spec->catfile($styledatadir, $file),
                                  $styledir);
    }
    if( $copyerr && !$config{"quiet"} ) {
      print STDERR "Error copying some style files.  Continuing regardless.\n";
    }
  }
  else {
    print STDERR "Style data directory not found.  Cannot copy style files.  Continuing regardless.\n";
    print STDERR <<EOF unless $config{"quiet"};
This error can occur if VHDocL auxiliary data were installed to a non-standard
location but the VHDOCL_DATADIR environment variable was not set.  Ask the
person who installed VHDocL for you to set this variable appropriately.
EOF
  }
  # Now copy all style files not given as URLs
  for my $item ("stylesheet", "leftlogo", "rightlogo") {
    if( $config{$item} ) {
      $config{$item."url"}= $config{$item} =~ /^\w+:\/\//;
      if( !$config{$item."url"} ) {
        my $destname= $config{"prefix"} . $item . "." . fileext($config{$item});
        if( ! copyfile($config{$item}, File::Spec->catfile($styledir, $destname)) ) {
          print STDERR "Could not copy `", $config{$item}, "' to style",
                    " directory.  Continuing regardless.\n"
            unless $config{"quiet"};
        }
        else {
          $config{$item}= "style/" . $destname;
        }
      }
    }
  }
  if( $config{"toplink"} ) {
    print STDERR "Warning: --homehtml is pointless when --toplink is present.  The home page will not be generated.\n"
        if $config{"homehtml"} && !$config{"quiet"};
    $config{"toplink"} =~ s/^([^|]*)\|//;
    $config{"toplinktext"}= $1 || "Home";
    $config{"toplinkabs"}= $config{"toplink"} =~ /^\w+:\/\// ||
             File::Spec->file_name_is_absolute($config{"toplink"});
    if( $config{"toplinkabs"} && $config{"toplink"} !~ /^\w+:\/\// ) {
      print STDERR "Warning: Absolute top link file name will not be",
                   " portable across systems.\n" unless $config{"quiet"};
    }
    $config{"toplink"}= File::Spec->abs2rel($config{"toplink"}, $dir)
        unless $config{"toplinkabs"};
  }
  else {
    $config{"toplink"}= $config{"prefix"} . "index.html";
    $config{"toplinktext"}= "Home";
    $config{"toplinkabs"}= 0;
    my $fname= $config{"outputdir"} . "/" . $config{"toplink"};
    open INDEX, ">$fname" or croak "Could not create index.html.\n";
    printhtmlheader(*INDEX{IO}, "Home", 1);
    my $homecontent= gethtml($config{"homehtml"});
    print INDEX ($homecontent ? "$homecontent\n<hr>\n" : "<p></p>\n");
    printhtmlfooter(*INDEX{IO}, 1);
    close INDEX;
  }
  if( $config{"cellpadding"} ) {
    $STDTAB= "<table class=\"vhdocltab\" border=\"0\" cellpadding=\"" .
             $config{"cellpadding"} .  "\">";
    print STDERR <<EOF;
Warning: The option -c / --cellpadding is deprecated and may be removed.
Instead, use the --stylefile option with a file containing something like:
table.vhdocltab td { padding:3px; }
EOF
  }
  if( $config{"indentation"} ) {
    $TDI= "<td class=\"vhdoclind\" width=\"" . $config{"indentation"} . "\"></td>";
    print STDERR <<EOF;
Warning: The option -i / --indentation is deprecated and may be removed.
Instead, use the --stylefile option with a file containing something like:
*.vhdoclind { width:50px; }
EOF
  }
}


# Print the header of an HTML documentation file
# -> File handle or scalar reference to print to
#    Page title
#    Global page flag, !=0 for entity list, instantiation hierarchy, etc., and
#    0 for documentation of single entity, architecture etc.
sub printhtmlheader
{
  my ($handle, $title, $global)= @_;
  my $prepre= ($global? "": "../");
  my $prefix= $prepre . $config{"prefix"};
  my $top;
  my $doctitle;
  my $stylesheet;
  my $leftlogo;
  my $rightlogo;
  my $toplink;
  my $html;

  $doctitle= length($config{"title"})?
                "\n<center>" . $config{"title"} . "</center><hr>\n" : "";
  $stylesheet= "<link rel=\"stylesheet\" type=\"text/css\" " .
               "href=\"${prepre}style/" .  $requisites{"basestyle"} . "\">";
  if( $config{"stylesheet"} ) {
    $top= $config{"stylesheeturl"}? "" : $prepre;
    $stylesheet .= "\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"" .
                   $top . $config{"stylesheet"} . "\">";
  }
  $top= $config{"leftlogourl"}? "" : $prepre;
  $leftlogo= $config{"leftlogo"}?
                "<img style=\"vertical-align:middle\" src=\"" . $top .
                $config{"leftlogo"} . "\">" : "";
  $top= $config{"rightlogourl"}? "" : $prepre;
  $rightlogo= $config{"rightlogo"}?
                "<img style=\"vertical-align:middle\" src=\"" . $top .
                $config{"rightlogo"} . "\">" : "";
  $top= $config{"toplinkabs"}? "" : $prepre;
  $toplink= $config{"toplink"}?  "<a href=\"" . $top . $config{"toplink"} .
                "\">" .  $config{"toplinktext"} .
                "</a>\n&nbsp;&nbsp; -- &nbsp;&nbsp;" : "";

  $html= <<EOF;
<html>
<head>
    <title>$title</title>
    $stylesheet
</head>
<body>
$doctitle
<table border="0" width="100%"><tr><td align="left">
$leftlogo
</td><td align="center">
$toplink
<a href="${prefix}entities.html">Entities</a>
&nbsp;&nbsp; -- &nbsp;&nbsp;
<a href="${prefix}packages.html">Packages</a>
&nbsp;&nbsp; -- &nbsp;&nbsp;
<a href="${prefix}instantiations.html">Instantiations</a>
&nbsp;&nbsp; -- &nbsp;&nbsp;
<a href="${prefix}hierarchy.html">Hierarchy</a>
&nbsp;&nbsp; -- &nbsp;&nbsp;
<a href="${prefix}sources.html">Sources</a>
</td><td align="right">
$rightlogo
</td></tr></table>

<hr>

EOF
  if( ref($handle) eq "SCALAR" ) {
    $$handle= $html;
  }
  else {
    print $handle $html;
  }
}


my @monthname= qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );

# Print the footer of a HTML documentation file
# -> File handle to print to
#    Optional flag indicating that the vertical bar should be omitted
sub printhtmlfooter
{
  my ($handle, $nobar)= @_;
  my ($sec,$min,$hour,$mday,$mon,$year)= localtime(time);

  $year += 1900;
  $mon= $monthname[$mon];
  $min= sprintf("%02d", $min);
  $sec= sprintf("%02d", $sec);
  print $handle "\n<hr>\n" unless $nobar;
  print $handle <<EOF

$config{"footer"}
Generated on $mday $mon $year $hour:$min:$sec with <a
href="http://www.volkerschatz.com/hardware/vhdocl.html">VHDocL</a>
V$version

</body>
</html>
EOF
}


# Escape HTML's reserved characters.
# -> Text
# <- Text with &<>" escaped
sub html_esc
{
  my ($string)= @_;

  $string =~ s/&/&amp;/g;
  $string =~ s/</&lt;/g;
  $string =~ s/>/&gt;/g;
  $string =~ s/"/&quot;/g;
  return $string;
}


# Strings: \x04 stands for double quotes which are later converted to `&quot;',
# unlike those enclosing the class names.
my $MARKQUOT= qr/(?:\b[box])?\x04[^\x04]*\x04|'[^']'/i;
# Lists of words belonging to CSS classes:
my @IOWORDS= qw( in out inout buffer linkage );
my @VARWORDS= qw( constant signal variable file attribute );
# "use" is now included in @DECLWORDS, even though this is only really correct
# for package use statements.
my @DECLWORDS= qw( entity architecture configuration package body
function procedure subtype type library component use );
my @OTHERWORDS= qw( begin pure impure postponed guarded if then else
elsif for generate while until loop next case when group exit block process
array units record with port generic map open null all others range not and
nand or xor xnor mod rem sla sll sra srl ror rol assert report severity 
is return to downto on of after wait bus new alias
select reject literal register transport inertial unaffected shared disconnect
access label end );
my @IEEEWORDS= qw( true false note warning error failure now foreign
read_mode write_mode append_mode open_ok status_error name_error mode_error
textio input output readline read writeline write oread owrite hread hwrite
endline bit bit_vector ieee std_logic_1164 to_bit to_bitvector to_stdulogic
to_stdulogicvector to_stdlogicvector rising_edge falling_edge is_x numeric_std
numeric_bit to_integer to_signed to_unsigned shift_left shift_right rotate_left
rotate_right resize std_logic_arith shl shr ext sext conv_integer conv_unsigned
conv_signed conv_std_logic_vector std_logic_misc and_reduce or_reduce
xor_reduce std_logic_unsigned std_logic_signed cond_op cond sh_left sh_right
align_size math_real math_e math_1_e math_pi math_1_pi math_log_of_2
math_log_of_10 math_log2_of_e math_log10_of_e math_sqrt2 math_sqrt1_2
math_sqrt_pi math_deg_to_rad math_rad_to_deg sign ceil floor fmax fmin uniform
srand rand get_rand_max sqrt cbrt exp log sin cos tan asin acos atan atan2 sinh
cosh tanh acosh atanh math_complex cbase_1 cbase_j czero cabs carg cmplx conj
csqrt cexp complex_to_polar polar_to_complex
);
my @IEEETYPES= qw( integer positive natural boolean real string character time
delay_length severity_level file_open_kind file_open_status line text side
std_ulogic std_ulogic_vector std_logic std_logic_vector x01 x01z ux01
ux01z small_int signed unsigned complex complex_vector complex_polar );
# "width" is a type defined in textio, but has been removed, as it may often be
# used as a constant/variable name.
my @PSLWORDS= qw( abort always assume assume_guarantee before clock const
countones cover default endpoint eventually fairness fell forall inf inherit
isunknown never next next_a next_e next_event next_event_a next_event_e onehot
onehot0 property prev restrict restrict_guarantee rose sequence stable strong
union until vmode vprop vunit within );
# Note: assert, boolean, report have been left out, as they conflict with other
# classes.  Keywords ending with underscores are not caught by /$ID/ and are
# for now also left out.  Single- and two-character keywords are for now
# ignored too.
my %SPANCLASS= ( map( { $_ => $SPIO; } @IOWORDS),
                 map( { $_ => $SPVA; } @VARWORDS),
                 map( { $_ => $SPDCL; } @DECLWORDS),
                 map( { $_ => $SPWD; } @OTHERWORDS),
                 map( { $_ => $SPIE; } @IEEEWORDS),
                 map( { $_ => $SPIET; } @IEEETYPES) );

# Convert VHDL code to HTML with syntax markup expressed in CSS classes.
# -> VHDL code
# <- HTML with <span> tags of the appropriate classes
sub markvhdl
{
  my ($code)= @_;

  $code =~ tr/&<>"/\x01\x02\x03\x04/;
  $code =~ s/($MARKQUOT)|($ID)/
        $1 ? "$SPSTR$1$SP_" : ($SPANCLASS{lc($2)} || $SPID) . $2 . $SP_ /iexog;
  $code =~ s/\x01/&amp;/g;
  $code =~ s/\x02/&lt;/g;
  $code =~ s/\x03/&gt;/g;
  $code =~ s/\x04/&quot;/g;
  return $code;
}


# Apply HTML markup to type name.  Calls markvhdl, and adds a link to the type
# definition if available.
# -> VHDL code describing a type
#    Reference to hash of the object that has this type, possibly including a
#    "typedef" field referencing the type definition object
# <- HTML markup of the type designation
sub marktype
{
  my ($code, $obj)= @_;

  $code= markvhdl($code);
  return $code unless $obj->{"typedef"} && $obj->{"typedef"}->{"doclink"};
  $code =~ s/\b((?:\w+\.)*$obj->{typedef}->{name})\b/<a href="$obj->{typedef}->{doclink}">$1<\/a>/i;
  return $code;
}


# Print detailed description of entity etc.  List items starting with @li are
# converted to their HTML equivalent
# -> File handle to print to
#    Reference to array containing paragraphs and list items of description
sub printdescription
{
  my ($handle, $desc)= @_;
  my $listnow= 0;

  for my $line (@$desc)
  {
    if( $line =~ s/^\@li\s*//i ) {
      if( !$listnow ) {
        print $handle "<ul>\n";
        $listnow= 1;
      }
      print $handle "<li>$SPDOC$line$SP_</li>\n";
    }
    else {
      if( $listnow ) {
        print $handle "</ul>\n";
        $listnow= 0;
      }
      print $handle "<p>$SPDOC\n$line\n$SP_</p>\n";
    }
  }
  print $handle "</ul>\n" if $listnow;
}


# Print the common part of a HTML file pertaining to an entity, architecture or
# package, below the header and headline.
# -> File handle to print to
#    Reference to hash representing the entity etc.
sub printobjhtml
{
  my ($handle, $obj)= @_;

  print $handle "<p><b>", $obj->{"doc"}->{"brief"}, "</b></p>\n" 
        if $obj->{"doc"}->{"brief"};
  print $handle "<p><b>", $obj->{"doc"}->{"short"}, "</b></p>\n" 
        if $obj->{"doc"}->{"short"};
  if( $obj->{"filename"} ) {
    print $handle "<p>Defined in ";
    if( $obj->{"file"} ) {
      print $handle "<a href=\"../sources/", $obj->{"file"}->{"docfilename"},
            "\">", $obj->{"filename"}, "</a>&nbsp;&nbsp;&nbsp;<a href=\"",
            ($obj->{"file"}->{"link"} =~ /^\w+:\/\// ? "":"../"),
            $obj->{"file"}->{"link"}, "\">[source file]</a></p>\n";
    }
    else {
      print $handle $obj->{"filename"}, "</p>\n"
    }
  }
  for (qw(synthesis simulation testbench deprecated internal)) {
    print $handle "<h3><b>", ucfirst($_), "</b></h3>\n" if $obj->{"doc"}->{$_};
  }
  print $handle "<p>\n";
  if( $obj->{"doc"}->{"author"} ) {
    print $handle ($obj->{"doc"}->{"author"} =~ /,|;|\band\b/?
                                        "Authors: " : "Author: ");
    print $handle $obj->{"doc"}->{"author"}, "<br>\n";
  }
  print $handle "Date: ", $obj->{"doc"}->{"date"}, "<br>\n"
        if $obj->{"doc"}->{"date"};
  print $handle "Version: ", $obj->{"doc"}->{"version"}, "<br>\n"
        if $obj->{"doc"}->{"version"};
  print $handle "ID: ", $obj->{"doc"}->{"id"}, "<br>\n"
        if $obj->{"doc"}->{"id"};
  print $handle "</p>\n\n";
  if( $obj->{"doc"}->{"description"} && @{$obj->{"doc"}->{"description"}} ) {
    print $handle "<hr>\n\n<h2>Detailed description</h2>\n\n";
    printdescription($handle, $obj->{"doc"}->{"description"});
  }
  if( $obj->{"doc"}->{"see"} && @{$obj->{"doc"}->{"see"}} ) {
    print $handle "<p>See also: ", join(", ", map( ($_->[2]?
            "<a href=\"" . $_->[2] . "\">" . $_->[0] . "</a>" : $_->[0]),
            @{$obj->{"doc"}->{"see"}})), "</p>\n\n";
  }
  if( $obj->{"attributes"} && keys(%{$obj->{"attributes"}}) ) {
    print $handle "\n<h2>Attributes</h2>\n\n";
    printattrhtml($handle, $obj);
  }
}


my %labels= ( "function" => "func:", "procedure" => "proc:", "psl" => "psl:",
            "component" => "comp:", "instance" => "inst:", "type" => "type:" );

# Print HTML fragment describing the libraries and package use clauses
# affecting and object.
# -> File handle to print to
#    Reference to hash representing entity, architecture, configuration,
#    package or package body
sub printlibusehtml
{
  my ($handle, $obj)= @_;
  my (%libs, %uses);        # use hashes to make libs/packages unique

  for (@{$obj->{"file"}->{"children"}}, @{$obj->{"children"}}) {
    if( $_->{"type"} eq "library" ) {
      $libs{lc($_->{"name"})}= $_;
    }
    elsif( $_->{"type"} eq "use" && $_->{"subtype"} eq "package" ) {
      $uses{lc($_->{"name"})}= $_;
    }
  }
  return unless keys(%libs) || keys(%uses);
  print $handle "\n<h2>Libraries and global use clauses</h2>\n\n$STDTAB\n";
  my @sortuses= sort keys %uses;
  for my $lib (sort keys %libs) {
    my $markedname= markvhdl($libs{$lib}->{"name"});
    print $handle "<tr$CCO><td colspan=\"2\"><b>${SPDCL}library$SP_ ",
                  $markedname, "</b></td></tr>\n";
    map { print $handle "<tr>$TDI<td>$SPDOC$_$SP_</td></tr>\n"; }
                          @{$libs{$lib}->{"doc"}->{"description"}};
    for my $usename (grep $_ =~ /^$lib\b/, @sortuses) {
      printusehtml($handle, $uses{$usename});
      delete $uses{$usename};
    }
  }
  for my $usename (sort keys %uses) {
    printusehtml($handle, $uses{$usename});
  }
  print $handle "</table>\n\n";
}


# Print HTML fragment describing a package use clause
# -> File handle to print to
#    Reference to hash representing use clause
sub printusehtml
{
  my ($handle, $use)= @_;
  my $markedname= markvhdl($use->{"name"});

  if( $use->{"object"} && (my $link= $use->{"object"}->{"doclink"}) ) {
    print $handle "<tr$CCO><td colspan=\"2\">${SPDCL}use$SP_ <a href=\"$link\">",
                  $markedname, "</a></td></tr>\n";
  }
  elsif( $use->{"package"} ) {
    print $handle "<tr$CCO><td colspan=\"2\">${SPDCL}use$SP_ ",
              "<a href=\"../packages/", $use->{"package"}->{"docfilename"},
              "\">", $markedname, "</a></td></tr>\n";
  }
  else {
    print $handle "<tr$CCO><td colspan=\"2\">${SPDCL}use$SP_ ", $markedname,
                  "</td></tr>\n";
  }
  map { print $handle "<tr>$TDI<td>$SPDOC$_$SP_</td></tr>\n"; }
                        @{$use->{"doc"}->{"description"}};
}


# Print HTML fragment describing a generic, port or constant
# -> File handle to print to
#    Reference to hash representing the generic/port/...
sub printgenporthtml
{
  my ($handle, $gp)= @_;

  print $handle "<tr$CCO><td align=\"left\"><b>$SPID", $gp->{"name"},
                "$SP_</b></td>\n";
  print $handle "<td align=\"center\"><i><b>$SPIO", $gp->{"direction"}, 
                "$SP_</b></i></td>" if $gp->{"direction"};
  print $handle "<td align=\"left\">", marktype($gp->{"subtype"}, $gp), "</td>\n";
  print $handle "<td align=\"left\">:= ", markvhdl($gp->{"value"}), "</td>\n"
        if $gp->{"value"};
  print $handle "</tr>\n";
  map { print $handle "<tr><td></td><td align=\"left\" colspan=\"3\">$SPDOC$_",
                      "$SP_</td></tr>\n" }
                        @{$gp->{"doc"}->{"description"}};
}


# Print section with links to components instantiating this one.
# -> File handle to print to
#    Reference to has representing entity, architecture or configuration
sub printinstantiated
{
  my ($handle, $obj)= @_;

  return unless $obj->{"instantiated"} && @{$obj->{"instantiated"}};
  # The instantiation list is already sorted because it was generated after
  # sorting the hierarchy nodes.  But it may contain duplicates if a
  # configuration has separate bindings for multiple instances of the same
  # entity.
  my @instlinks= map nodehtml($_, 1), uniq @{$obj->{"instantiated"}};
  print $handle "\n<h2>Instantiated in...</h2>\n\n", join(", ", @instlinks);
}


my $enthtmlerr= 0;

# Write the HTML documentation for an entity
# -> Reference to hash representing entity
sub entityhtml
{
  my ($ent)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"}, "entities",
                                 $ent->{"docfilename"});

  if( !open(ENT, ">$fname") ) {
    limitfileerr("Cannot create output file $fname", \$enthtmlerr);
    return;
  }
  printhtmlheader(*ENT{IO}, $ent->{"fullname"});
  print ENT "\n<h1>Entity ", $ent->{"fullname"}, "</h1>\n";
  printobjhtml(*ENT{IO}, $ent);
  if( @{$ent->{"architectures"}} ) {
    print ENT "\n<h2>Architectures</h2>\n\n$STDTAB\n";
    map { print ENT "<h3><a href=\"../architectures/",
            $_->{"docfilename"}, "\">", $_->{"name"}, "</a></h3>\n"; }
            @{$ent->{"architectures"}};
    print ENT "</table>\n\n";
  }
  else {
    print ENT "\n<h2>No architectures found</h2>\n\n";
  }
  if( @{$ent->{"configurations"}} ) {
    print ENT "\n<h2>Configurations</h2>\n\n$STDTAB\n";
    map { print ENT "<h3><a href=\"../configurations/",
            $_->{"docfilename"}, "\">", $_->{"name"}, "</a></h3>\n"; }
            @{$ent->{"configurations"}};
    print ENT "</table>\n\n";
  }
  printinstantiated(*ENT{IO}, $ent);
  print ENT "\n<hr>\n\n";
  printlibusehtml(*ENT{IO}, $ent);
  if( my @gens= @{$ent->{"childtype"}->{"generic"}} ) {
    print ENT "\n<h2>Generics</h2>\n\n$STDTAB\n";
    map { printgenporthtml(*ENT{IO}, $_) } @gens;
    print ENT "</table>\n\n";
  }
  if( my @ports= @{$ent->{"childtype"}->{"port"}} ) {
    print ENT "\n<h2>Ports</h2>\n\n$STDTAB\n";
    map { printgenporthtml(*ENT{IO}, $_) } @ports;
    print ENT "</table>\n\n";
  }
  printhtmlfooter(*ENT{IO});
  close ENT;
}


# Print description and attributes of component, instance, process, procedure
# or function
# -> File handle to print to
#    Reference to hash representing object
sub printcommonhtml
{
  my ($handle, $obj)= @_;

  map { print $handle "<tr>$TDI<td colspan=\"4\">$SPDOC$_$SP_</td></tr>\n" }
                        @{$obj->{"doc"}->{"description"}};
  if( $obj->{"attributes"} && keys(%{$obj->{"attributes"}}) ) {
    print $handle "<tr>$TDI<td colspan=\"4\">Attributes:</td></tr>\n",
                  "<tr>$TDI$TDI<td colspan=\"3\">";
    printattrhtml($handle, $obj);
    print $handle "</td></tr>\n";
  }
}


# Print HTML table listing an object's attributes and their descriptions
# -> File handle to print to
#    Reference to hash describing the object
sub printattrhtml
{
  my ($handle, $obj)= @_;

  return unless $obj->{"attributes"} && keys(%{$obj->{"attributes"}});
  print $handle "$STDTAB\n";
  for my $attrname (keys %{$obj->{"attributes"}}) {
    my $aspec= $obj->{"attributes"}->{$attrname};
    my $attr= $aspec->{"attribute"};
    print $handle "<tr$CCO><td><b>$SPID", $aspec->{"name"},
                "$SP_</b></td><td> : ", ($attr->{"subtype"} ?
             markvhdl($attr->{"subtype"}) : "<i>${SPNC}unknown type$SP_</i>"), 
                "</td><td> := ", markvhdl($aspec->{"value"}), "</td></tr>\n";
    if( $attr->{"doc"}->{"description"} &&
                              @{$attr->{"doc"}->{"description"}} ) {
      map { print $handle "<tr>$TDI<td colspan=\"2\">$SPDOC$_$SP_</td></tr>\n" }
                @{$attr->{"doc"}->{"description"}};
    }
    if( $aspec->{"doc"}->{"description"} &&
                              @{$aspec->{"doc"}->{"description"}} ) {
      map { print $handle "<tr>$TDI<td colspan=\"2\">$SPDOC$_$SP_</td></tr>\n" }
                @{$aspec->{"doc"}->{"description"}};
    }
  }
  print $handle "</table>\n";
}


# Print HTML fragment describing a component declaration
# -> File handle to print to
#    Reference to hash representing the component declaration
sub printcomphtml
{
  my ($handle, $comp)= @_;

  print $handle "<tr$CCO><td colspan=\"5\"><b><a name=\"",
                $labels{"component"}, $comp->{"name"}, "\">$SPDID",
                $comp->{"name"}, "$SP_</a></b></td></tr>\n";
  printcommonhtml($handle, $comp);
  print $handle "<tr>$TDI<td colspan=\"4\">",
                "Default binding: $SPCO<a href=\"../entities/",
                $comp->{"binding"}->{"docfilename"}, "\">$SPID", 
                $comp->{"binding"}->{"fullname"}, "$SP_</a>$SP_</td></tr>\n"
        if $comp->{"binding"};
}


# Print HTML fragment describing all function and procedure declarations of a
# library unit, in the order in which they appear in the source.
# -> File handle to print to
#    Reference to hash representing the top-level declaration (library unit)
sub printfuncprochtml
{
  my ($handle, $obj)= @_;
  my @funcprocs;
  my @headwords;
  my $headline;

  @funcprocs= @{$obj->{"childtype"}->{"funcproc"}};
  return unless @funcprocs;
  push @headwords, "functions" if $obj->{"childtype"}->{"function"} &&
                                 @{$obj->{"childtype"}->{"function"}};
  push @headwords, "procedures" if $obj->{"childtype"}->{"procedure"} &&
                                  @{$obj->{"childtype"}->{"procedure"}};
  $headline= ucfirst join " and ", @headwords;
  print $handle "\n<h2>$headline</h2>\n\n$STDTAB\n";
  map { printfunchtml($handle, $_) } @funcprocs;
  print $handle "</table>\n\n";
}


# Print HTML fragment describing a function or procedure declaration
# -> File handle to print to
#    Reference to hash representing the function/procedure
sub printfunchtml
{
  my ($handle, $func)= @_;
  my $label= $labels{$func->{"type"}} . $func->{"name"};
  my $arglist= $func->{"parlist"} ?
                " (" . markvhdl($func->{"parlist"}) . ")" : "";

  print $handle "<tr$CCO><td colspan=\"5\">$SPDCL", $func->{"type"},
                "$SP_ <b><a name=\"$label\">$SPDID",
                $func->{"name"}, "$SP_</a></b>", $arglist,
                ($func->{"subtype"}? " ${SPWD}return$SP_ " .
                                markvhdl($func->{"subtype"}) : ""),
        "</td></tr>\n";
  print $handle "<tr$CCO>$TDI<td colspan=\"4\"><b>${SPWD}impure$SP_</b></td></tr>\n"
        if $func->{"pure"} && $func->{"pure"} eq "impure";
  printcommonhtml($handle, $func);
}


# Print HTML fragment describing a type declaration
# -> File handle to print to
#    Reference to hash describing the type declaration
sub printtypehtml
{
  my ($handle, $type)= @_;

  my $label= $labels{"type"} . $type->{"name"};
  print $handle "<tr$CCO><td>$SPDCL",
                ($type->{"subtype"} eq "subtype"? "subtype": "type"),
                "$SP_</td><td><a name=\"$label\"><b>$SPTYID", $type->{"name"},
                "$SP_</b></a></td><td>${SPWD}is$SP_</td>\n<td>";
  if( $type->{"subtype"} eq "record" ) {
    print $handle "${SPWD}record$SP_</td></tr>\n";
    map { print $handle "<tr><td></td><td colspan=\"4\">$SPDOC$_$SP_</td></tr>\n"; }
                        @{$type->{"doc"}->{"description"}};
    if( my @elements= @{$type->{"children"} || []} ) {
      print $handle "<tr><td></td><td>Elements: </td><td colspan=\"3\">$STDTAB\n";
      map { printgenporthtml($handle, $_) } @elements;
      print $handle "</table></td></tr>\n";
    }
    return;
  }
  if( $type->{"subtype"} eq "units" ) {
    print $handle marktype($type->{"definition"}), " ${SPWD}units$SP_ $SPID",
                  $type->{"baseunit"}, "$SP_</td></tr>\n";
    map { print $handle "<tr><td></td><td colspan=\"4\">$SPDOC$_$SP_</td></tr>\n"; }
                        @{$type->{"doc"}->{"description"}};
    for my $chain (@{$type->{"chains"}}) {
      print $handle "<tr><td></td><td></td><td colspan=\"3\">";
      my $u= $chain;
      my $closeparens= "";
      while( @$u > 1 ) {
        print $handle "$SPID$$u[0]$SP_ = $$u[1] ";
        $u= $$u[2];
        if( @$u > 1 ) {
          print $handle "( ";
          $closeparens .= ")";
        }
      }
      print $handle "$SPID$$u[0]$SP_ $closeparens</td></tr>\n";
    }
    return;
  }
  if( $type->{"subtype"} =~ /type$/ ) {
    print $handle marktype($type->{"definition"}, $type), "</td></tr>\n";
  }
  elsif( $type->{"subtype"} =~ /^protected/i ) {
    print $handle "${SPWD}protected$SP_...</td></tr>\n";
  }
  else {
    print $handle "???</td></tr>\n";
  }
  map { print $handle "<tr><td></td><td colspan=\"4\">$SPDOC$_$SP_</td></tr>\n"; }
                        @{$type->{"doc"}->{"description"}};
}


# Print HTML fragment describing the constructs surrounding a process,
# instantiation or PSL statement.
# -> File handle to print to
#    Reference to array of hashes representing declarative items (usually
#    generate or block statements) enclosing the process (etc.) and the process
#    itself.
#    Name of the declaration enclosed in blocks; defaults to the type of the
#    last path element.
sub printtracehtml
{
  my ($handle, $path, $declname)= @_;

  return unless $#$path;
  $declname ||= $path->[-1]->{"type"};
  print $handle "<tr>$TDI<td colspan=\"4\">This $declname is inside the ",
                "following construct", ($#$path>1? "s":""), ":</td></tr>\n";
  for my $trc (@$path[0..$#$path-1]) {
    if( $trc->{"type"} eq "generate" ) {
      print $handle "<tr$CCO>$TDI$TDI<td colspan=\"3\"><b>$SPID$trc->{name}",
          "$SP_</b> : $SPWD", $trc->{"subtype"}, "$SP_ ",
          markvhdl($trc->{"parameters"}), " ${SPWD}generate$SP_</td></tr>\n";
    }
    elsif( $trc->{"type"} eq "block" ) {
      my $guard= $trc->{"guard"} ? "( " . markvhdl($trc->{"guard"}) . " )" : "";
      print $handle "<tr$CCO>$TDI$TDI<td colspan=\"3\"><b>$SPID$trc->{name}",
          "$SP_</b> : ${SPWD}block$SP_ ", $guard, "</td></tr>\n";
    }
    else {
      print $handle "<tr$CCO>$TDI$TDI<td colspan=\"3\">$SPWD", $trc->{"type"},
                 "$SP_ <b>", ($trc->{"name"} ? $SPID.$trc->{"name"}.$SP_ :
                                              "<i>${SPNC}unnamed$SP_</i>"),
                 "</b></td></tr>\n";
    }
    map { print $handle "<tr>$TDI$TDI$TDI<td colspan=\"2\">$SPDOC$_$SP_</td></tr>\n" }
                          @{$trc->{"doc"}->{"description"}};
  }
}


# Print HTML fragment describing a process
# -> File handle to print to
#    Reference to array containing the path to the process
sub printprochtml
{
  my ($handle, $path)= @_;
  my $proc= $$path[$#$path];

  print $handle "<tr$CCO><td colspan=\"5\"><b>", ($proc->{"name"} ?
            $SPDID.$proc->{"name"}.$SP_ : "<i>${SPNC}unnamed$SP_</i>"), "</b>",
  ($proc->{"sensitivity"}? " (" . markvhdl($proc->{"sensitivity"}) . ")" : ""), 
          "</td></tr>\n";
  print $handle "<tr$CCO>$TDI<td colspan=\"4\"><b>${SPWD}postponed$SP_</b></td></tr>\n"
        if $proc->{"postponed"};
  printcommonhtml($handle, $proc);
  printtracehtml($handle, $path);
}



# Print HTML fragment describing an instantiation
# -> File handle to print to
#    Reference to array containing the path to the instance
sub printinsthtml
{
  my ($handle, $path)= @_;
  my $inst= $$path[$#$path];

  print $handle "<tr$CCO><td colspan=\"5\"><b><a name=\"", $labels{"instance"},
              $inst->{"name"}, "\">$SPDID", $inst->{"name"}, "$SP_</a></b> : ";
  if( $inst->{"subtype"} eq "configuration" ) {
    print $handle "${SPWD}configuration$SP_ ";
    if( $inst->{"binding"} ) {
      print $handle "<a href=\"../configurations/",
                $inst->{"binding"}->{"docfilename"}, "\">$SPID",
                $inst->{"objname"}, "$SP_</a></td></tr>\n";
    }
    else {
      print $handle $SPID, $inst->{"objname"}, "$SP_</td></tr>\n";
    }
  }
  elsif( $inst->{"subtype"} eq "entity" ) {
    print $handle "${SPDCL}entity$SP_ ";
    if( $inst->{"binding"} ) {
      print $handle "<a href=\"../entities/",
                $inst->{"binding"}->{"docfilename"}, "\">$SPID",
                $inst->{"objname"}, "$SP_</a>";
    }
    else {
      print $handle $inst->{"objname"};
    }
    if( $inst->{"bindarch"} ) {
      print $handle " (<a href=\"../architectures/",
                    $inst->{"bindarch"}->{"docfilename"}, "\">$SPID",
                    $inst->{"archname"}, "$SP_</a>)";
    }
    elsif( $inst->{"archname"} ) {
      print $handle " ($SPID", $inst->{"archname"}, "$SP_)";
    }
    print $handle "</td></tr>\n";
  }
  elsif( $inst->{"component"} ) {
    print $handle "<a href=\"", $inst->{"component"}->{"doclink"}, "\">$SPID",
                  $inst->{"objname"}, "$SP_</a></td></tr>\n";
  }
  else {
    print $handle $SPID, $inst->{"objname"}, "$SP_</td></tr>\n";
  }
  printcommonhtml($handle, $inst);
  if( $inst->{"genericmap"} && @{$inst->{"genericmap"}} ) {
    my @gmap= @{$inst->{"genericmap"}};
    print $handle "<tr>$TDI<td colspan=\"4\">Generic map:</td></tr>\n",
                  "<tr>$TDI$TDI<td colspan=\"3\"><table border=\"0\"$CCO>\n";
    map { print $handle "  <tr><td>$SPID", $$_[0], "$SP_</td><td> => ",
                              markvhdl($$_[1]), "</td></tr>\n"; } @gmap;
    print $handle "</table></td></tr>\n";
  }
  # Now for explicit binding of component instances
  if( $inst->{"subtype"} eq "component" &&
      ((my $bind= $inst->{"binding"}) || $inst->{"bindname"}) ) {
    if( $bind ) {
      print $handle "<tr>$TDI<td colspan=\"4\">Binding: $SPCO<a href=\"",
      ($bind->{"type"} eq "entity" ?  "../entities/" : "../configurations/"),
          $bind->{"docfilename"}, "\">$SPID", $bind->{"fullname"},
          "$SP_</a>";
    }
    else {
      print $handle "<tr>$TDI<td colspan=\"4\">Binding: $SPCO$SPID",
                      $inst->{"bindname"}, "$SP_";
    }
    if( $inst->{"archname"} ) {
      if( $inst->{"bindarch"} ) {
        print $handle " (<a href=\"../architectures/",
                      $inst->{"bindarch"}->{"docfilename"}, "\">$SPID",
                      $inst->{"archname"}, "$SP_</a>)";
      }
      else {
        print $handle " ($SPID", $inst->{"archname"}, "$SP_)";
      }
    }
    print $handle "$SP_</td></tr>\n";
    map { print $handle "<tr>$TDI$TDI<td colspan=\"3\">$SPDOC$_$SP_</td></tr>\n" }
                        @{$inst->{"binddoc"}};
    if( $inst->{"bindgen"} ) {
      my $map= $inst->{"bindgen"}->{"map"};
      print $handle "<tr>$TDI$TDI<td colspan=\"3\">Generic map:</td></tr>\n",
                "<tr>$TDI$TDI$TDI<td colspan=\"2\"><table border=\"0\"$CCO>\n";
      map { print $handle "  <tr><td>$SPID", $$_[0], "$SP_</td><td> => ",
                                markvhdl($$_[1]), "</td></tr>\n"; } @$map;
      print $handle "</table></td></tr>\n";
    }
  }
  printtracehtml($handle, $path, "instantiation");
}


# Print HTML fragment documenting PSL statements in an architecture or package.
# -> File handle to print to
#    Reference to hash representing the architecture / package
sub printpslhtml
{
  my ($handle, $obj)= @_;
  my @allpsl;
  my @psldefs;
  my @psldirs;

  @allpsl= trace_all($obj, "type", "psl");
  return unless @allpsl;
  for (@allpsl) {
    if( $_->[-1]->{"subtype"} =~ /^(?:property|sequence|endpoint|default clock)$/ ) {
        push @psldefs, $_;
    }
    else {
        push @psldirs, $_;
    }
  }
  if( @psldefs ) {
    print $handle "\n<h2>PSL definitions</h2>\n\n$STDTAB\n";
    for my $trc (@psldefs) {
      my $def= $trc->[-1];
      print $handle "<tr$CCO><td colspan=\"5\">$SPPSL$def->{subtype}$SP_ ";
      print $handle "<a name=\"$labels{psl}$def->{name}\">$SPPID$def->{name}$SP_</a> "
          if $def->{"name"};
      print $handle " (", markvhdl($def->{"parlist"}), ")",
                    "</td></tr>\n<tr$CCO>$TDI<td colspan=\"4\">"
          if $def->{"parlist"};
      print $handle "${SPWD}is$SP_ ", markvhdl($def->{"value"}), "</td></tr>\n";
      printcommonhtml($handle, $def);
      printpslrefhtml($handle, $def);
      printtracehtml($handle, $trc, "definition");
    }
    print $handle "</table>\n\n";
  }
  if( @psldirs ) {
    print $handle "\n<h2>PSL directives</h2>\n\n$STDTAB\n";
    for my $trc (@psldirs) {
      my $dir= $trc->[-1];
      print $handle "<tr$CCO><td>";
      print $handle "$SPPID$dir->{name}$SP_ : " if $dir->{"name"};
      print $handle "</td><td colspan=\"4\"><b>$SPPSL$dir->{subtype}$SP_</b> ",
                    markvhdl($dir->{"property"} || $dir->{"sequence"}),
                    "</td></tr>\n";
      print $handle "<tr$CCO>$TDI<td colspan=\"4\">${SPWD}report$SP_ ",
                    markvhdl($dir->{"report"}), "</td></tr>\n"
          if $dir->{"report"};
      printcommonhtml($handle, $dir);
      printpslrefhtml($handle, $dir);
      printtracehtml($handle, $trc, "directive");
    }
    print $handle "</table>\n\n";
  }
}


# Print Links to PSL definitions referenced in a given PSL statement.
# -> File handle to print to
#    PSL code fragment to be searched for identifiers referring to definitions.
sub printpslrefhtml
{
  my ($handle, $psl)= @_;

  my $refs= $psl->{"defrefs"};
  return unless $refs && @$refs;
  print $handle "<tr>$TDI<td colspan=\"4\">Referenced definition",
                (@$refs > 1 ? "s" : ""), ": ",
            join(", ", map "<a href=\"$_->{doclink}\">$_->{name}</a>", @$refs),
                "</td></tr>\n";
}


my $archhtmlerr= 0;

# Write the HTML documentation for an architecture
# -> Reference to hash representing architecture
sub architecturehtml
{
  my ($arch)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"}, "architectures",
                                 $arch->{"docfilename"});
  my $ent= $arch->{"entity"};
  my $headname= $arch->{"name"} . " of " . $arch->{"objname"};

  if( !open(ARCH, ">$fname") ) {
    limitfileerr("Cannot create output file $fname", \$archhtmlerr);
    return;
  }
  printhtmlheader(*ARCH{IO}, $headname);
  if( $ent ) {
    print ARCH "\n<h1>Architecture ", $arch->{"name"}, 
          " of <a href=\"../entities/", $ent->{"docfilename"},
          "\">", $ent->{"fullname"}, "</a></h1>\n\n";
  }
  else {
    print ARCH "\n<h1>Architecture ", $arch->{"name"}, " of ", 
          $arch->{"objname"}, "</a></h1>\n\n";
  }
  printobjhtml(*ARCH{IO}, $arch);
  printinstantiated(*ARCH{IO}, $arch);
  print ARCH "\n<hr>\n\n";
  printlibusehtml(*ARCH{IO}, $arch);
  if( my @types= @{$arch->{"childtype"}->{"type"}} ) {
    print ARCH "\n<h2>Type declarations</h2>\n\n$STDTAB\n";
    map { printtypehtml(*ARCH{IO}, $_) } @types;
    print ARCH "</table>\n\n";
  }
  if( my @consts= @{$arch->{"childtype"}->{"constant"}} ) {
    print ARCH "\n<h2>Constants</h2>\n\n$STDTAB\n";
    map { printgenporthtml(*ARCH{IO}, $_) } @consts;
    print ARCH "</table>\n\n";
  }
  printfuncprochtml(*ARCH{IO}, $arch);
  if( my @comps= @{$arch->{"childtype"}->{"component"}} ) {
    print ARCH "\n<h2>Component declarations</h2>\n\n$STDTAB\n";
    map { printcomphtml(*ARCH{IO}, $_) } @comps;
    print ARCH "</table>\n\n";
  }
  printpslhtml(*ARCH{IO}, $arch);
  if( my @procs= trace_all($arch, "type", "process") ) {
    print ARCH "\n<h2>Processes</h2>\n\n$STDTAB\n";
    map { printprochtml(*ARCH{IO}, $_) } @procs;
    print ARCH "</table>\n\n";
  }
  if( my @insts= trace_all($arch, "type", "instance") ) {
    print ARCH "\n<h2>Instantiations</h2>\n\n$STDTAB\n";
    map { printinsthtml(*ARCH{IO}, $_) } @insts;
    print ARCH "</table>\n\n";
  }
  printhtmlfooter(*ARCH{IO});
  close ARCH;
}


# Prints one level of the hierarchy of for...use statements in a configuration
# and recursively calls itself to print the deeper levels
# -> File handle to print to
#    Reference to array of references to hashes representing for statements at
#    the same level
#    Current depth in the hierarchy (for indentation)
#    Maximal depth (for colspan attribute of <td> tag)
sub printconfightml
{
  my ($handle, $fors, $curdepth, $maxdepth)= @_;
  my $ind2= $TDI x $curdepth;
  my $span= $maxdepth - $curdepth + 3;

  for my $for (@$fors) {
    print $handle "<tr$CCO>$ind2<td colspan=\"", $span, "\">${SPWD}for$SP_ <b>";
    if( $for->{"subtype"} eq "architecture" ) {
      if( $for->{"object"} && $for->{"object"}->{"type"} eq "architecture" ) {
        print $handle "<a href=\"../architectures/",
                $for->{"object"}->{"docfilename"}, "\">$SPID",
                $for->{"objname"}, "$SP_</a></b></td></tr>\n";
      }
      else {
        print $handle $SPID, $for->{"objname"}, "$SP_</b></td></tr>\n";
      }
      map { print $handle "<tr>$ind2$TDI<td colspan=\"", $span-1, "\">$SPDOC",
                   "$_$SP_</td></tr>\n" }    @{$for->{"doc"}->{"description"}};
    }
    else {
      my $comp;
      my $use;
      if( @{$for->{"objnames"}}==1 && ($for->{"objnames"}->[0] eq "all" ||
                                $for->{"objnames"}->[0] eq "others") ) {
        print $handle $SPWD, $for->{"objnames"}->[0], $SP_;
        $comp= $for->{"objects"}->[0]->{"component"}
                if $for->{"objects"} && @{$for->{"objects"}};
      }
      elsif( $for->{"objects"} && @{$for->{"objects"}} ) {
        print $handle join("</b>, <b>", map("<a href=\"" . $_->{"doclink"} .
              "\">$SPID" . $_->{"name"} . "$SP_</a>", @{$for->{"objects"}}));
        $comp= $for->{"objects"}->[0]->{"component"};
      }
      else {
        print $handle $SPID, join("$SP_</b>, <b>$SPID", @{$for->{"objnames"}}),
                      $SP_;
      }
      if( $comp ) {
        print $handle "</b> : <a href=\"", $comp->{"doclink"}, "\">$SPID",
                      $for->{"objtype"}, "$SP_</a>";
      }
      else {
        print $handle "</b> : $SPID", $for->{"objtype"}, $SP_;
      }
      if( $use= $for->{"use"} ) {
        if( $for->{"binding"} ) {
          print $handle " ${SPWD}use$SP_ $SPDCL", $use->{"subtype"},
                "$SP_ <a href=\"../",
              ($use->{"subtype"} eq "entity"? "entities/" : "configurations/"),
                $for->{"binding"}->{"docfilename"}, "\">$SPID", $use->{"name"},
                "$SP_</a>";
          if( $for->{"bindarch"} ) {
            print $handle " (<a href=\"../architectures/",
                          $for->{"bindarch"}->{"docfilename"}, "\">$SPID",
                          $for->{"archname"}, "$SP_</a>)</td>$SP_</tr>\n";
          }
          elsif( $use->{"archname"} ) {
           print $handle " ($SPID", $use->{"archname"}, "$SP_)</td>$SP_</tr>\n";
          }
        }
        else {
          print $handle " use ", $use->{"subtype"}, " ", $use->{"name"},
            ($use->{"archname"}? "($SPID" . $use->{"archname"} . "$SP_)" : ""),
                "</td>$SP_</tr>\n";
        }
      }
      else {
        print $handle "</td>$SP_</tr>\n";
      }
      map { print $handle "<tr>$ind2$TDI<td colspan=\"", $span-1, "\">$SPDOC",
                   "$_$SP_</td></tr>\n" }    @{$for->{"doc"}->{"description"}};
      map { print $handle "<tr>$ind2$TDI<td colspan=\"", $span-1, "\">$SPDOC",
           "$_$SP_</td></tr>\n" }    @{$for->{"use"}->{"doc"}->{"description"}};
      if( $for->{"bindgen"} ) {
        my $map= $for->{"bindgen"}->{"map"};
        print $handle "<tr>$ind2$TDI<td colspan=\"", $span-1,
                "\">Generic map:</td></tr>\n<tr>$ind2$TDI$TDI<td colspan=\"",
                $span-2, "\"><table border=\"0\"$CCO>\n";
        map { print $handle "  <tr><td>$SPID", $$_[0], "$SP_</td><td> => ",
                                  markvhdl($$_[1]), "</td></tr>\n"; } @$map;
        print $handle "</table></td></tr>\n";
      }
    }
    my @nextfors= find_children($for, "type", "for");
    printconfightml($handle, \@nextfors, $curdepth+1, $maxdepth);
  }
}


my $confhtmlerr= 0;

# Write the HTML documentation for a configuration
# -> Reference to hash representing configuration
sub configurationhtml
{
  my ($conf)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"}, "configurations",
                                 $conf->{"docfilename"});
  my $ent= $conf->{"entity"};
  my $headname= $conf->{"name"} . " of " . $conf->{"objname"};
  my $maxdepth;
  my @topfors;

  if( !open(CONF, ">$fname") ) {
    limitfileerr("Cannot create output file $fname", \$confhtmlerr);
    return;
  }
  printhtmlheader(*CONF{IO}, $headname);
  if( $ent ) {
    print CONF "\n<h1>Configuration ", $conf->{"name"}, 
          " of <a href=\"../entities/", $ent->{"docfilename"},
          "\">", $ent->{"fullname"}, "</a></h1>\n\n";
  }
  else {
    print CONF "\n<h1>Configuration ", $conf->{"name"}, " of ", 
          $conf->{"objname"}, "</a></h1>\n\n";
  }
  printobjhtml(*CONF{IO}, $conf);
  printinstantiated(*CONF{IO}, $conf);
  print CONF "\n<hr>\n\n";
  printlibusehtml(*CONF{IO}, $conf);
  print CONF "\n<h2>Configuration</h2>\n\n$STDTAB\n";
  $maxdepth= max_depth($conf);
  @topfors= @{$conf->{"childtype"}->{"for"} || []};
  printconfightml(*CONF{IO}, \@topfors, 0, $maxdepth);
  print CONF "</table>\n";
  printhtmlfooter(*CONF{IO});
  close CONF;
}


my $packhtmlerr= 0;

# Write the HTML documentation for a package or orphaned package body.  The
# documentation of functions and procedures in a package and the corresponding
# package body are concatenated and printed in the documentation of the package
# only.  To this end, the duplicate functions/procedures are removed from the
# package body hash, and their the documentation in the package is modified.
# If no declarations specific to the package body remain to be documented, the
# section about the package body is left out.
# -> Reference to hash representing package or package body
sub packagehtml
{
  my ($pack)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"}, "packages",
                                 $pack->{"docfilename"});
  my $pbody;

  if( !open(PACK, ">$fname") ) {
    limitfileerr("Cannot create output file $fname", \$packhtmlerr);
    return;
  }
  printhtmlheader(*PACK{IO}, $pack->{"fullname"});
  if( $pack->{"type"} eq "package" ) {
    $pbody= $pack->{"packagebody"};
    if( $pbody ) {
      my ($pbfuncs, $pbprocs, $pbfuncprocs, $pbconsts)= ( [], [], [], [] );
      for my $f (@{$pbody->{"childtype"}->{"function"}}) {
        my $el= elem { packsubeq($_, $f) } @{$pack->{"childtype"}->{"function"}};
        if( $el ) {
          push @{$el->{"doc"}->{"description"}},
                    @{$f->{"doc"}->{"description"} || []};
        }
        else {
          push @$pbfuncs, $f
        }
      }
      for my $p (@{$pbody->{"childtype"}->{"procedure"}}) {
        my $el= elem { packsubeq($_, $p) } @{$pack->{"childtype"}->{"procedure"}};
        if( $el ) {
          push @{$el->{"doc"}->{"description"}},
                    @{$p->{"doc"}->{"description"} || []};
        }
        else {
          push @$pbprocs, $p;
        }
      }
      # Can't just concatenate ->{"function"} and ->{"procedure"} because we
      # want to preserve order
      for my $f (@{$pbody->{"childtype"}->{"funcproc"}}) {
        push @$pbfuncprocs, $f if elem { $_ == $f } (@$pbfuncs, @$pbprocs);
      }
      for my $c (@{$pbody->{"childtype"}->{"constant"}}) {
        my $el= elem { lc($c->{"name"}) eq lc($_->{"name"}) }
                        @{$pack->{"childtype"}->{"constant"}};
        if( $el ) {
          push @{$el->{"doc"}->{"description"}},
                    @{$c->{"doc"}->{"description"} || []};
        }
        else {
          push @$pbconsts, $c;
        }
      }
      @{$pbody->{"childtype"}}{qw(function procedure funcproc constant)}=
                                 ($pbfuncs, $pbprocs, $pbfuncprocs, $pbconsts);
    }
    print PACK "<h1>Package ", $pack->{"fullname"}, "</h1>\n\n";
    printobjhtml(*PACK{IO}, $pack);
    print PACK "\n<hr>\n\n";
    printlibusehtml(*PACK{IO}, $pack);
    if( my @types= @{$pack->{"childtype"}->{"type"}} ) {
      print PACK "\n<h2>Type declarations</h2>\n\n$STDTAB\n";
      map { printtypehtml(*PACK{IO}, $_) } @types;
      print PACK "</table>\n\n";
    }
    if( my @consts= @{$pack->{"childtype"}->{"constant"}} ) {
      print PACK "\n<h2>Constants</h2>\n\n$STDTAB\n";
      map { printgenporthtml(*PACK{IO}, $_) } @consts;
      print PACK "</table>\n\n";
    }
    printfuncprochtml(*PACK{IO}, $pack);
    if( my @comps= @{$pack->{"childtype"}->{"component"}} ) {
      print PACK "\n<h2>Component declarations</h2>\n\n$STDTAB\n";
      map { printcomphtml(*PACK{IO}, $_) } @comps;
      print PACK "</table>\n\n";
    }
    printpslhtml(*PACK{IO}, $pack);
    unless( $pbody ) {
      printhtmlfooter(*PACK{IO});
      close PACK;
      return;
    }
  }
  else {
    $pbody= $pack;
    $pack= undef;
  }
  # Only document package body if it contains further declarations
  unless( @{$pbody->{"childtype"}->{"type"}} ||
          @{$pbody->{"childtype"}->{"funcproc"}} ||
          @{$pbody->{"childtype"}->{"constant"}} ) {
    printhtmlfooter(*PACK{IO});
    close PACK;
    return;
  }
  print PACK "\n\n<hr>\n\n";
  print PACK "<h1>Package body ", $pbody->{"fullname"}, "</h1>\n\n";
  printobjhtml(*PACK{IO}, $pbody);
  print PACK "\n<hr>\n\n";
  printlibusehtml(*PACK{IO}, $pbody);
  if( my @types= @{$pbody->{"childtype"}->{"type"}} ) {
    print PACK "\n<h2>Type declarations</h2>\n\n$STDTAB\n";
    map { printtypehtml(*PACK{IO}, $_) } @types;
    print PACK "</table>\n\n";
  }
  if( my @consts= @{$pbody->{"childtype"}->{"constant"}} ) {
    print PACK "\n<h2>Constants</h2>\n\n$STDTAB\n";
    map { printgenporthtml(*PACK{IO}, $_) } @consts;
    print PACK "</table>\n\n";
  }
  printfuncprochtml(*PACK{IO}, $pbody);
  printhtmlfooter(*PACK{IO});
  close PACK;
}


my $sourcehtmlerr= 0;
my @htmlescapes= qw( x &amp; &lt; &gt; &quot; );

# Generate the HTML page for a source file.
# -> Reference to hash representing the VHDL file
sub sourcehtml
{
  my ($file)= @_;
  my $srcfname= $file->{"name"};
  my $outfname= File::Spec->catfile($config{"outputdir"}, "sources",
                                    $file->{"docfilename"});
  my $header;
  my $source;
  my $markedcode;

  if( !open(VHDL, $srcfname) ) {
    limitfileerr("Cannot open source file $srcfname for generating source HTML file", \$sourcehtmlerr);
    return;
  }
  if( !open(SRCHTML, ">$outfname") ) {
    limitfileerr("Cannot create output file $outfname", \$sourcehtmlerr);
    close VHDL;
    return;
  }
  {
      local $/;
      $source= <VHDL>;
  }
  close VHDL;
  if( $file->{"tabsize"} ) {
    $tabstop= $file->{"tabsize"};
    $source= expand($source);
  }
  my $endnewline= $source =~ /\n$/;
  $source =~ s/[ \t\r]+\n/\n/g;
  $source =~ tr/&<>"/\x01\x02\x03\x04/;
  $source =~ s/(($MARKQUOT)|(--)(?:([+*])(?:[^+*\n].*)?|.*)(?=\n)|($ID))/
            ($3 ? $4 ? $SPDOC : $SPDO : $2 ? $SPSTR :
             $SPANCLASS{lc($5)} || $SPID) . $1 . $SP_ /ieog;
  $source =~ s/([\x01-\x04])/$htmlescapes[ord $1]/ge;
  $source= "<div class=\"shaded\">$source";
  my ($shadeon, $shadeoff)= ("\n<div class=\"shaded\">", "\n</div>");
  my $linenr= 0;
  my $nlines= $source =~ s/\n/++$linenr & 1 ? $shadeoff : $shadeon/ge;
  $source .= "</div>" if ($linenr & 1) == 0;
  ++$nlines unless $endnewline;

  printhtmlheader(*SRCHTML{IO}, $file->{"name"});
  print SRCHTML "\n<h1>Source file ", $file->{"name"}, "</h1>\n";
  print SRCHTML "\n<p><a href=\"", ($file->{"link"} =~ /^\w+:\/\// ? "":"../"),
                                $file->{"link"}, "\">Link to file</a></p>\n"
        if $config{"sourcelinks"};
  print SRCHTML "<table border=\"0\" cellpadding=\"0\"><tr><td><pre>\n";
  my $nrwidth= length($nlines);
  for my $nr (1..$nlines) {
    printf SRCHTML "%${nrwidth}d \n", $nr;
  }
  print SRCHTML "</pre></td><td width=\"15\"></td><td>\n";
  print SRCHTML "<pre$CCO>\n$source</pre>\n</td></tr></table>\n";
  printhtmlfooter(*SRCHTML{IO});
  close SRCHTML;
}


# Create a JavaScript file in the style folder which performs VHDL syntax
# markup.
# (->) %SPANCLASS
sub makemarkupjs
{
  my $jsfname= File::Spec->catfile($config{"outputdir"}, "style",
                                    $config{"prefix"} . "vhdlmarkup.js");
  my %markwords= revhash %SPANCLASS;
  my %markrenames;

  if( !open(JS, ">$jsfname") ) {
    print STDERR "Cannot create file $jsfname for VHDL source markup - $!\n";
    return;
  }
  print JS <<EOF;
window.onload = function() {
    var lnumpre= document.getElementById('linenumbers');
    var vhdlpre= document.getElementById('vhdlcode');
    var nlines;
    {
        var newlpos= vhdlpre.innerHTML.match(/\\n/g);
        nlines= newlpos.length;
        if( vhdlpre.innerHTML.charAt(vhdlpre.innerHTML.length - 1) != "\\n" ) {
            ++nlines;
        }
    }
    var slfrom= -String(nlines).length;
    for( var linenr= 1; linenr <= nlines; ++linenr ) {
        lnumpre.innerHTML += String("        " + linenr).slice(slfrom) + " \\n";
    }
    var idregex= /&?\\b[a-zA-Z](?:\\w*[a-zA-Z0-9])?\\b/g;
    var re_entity= /^&/;
EOF
  for my $spanclass (keys %markwords) {
    my $regexname= $spanclass;
    $regexname =~ s/^<span class="/re_/i;
    $regexname =~ s/">$//;
    $regexname =~ s/\s/_/g;
    $markrenames{$spanclass}= $regexname;
    print JS "    var $regexname= /^(?:", join("|", @{$markwords{$spanclass}}),
             ")\$/i;\n"
  }
  print JS <<EOF;
    var html= vhdlpre.innerHTML;
    var re_quotcom= /((?:\\b[box])?"[^"]*"|'[^']'|--[^\\r\\n]*)/ig;
    var quotcoms= html.match(re_quotcom);
    if( quotcoms ) {
        html= html.replace(re_quotcom, "\\x01");
    }
    var ids= html.match(idregex);
    if( ids ) {
        html= html.replace(idregex, "\\x02");
        var gaps= html.split( "\\x02" );
        html= "";
        for( var ind= 0; ind< ids.length; ++ind ) {
            var markclass= "";
            var markclose= "$SP_";
            if( re_entity.exec(ids[ind]) ) {
                markclose= "";
            }
            else
EOF
  for my $spanclass (keys %markwords) {
    my $regexname= $markrenames{$spanclass};
    print JS <<EOF;
            if( $regexname.exec(ids[ind]) ) {
                markclass= '$spanclass';
            }
            else
EOF
  }
  print JS <<EOF;
            {   markclass= '$SPID';
            }
            html += gaps[ind] + markclass + ids[ind] + markclose;
        }
        html += gaps[gaps.length - 1];
    }
    if( quotcoms ) {
        var nonquotcoms= html.split("\\x01");
        html= "";
        var re_spantag= /<span class="[^"]+">|<\\/span>/gi;
        for( var ind= 0; ind < quotcoms.length; ++ind ) {
            quotcoms[ind].replace(re_spantag, "");
            var markclass= '$SPSTR';
            if( quotcoms[ind].charAt(0) == "-" ) {
                markclass= quotcoms[ind].charAt(2) == "*"? '$SPDOC' : '$SPDO';
            }
            html += nonquotcoms[ind] + markclass + quotcoms[ind] + "$SP_";
        }
        html += nonquotcoms[nonquotcoms.length - 1];
    }
    html= '<div class="shaded">' +
          html.replace(/\\n([^\\n]*\\n)/g, '\\n</div>\$1<div class="shaded">');
    if( nlines & 1 == 1 ) {
        html += '</div>';
    }
    vhdlpre.innerHTML= html;
}
EOF
  close JS;
}


# Generate the HTML page for a source file.  This function generates HTML code
# which uses the JavaScript SyntaxHighlighter tool.
# -> Reference to hash representing the VHDL file
sub sourcehtml_js
{
  my ($file)= @_;
  my $srcfname= $file->{"name"};
  my $outfname= File::Spec->catfile($config{"outputdir"}, "sources",
                                    $file->{"docfilename"});
  my $header;

  if( !open(VHDL, $srcfname) ) {
    limitfileerr("Cannot open source file $srcfname for generating source HTML file", \$sourcehtmlerr);
    return;
  }
  if( !open(SRCHTML, ">$outfname") ) {
    limitfileerr("Cannot create output file $outfname", \$sourcehtmlerr);
    close VHDL;
    return;
  }
  printhtmlheader(\$header, $file->{"name"});
  $header =~ s!(?=</head>)!<<EOF!ie;
    <script type="text/javascript" src="../style/$config{prefix}vhdlmarkup.js"></script>
EOF
  print SRCHTML $header;
  print SRCHTML "\n<h1>Source file ", $file->{"name"}, "</h1>\n";
  print SRCHTML "\n<p><a href=\"", ($file->{"link"} =~ /^\w+:\/\// ? "":"../"),
                                $file->{"link"}, "\">Link to file</a></p>\n"
        if $config{"sourcelinks"};
  print SRCHTML "<table><tr><td><pre id=\"linenumbers\">\n";
  print SRCHTML "</pre></td><td><pre id=\"vhdlcode\" class=\"vhdlcode\">\n";
  $tabstop= $file->{"tabsize"} if $file->{"tabsize"};
  while( <VHDL> )
  {
    $_= expand($_) if $file->{"tabsize"};
    s/&/&amp;/g;
# Don't replace " by entity to facilitate regex string matching in JavaScript.
    s/</&lt;/g;
    s/>/&gt;/g;
    print SRCHTML $_;
  }
  print SRCHTML "</pre></td></tr></table>\n";
  printhtmlfooter(*SRCHTML{IO});
  close SRCHTML;
  close VHDL;
}


# Generate the HTML page listing entities, architectures and configurations
# -> Reference to array of hash references representing entities
#    Reference to array of hash references representing architectures not
#    associated with any entity (known to us)
#    Reference to array of hash references representing configurations not
#    associated with any entity (known to us)
#    Flag indicating that there are configurations at all
sub entitylisthtml
{
  my ($ents, $oarchs, $oconfs, $haveconfs)= @_;
  my @list;
  my $fname= File::Spec->catfile($config{"outputdir"},
                                $config{"prefix"} . "entities.html");

  if( !open(LIST, ">$fname") ) {
    print STDERR "Cannot create output file $fname - $!\n";
    return;
  }
  for my $oa (@$oarchs) {
    if( my ($elem)= grep(lc($_->{"name"}) eq lc($oa->{"objname"}), @list) ) {
      push @{$elem->{"architectures"}}, $oa;
    }
    else {
      push @list, { "name", $oa->{"objname"}, "architectures", [ $oa ] };
    }
  }
  for my $oc (@$oconfs) {
    if( my ($elem)= grep(lc($_->{"name"}) eq lc($oc->{"objname"}), @list) ) {
      push @{$elem->{"configurations"}}, $oc;
    }
    else {
      push @list, { "name", $oc->{"objname"}, "configurations", [ $oc ] };
    }
  }
  push @list, (map { "name", $_->{"fullname"}, "entity", $_, 
                     "architectures", $_->{"architectures"},
                     "configurations", $_->{"configurations"} }, @$ents);
  @list= sort { $a->{"name"} cmp $b->{"name"} } @list;
  printhtmlheader(*LIST{IO}, "Entities, Architectures and Configurations", 1);
  print LIST "\n<h1>List of entities", ($haveconfs?
     ", architectures and configurations" : " and architectures"), "</h1>\n";
  if( !@list ) {
    print LIST "\n<p>No entities, architectures or configurations were ",
                "found.</p>\n";
    printhtmlfooter(*LIST{IO});
    close LIST;
    return;
  }
  elsif( $haveconfs ) {
    print LIST "\n<p>Configurations are given in <i>italics</i>.</p>\n";
  }
  print LIST "\n\n$STDTAB\n";
  for my $item (@list) {
    if( $item->{"entity"} ) {
      print LIST "<tr><td colspan=\"2\"><a href=\"entities/",
                $item->{"entity"}->{"docfilename"}, 
                "\"><b>", $item->{"name"}, "</b></a></td>";
      if( my $brief= ($item->{"entity"}->{"doc"}->{"brief"} ||
                      $item->{"entity"}->{"doc"}->{"short"}) ) {
        print LIST "<td>$brief</td>\n";
      }
      print LIST "</tr>\n";
    }
    else {
      print LIST "<tr><td colspan=\"2\"><b>", $item->{"name"}, "</b></td></tr>\n";
    }
    for my $arch (@{$item->{"architectures"}}) {
      print LIST "<tr>$TDI<td><a href=\"architectures/",$arch->{"docfilename"},
                 "\">", $arch->{"name"}, "</a></td>";
      if( my $brief= ($arch->{"doc"}->{"brief"} ||
                      $arch->{"doc"}->{"short"}) ) {
        print LIST "<td>$brief</td>\n";
      }
      print LIST "</tr>\n";
    }
    for my $conf (@{$item->{"configurations"}}) {
      print LIST "<tr>$TDI<td><a href=\"configurations/",
            $conf->{"docfilename"}, "\"><i>", $conf->{"name"}, "</i></a></td>";
      if( my $brief= ($conf->{"doc"}->{"brief"} ||
                      $conf->{"doc"}->{"short"}) ) {
        print LIST "<td>$brief</td>\n";
      }
      print LIST "</tr>\n";
    }
  }
  print LIST "</table>\n\n";
  printhtmlfooter(*LIST{IO});
  close LIST;
}


# Generate the HTML page listing packages
# -> Reference to array of hash references representing packages
#    Reference to array of hash references representing package bodies not
#    associated with any package (known to us), or undef
sub packagelisthtml
{
  my ($packs, $opbodies)= @_;
  my @list;
  my $fname= File::Spec->catfile($config{"outputdir"},
                                $config{"prefix"} . "packages.html");

  if( !open(LIST, ">$fname") ) {
    print STDERR "Cannot create output file $fname - $!\n";
    return;
  }
  printhtmlheader(*LIST{IO}, "Packages", 1);
  if( !@$packs && (!$opbodies || !@$opbodies) ) {
    print LIST "\n<h1>List of packages</h1>\n\n";
    print LIST "<p>No packages were found.</p>\n";
    printhtmlfooter(*LIST{IO});
    close LIST;
    return;
  }
  if( @$packs ) {
    print LIST "\n<h1>List of packages</h1>\n\n";
    for my $pack (@$packs) {
      print LIST "<p><a href=\"packages/", $pack->{"docfilename"}, "\">",
                  $pack->{"fullname"}, "</a></p>\n";
    }
  }
  if( $opbodies && @$opbodies ) {
    print LIST "\n<h1>List of orphaned package bodies</h1>\n\n";
    for my $pbody (@$opbodies) {
      print LIST "<p><a href=\"packages/", $pbody->{"docfilename"}, "\">",
                  $pbody->{"fullname"}, "</a></p>\n";
    }
  }
  printhtmlfooter(*LIST{IO});
  close LIST;
}


# Modify the HTML header and body tag to allow the hierarchical tree view to
# work.
# -> Reference to scalar containing the start of the HTML file returned by
#    printhtmlheader()
#    List of IDs of tags enclosing tree views
# (<-) modified HTML header scalar
sub maketreeviewheader
{
  my ($header, @ids)= @_;

  return unless @ids;
  $$header =~ s!(?=</head>)!<<EOF!ie;
    <link type="text/css" rel="stylesheet" href="style/treeview.css">
    <script type="text/javascript" src="style/treeview.js"></script>
EOF
  my $ind= -1;
  my $onload= join " ", map scalar(++$ind, "treeMenu_init(document.getElementById('$_'), unescape(window.name).split(',')[$ind]);"), @ids;
  my $onunload= join ").concat(',').concat(", map "escape(treeMenu_store(document.getElementById('$_')))", @ids;
  $onunload= "window.name = ($onunload);";
  $$header =~ s!<body>!<<EOF!ie;
<body
  onload="$onload"
  onunload="$onunload">
EOF
}


# Print the instantiation hierarchy or part of it in a tree view parts of which
# can be hidden or exposed using JavaScript.
# -> File handle to print to
#    Reference to array of root nodes
#    Flag indicating that the whole hierarchy should be printed rather than
#    just the first level
#    Optional: ID of the <dl> tag enclosing the hierarchy view (needed if more
#    than one such list goes onto the same page)
sub printhierarchy
{
  my ($handle, $nodes, $deep, $tagid)= @_;
  $tagid ||= "treeview";

  print $handle <<EOF;
<p><form>
<input type="button" value="Open all" onclick="treeMenu_closeOrOpenAll(document.getElementById('$tagid'), false);">
<input type="button" value="Close all" onclick="treeMenu_closeOrOpenAll(document.getElementById('$tagid'), true);">
</form></p>
<dl id="$tagid">
EOF
  my $maxdepth= 0;
  for my $node (@$nodes) {
    next unless $deep || $node->{"confname"};
    my $thismax= hier_max_depth($node);
    $maxdepth= $thismax if $maxdepth < $thismax;
  }
  for my $node (@$nodes) {
    printhiernodehtml($handle, $node, [], $maxdepth, !$deep);
  }
  print $handle "</dl>\n\n";
}


# Prints an HTML fragment describing one node in the instantiation hierarchy
# and recursively calls itself to print the children
# -> File handle to print to
#    Reference to the hash representing the hierarchy node
#    Reference to an array containing hash references of the parent nodes from
#    bottom to top, to avoid infinite loops in the case of recursive
#    instantiations
#    Maximum depth of the tree
#    (optional) If !=0, do not recurse beyond instantiations given in one
#    architecture or configuration
sub printhiernodehtml
{
  my ($handle, $node, $trace, $maxdepth, $notdeep)= @_;
  my $real= $node->{"proxy"} || $node;
  my $brief;
  my $recursion= 0;

  if( grep($_ == $real, @$trace) ) {
    $recursion= 1;
  }
  elsif( ($real->{"architecture"} &&
       ($brief= $real->{"architecture"}->{"doc"}->{"brief"} ||
                $real->{"architecture"}->{"doc"}->{"short"}))
        || ($real->{"entity"} &&
       ($brief= $real->{"entity"}->{"doc"}->{"brief"} ||
                $real->{"entity"}->{"doc"}->{"short"})) ) {
  }
  my $nodehtml= nodehtml($node);
  $node->{"done"}= 1;
  $real->{"done"}= 1;
  if( $recursion ) {
    print $handle <<EOF;
<dd><table border="0"><tr><td><img src="style/$requisites{leafimg}">&nbsp;</td>
    <td>$nodehtml ... (recursion)</td></tr></table></dd>
EOF
    return;
  }
  if( $brief ) {
    $nodehtml .= "</td><td width=\"10\"></td><td> $brief";
  }
  if( ! $real->{"children"} || ! @{$real->{"children"}} ||
      ( $notdeep && @$trace &&
    # Instantiation overview: do not descend past 1st level for architectures;
    # stop at architecture or different configuration for configurations
        ($node->{"proxy"} || !$$trace[0]->{"confname"} ||
          $$trace[0]->{"confname"} ne ($node->{"confname"} || "")) ) ) {
    print $handle <<EOF;
<dd><table border=\"0\"><tr><td><img src="style/$requisites{leafimg}">&nbsp;</td>
    <td>$nodehtml</td></tr></table></dd>
EOF
    return;
  }
  print $handle <<EOF;
<dd><table border="0"><tr><td><img src="style/$requisites{nodeimg}"><img src="style/$requisites{subtrimg}">&nbsp;</td>
    <td>$nodehtml</td></tr></table> <dl>
EOF
  unshift @$trace, $real;
  for my $child (@{$real->{"children"}}) {
    printhiernodehtml($handle, $child, $trace, $maxdepth, $notdeep);
  }
  shift @$trace;
  print $handle "</dl></dd>\n";
}


# Generate HTML code describing the module represented by a hierarchy node.
# The HTML is cached in the html field of the node hash.
# -> Reference to hierarchy node hash
#    optional: if true, prepend "../" to all links (applicable for use in
#    non-global pages in subfolders)
# <- HTML string
sub nodehtml
{
  my ($node, $nonglobal)= @_;

  return $node->{$nonglobal? "../html" : "html"} if $node->{"html"};
  my $html= "";
  if( $node->{"proxy"} ) {
    $html= nodehtml($node->{"proxy"});
  }
  else {
    if( $node->{"entname"} ) {
      $html .= "<a href=\"entities/" . $node->{"entity"}->{"docfilename"} .
                    "\">"
        if $node->{"entity"};
      $html .= "<b>" . $node->{"entname"} . "</b>";
      $html .= "</a>"
        if $node->{"entity"};
    }
    if( $node->{"archname"} ) {
      $html .= "&nbsp;";
      $html .= "<a href=\"architectures/" .
                    $node->{"architecture"}->{"docfilename"} . "\">"
        if $node->{"architecture"};
      $html .= "(" . $node->{"archname"} . ")";
      $html .= "</a>"
        if $node->{"architecture"};
    }
  }
  if( $node->{"confname"} ) {
    $html .= "&nbsp;";
    $html .= "<a href=\"configurations/" .
                  $node->{"configuration"}->{"docfilename"} . "\">"
      if $node->{"configuration"};
    $html .= "[<i>" . $node->{"confname"} . "</i>]";
    $html .= "</a>"
      if $node->{"configuration"};
  }
  $node->{"../html"}= $node->{"html"}= $html;
  $node->{"../html"} =~ s! href="! href="../!ig;
  return $node->{$nonglobal? "../html" : "html"};
}


# Generate the HTML page of the instantiation overview
# -> Reference to array containing hierarchy nodes of architectures and
#    configurations
#    Flag indicating that there are configurations at all
sub instantiationhtml
{
  my ($hier, $haveconfs)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"},
                                $config{"prefix"} . "instantiations.html");
  my $header;
  my $maxdepth;

  if( !open(INST, ">$fname") ) {
    print STDERR "Cannot create output file $fname - $!\n";
    return;
  }
  printhtmlheader(\$header, "Instantiation overview", 1);
  maketreeviewheader(\$header, "treeview");
  print INST $header;
  print INST "\n<h1>Instantiation overview</h1>\n\n";
  print INST "\n<p>Configurations are given in brackets and in <i>italics</i>.</p>\n\n"
        if $haveconfs;
  print INST <<EOF;

<p>Click on <img src="style/$requisites{nodeimg}"> to open or close one level,
on <img src="style/$requisites{subtrimg}"> to open or close all levels (only
for configurations).</p>
EOF
  printhierarchy(*INST{IO}, $hier, 0, "treeview");
  printhtmlfooter(*INST{IO});
  close INST;
}


# Generate the HTML page of the instantiation hierarchy
# -> Reference to array containing hierarchy nodes of architectures and
#    configurations
#    Flag indicating that there are configurations at all
sub hierarchyhtml
{
  my ($hier, $haveconfs)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"},
                                $config{"prefix"} . "hierarchy.html");
  my $header;
  my $maxdepth;

  if( !open(HIER, ">$fname") ) {
    print STDERR "Cannot create output file $fname - $!\n";
    return;
  }
  my @topmods= topmodules($hier);
  printhtmlheader(\$header, "Instantiation hierarchy", 1);
  maketreeviewheader(\$header, (@{$topmods[0]} ? ("topview", "otherview") : ("otherview")));
  print HIER $header;
  print HIER "\n<h1>Instantiation hierarchy</h1>\n\n";
  print HIER "\n<p>Configurations are given in brackets and in <i>italics</i>.</p>\n\n"
        if $haveconfs;
  print HIER <<EOF;

<p>Click on <img src="style/$requisites{nodeimg}"> to open or close one level,
on <img src="style/$requisites{subtrimg}"> to open or close all levels.</p>
EOF
  if( @{$topmods[0]} ) {
    print HIER "<h3>Designated top modules</h3>\n\n";
    printhierarchy(*HIER{IO}, $topmods[0], 1, "topview");
    print HIER "<h3>Other uninstantiated modules</h3>\n\n";
  }
  my @leftovers= grep !$_->{"done"}, @$hier;
  printhierarchy(*HIER{IO}, [@{$topmods[1]}, @leftovers], 1, "otherview");
  printhtmlfooter(*HIER{IO});
  close HIER;
}


# Generate list of source files with links to their HTML files.
# -> Reference to array of hashes representing VHDL source files
sub sourcelisthtml
{
  my ($sources)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"},
                                $config{"prefix"} . "sources.html");

  if( !open(SOURCE, ">$fname") ) {
    print STDERR "Cannot create output file $fname - $!\n";
    return;
  }
  printhtmlheader(*SOURCE{IO}, "Source file overview", 1);
  print SOURCE "\n<h1>Source file overview</h1>\n";
  print SOURCE "\n<p>The file paths link to HTML pages showing the sources; the links in brackets point to the actual source files.</p>\n";
  my @srclist= sort { $a->{"name"} cmp $b->{"name"} } @$sources;
  print SOURCE "\n<table border=\"0\">\n";
  for my $file (@srclist) {
    print SOURCE "<tr><td><a href=\"sources/", $file->{"docfilename"}, "\">",
                $file->{"name"}, "</a>";
    print SOURCE "&nbsp;&nbsp;&nbsp;</td><td><a href=\"" . $file->{"link"}, "\">[source file]</a>"
        if $config{"sourcelinks"};
    print SOURCE "</td></tr>\n";
  }
  print SOURCE "</table>\n";
  printhtmlfooter(*SOURCE{IO});
  close LIST;
}


##############################################################################
##############################################################################
####                    Main program
##############################################################################
##############################################################################

my @vhdlfiles= @{parseargv(\@ARGV)};

if( $config{"benchmark"} ) {
  eval { require Time::HiRes; };
  if( $@ ) {
    print STDERR "Module Time::HiRes not found, which is required for --benchmark.  Aborting.\n";
    exit 1;
  }
}

$config{"absoutputdir"}= mycanonpath($config{"outputdir"});

if( uniq_files(\@vhdlfiles) ) {
  print STDERR "Warning: Duplicate source file names were removed.\n";
}

unless( @vhdlfiles ) {
  print "No source files given - nothing to be done.\n"
        unless $config{"quiet"};
  exit;
}

prepareoutput();
prepareparallel();

# This is the only data structure relating to declarative items which does not
# conform to our canonical format (see parsefile()).  %libraries is a hash
# mapping the library name to an array reference containing all (top-level)
# declarations in that library.
my %libraries;

{
my %docfilenames;

while( defined(my $fileind= parsenext(\@vhdlfiles)) ) {
  my $file= $vhdlfiles[$fileind];
  push @{$libraries{lc($file->{"libname"})}}, @{$file->{"children"}};
  my $trunkname;
  (undef, undef, $trunkname)= File::Spec->splitpath($file->{"name"});
  $trunkname =~ s/\.[^\.]*$//;
  $file->{"link"}= sourcelink($file->{"name"});
  $file->{"docfilename"}= $config{"prefix"} . $trunkname . ".html";
  push @{$docfilenames{$file->{"docfilename"}}}, $file;
}

getgitmeta();

# Disambiguate duplicate source HTML file names
for my $docfiles (values %docfilenames) {
  next if @$docfiles == 1;
  for my $file (@$docfiles) {
    my $suffix= substr(Digest::MD5::md5_hex($file->{"name"}), 0, 8);
    $file->{"docfilename"} =~ s/\.html$/_$suffix.html/i;
  }
}

}

print "Scrunching and twisting everything together...\n" unless $config{"quiet"};
benchmark() if $config{"benchmark"};

my @entities;
my @architectures;
my @configurations;
my @packages;
my @packagebodies;
my @usertypes;
my @userdeclids;
my @pslids;
my $duplicate= 0;
my @alsotypes= qw(record units protected protectedbody);

# Build entity, architecture, configuration and package lists
for my $lib (keys(%libraries)) {
  my $decls= $libraries{$lib};
  for (@$decls) {       # create these entries to avoid "undefined" warnings
    $_->{"children"} ||= [];
    $_->{"childtype"} ||= {};
    $_->{"allinstances"} ||= [];
    $_->{"allprocesses"} ||= [];
    $_->{"allpsldefs"} ||= [];
  }
  my @ents= grep $_->{"type"} eq "entity", @$decls;
  $duplicate += uniq_objs(\@ents);
  my @archs= grep $_->{"type"} eq "architecture", @$decls;
  $duplicate += uniq_objs(\@archs);
  my @confs= grep $_->{"type"} eq "configuration", @$decls;
  $duplicate += uniq_objs(\@confs);
  my @packs= grep $_->{"type"} eq "package", @$decls;
  $duplicate += uniq_objs(\@packs);
  my @pbods= grep $_->{"type"} eq "packagebody", @$decls;
  $duplicate += uniq_objs(\@pbods);
  for my $ac (@archs, @confs) {
    $ac->{"libname"} = $lib;
    next if $ac->{"objname"} =~ /\..*\./ || 
  ($ac->{"objname"} =~ /^([^.\s]+)\s*\./ && grep($_ eq $1, keys(%libraries)));
    $ac->{"objname"}= $lib . "." . $ac->{"objname"};
  }
  for (@ents, @packs, @pbods) {
    $_->{"libname"} = $lib;
    $_->{"fullname"}= $lib . "." . $_->{"name"};
  }
  add_selnames($lib, @ents, @archs, @confs, @packs, @pbods);
  push @entities, @ents;
  push @architectures, @archs;
  push @configurations, @confs;
  push @packages, @packs;
  push @packagebodies, @pbods;
  push @userdeclids, map lc($_->{"name"}),
        map( ($_, @{$_->{"childtype"}->{"function"} ||= []},
                  @{$_->{"childtype"}->{"procedure"} ||= []},
                  @{$_->{"childtype"}->{"component"} ||= []},
                  @{$_->{"allinstances"}} ),
            (@archs, @packs, @pbods) );
  push @userdeclids, map lc($_->{"name"}), grep $_->{"name"},
                    map @{$_->{"allprocesses"}}, @archs;
  push @userdeclids, map lc($_->{"name"}), (@ents, @confs);
  push @pslids, map lc($_->{"name"}), grep $_->{"name"},
                map @{$_->{"childtype"}->{"psl"} || []}, (@archs, @packs)
    if $config{"psl"};
  # Restore "type" hash entry of some type declarations that was set
  # incorrectly to facilitate parsing.
  for my $obj (@archs, @packs, @pbods) {
    for my $ty (@alsotypes) {
      next unless $obj->{"childtype"}->{$ty};
      map { $_->{"type"}= "type"; } @{$obj->{"childtype"}->{$ty}};
      push @{$obj->{"childtype"}->{"type"}}, @{$obj->{"childtype"}->{$ty}};
      undef $obj->{"childtype"}->{$ty};
    }
    push @usertypes, map lc($_->{"name"}), @{$obj->{"childtype"}->{"type"} ||= []};
    $obj->{"childtype"}->{"constant"} ||= [];
    $obj->{"childtype"}->{"funcproc"} ||= [];
  }
}

@SPANCLASS{@userdeclids}= ($SPDID) x @userdeclids;
@userdeclids= ();
@SPANCLASS{@usertypes}= ($SPTYID) x @usertypes;
@usertypes= ();
if( $config{"psl"} ) {
  @SPANCLASS{@PSLWORDS}= ($SPPSL) x @PSLWORDS;
  @SPANCLASS{@pslids}= ($SPPID) x @pslids;
  @pslids= ();
}

print STDERR "Warning: Duplicate declarations were discarded.\n" if $duplicate;


for my $ent (@entities)
{
  # Assign architectures to entities
  # Important - even if there are none, @{$ent->{"architectures"}} exists
  @{$ent->{"architectures"}}= 
            grep lc($_->{"objname"}) eq lc($ent->{"fullname"}), @architectures;
  map $_->{"entity"}= $ent, @{$ent->{"architectures"}};

  # Assign configurations to entities
  # Important - even if there are none, @{$ent->{"configurations"}} exists
  @{$ent->{"configurations"}}= 
          grep lc($_->{"objname"}) eq lc($ent->{"fullname"}), @configurations;
  map $_->{"entity"}= $ent, @{$ent->{"configurations"}};

  $ent->{"childtype"}->{"generic"} ||= [];
  $ent->{"childtype"}->{"port"} ||= [];
  # Assign @generic and @port docs to their declarations if legacy mode is on
  if( $config{"compat"} )
  {
    my @gens= @{$ent->{"childtype"}->{"generic"}};
    my @ports= @{$ent->{"childtype"}->{"port"}};
    if( @gens ) {
      # Copy generic documentation from the entity docs to its generic(s)
      for my $docname (keys(%{$ent->{"doc"}->{"generic"}})) {
        my ($subject)= grep $_->{"name"} eq $docname, @gens;
        if( !$subject ) {
          print STDERR "Spurious \@generic referring to non-existing generic ",
                        "$docname of entity ", $ent->{"name"}, " in file ",
                        $ent->{"filename"}, "\n";
          next;
        }
        unshift @{$subject->{"doc"}->{"description"}},
                    $ent->{"doc"}->{"generic"}->{$docname};
      }
    }
    if( @ports ) {
      # Copy port documentation from the entity docs to its port(s)
      for my $docname (keys(%{$ent->{"doc"}->{"port"}})) {
        my ($subject)= grep $_->{"name"} eq $docname, @ports;
        if( !$subject ) {
          print STDERR "Spurious \@port referring to non-existing port ",
                        "$docname of entity ", $ent->{"name"}, " in file ",
                        $ent->{"filename"}, "\n";
          next;
        }
        unshift @{$subject->{"doc"}->{"description"}},
                    $ent->{"doc"}->{"port"}->{$docname};
      }
    }
  }

  # Match attribute specifications to declarations and to targets
  match_attributes($ent);
  # HTML file name
  $ent->{"docfilename"}= $config{"prefix"} . $ent->{"fullname"} . ".html";
}



my @orphanedarchs;

for my $arch (@architectures) {
  # Build list of architectures we do not know the entity of
  push @orphanedarchs, $arch unless $arch->{"entity"};
  # Match attribute specifications to declarations and to targets
  match_attributes($arch);
  # HTML file name
  $arch->{"docfilename"}= $config{"prefix"} . $arch->{"objname"} . "-" .
                          $arch->{"name"} . ".html";
  for my $child (@{$arch->{"children"}}, @{$arch->{"allinstances"}}, @{$arch->{"allpsldefs"}}) {
    if( $labels{$child->{"type"}} && $child->{"name"} ) {
      $child->{"doclink"}= "../architectures/" . $arch->{"docfilename"} . "#"
                            . $labels{$child->{"type"}} . $child->{"name"};
    }
  }
}



my @orphanedconfs;

for my $conf (@configurations) {
  # Build list of configurations we do not know the entity of
  push @orphanedconfs, $conf unless $conf->{"entity"};
  # HTML file name
  $conf->{"docfilename"}= $config{"prefix"} . $conf->{"objname"} . "-" .
                          $conf->{"name"} . ".html";
  # Now assign objects to the use statements
  resolve_configuration($conf, \%libraries);
}


for my $pack (@packages)
{
  # Assign body to package
  for my $pbod (@packagebodies) {
    if( lc($pack->{"fullname"}) eq lc($pbod->{"fullname"}) ) {
      $pack->{"packagebody"}= $pbod;
      $pbod->{"package"}= $pack;
      last;
    }
  }
  # HTML file name
  $pack->{"docfilename"}= $config{"prefix"} . $pack->{"fullname"} . ".html";
  # Create full name and HTML link (where applicable) for declarative items in
  # package
  for my $child (@{$pack->{"children"}}, @{$pack->{"allpsldefs"}}) {
    $child->{"fullname"}= $pack->{"fullname"} . "." . $child->{"name"};
    if( $labels{$child->{"type"}} && $child->{"name"} ) {
      $child->{"doclink"}= "../packages/" . $pack->{"docfilename"} . "#" .
                                $labels{$child->{"type"}} . $child->{"name"};
    }
  }
  # Match attribute specifications to declarations and to targets
  match_attributes($pack);
  # Add component declarations to selected name table
  add_selnames($pack->{"fullname"}, @{$pack->{"childtype"}->{"component"}});
  # Add type declarations to selected name table
  add_selnames($pack->{"fullname"}, @{$pack->{"childtype"}->{"type"}});
  # Abuse selected name database for resolving PSL definition references
  add_selnames($pack->{"fullname"}, @{$pack->{"allpsldefs"}});
  # Find default bindings for components declared in the package
  map { $_->{"binding"}= find_selname($_->{"name"}, "entity",
                            $pack->{"fullname"}); }
            @{$pack->{"childtype"}->{"component"}};
}


my @orphanedpbodies;

for my $pbody (@packagebodies)
{
  # Build list of package bodies we didn't find a package for
  push @orphanedpbodies, $pbody unless $pbody->{"package"};
  # Match attribute specifications to declarations and to targets
  match_attributes($pbody);
  # HTML file name
  $pbody->{"docfilename"}= $config{"prefix"} . $pbody->{"fullname"} . ".html";
}

for my $opb (@orphanedpbodies)
{
  # Find default bindings for components declared in the package
  map { $_->{"binding"}= find_selname($_->{"name"}, "entity",
                            $opb->{"fullname"}); }
              @{$opb->{"childtype"}->{"component"}};
  # Create full name and HTML link (where applicable) for declarative items in
  # package body, since we do not have a package to match
  for my $child (@{$opb->{"children"}}) {
    $child->{"fullname"}= $opb->{"fullname"} . "." . $child->{"name"};
    if( $labels{$child->{"type"}} && $child->{"name"} ) {
      $child->{"doclink"}= "../packages/" . $opb->{"docfilename"} . "#" .
                                $labels{$child->{"type"}} . $child->{"name"};
    }
  }
  # Add component declarations to selected name table
  add_selnames($opb->{"fullname"}, @{$opb->{"childtype"}->{"component"}});
}


# Resolve package use clauses and link to the package.
for my $file (@vhdlfiles)
{
  my @fuses= grep $_->{"subtype"} eq "package", @{$file->{"uses"}};
  for my $useclause (@fuses) {
    next unless $useclause->{"name"} =~ /^([^.\s]+\s*\.\s*[^.\s]+)/;
    my $pack= $1;
    $useclause->{"package"}= find_selname($pack, "package", $file->{"libname"});
    next unless $useclause->{"package"};
    next if $useclause->{"name"} =~ /\ball$/i;
    $useclause->{"name"} =~ /^$pack\s*\.\s*([^.\s]+)/;
    ($useclause->{"object"})= find_children($useclause->{"package"}, "name", $1);
  }
}


# Resolve the user-defined types in all kinds of declarations
for my $obj (@architectures, @packages, @packagebodies) {
  my @typed= (@{$obj->{"childtype"}->{"constant"}},
              @{$obj->{"childtype"}->{"type"}},
              grep( $_->{"type"} eq "recordelement",
                    map( ( @{$_->{"children"} || []} ),
                         grep( $_->{"subtype"} eq "record",
                               @{$obj->{"childtype"}->{"type"}} ))) );
  resolve_types($obj, @typed);
}

for my $ent (@entities) {
  resolve_types($ent, @{$ent->{"childtype"}->{"port"}},
                      @{$ent->{"childtype"}->{"generic"}} );
}


# Now take care of locally specified bindings and generic maps of instances.
# Nested configurations will be tackled below.
for my $arch (@architectures, @orphanedarchs)
{
  my @topuses= reverse grep $_->{"subtype"} eq "package", @{$arch->{"uses"}};
  my @comps= @{$arch->{"childtype"}->{"component"}};
  # Assign default binding to component declarations
  map { $_->{"binding"}= find_selname($_->{"name"}, "entity",
                                      $arch->{"libname"}); } @comps;
  my @noncompinsts;
bindcompinst:
  for my $inst (@{$arch->{"allinstances"}}) {
    if( $inst->{"subtype"} ne "component" ) {
      push @noncompinsts, $inst;
      next;
    }
    # Match component instances to component declarations.
    # First try local component declarations:
    $inst->{"component"}=
              elem { lc($_->{"name"}) eq lc($inst->{"objname"}) } @comps;
    # If there is no matching local component declaration, we have to find
    # one in one of the packages.  If the bare name is unique, we choose that
    # component.
    $inst->{"component"}= find_selname($inst->{"objname"}, "component")
        unless $inst->{"component"};
    # If not, try selected names according to use clauses.
    if( defined($inst->{"component"}) && $inst->{"component"} == 0 ) {
      for my $useclause (@topuses) {
        my $name= merge_selname($useclause->{"name"}, $inst->{"objname"});
        next unless $name;
        $inst->{"component"}= find_selname($name, "component");
        last if $inst->{"component"};
      }
    }
    # This procedure has the illogical side effect that an ambiguous component
    # instantiation will be shown as unresolved if no matching use clause is
    # found.
    # Now we tackle binding indications in the blocks enclosing the
    # instantiation.
    for my $use (reverse @{$inst->{"uses"}}) {
      next if $use->{"subtype"} eq "package";
      my $for= $use->{"for"};
      next unless $for && lc($for->{"objtype"}) eq lc($inst->{"objname"}) &&
            ( lc($for->{"objnames"}->[0]) eq "all" ||
            elem { lc($_) eq lc($inst->{"name"}) } @{$for->{"objnames"}} );
      @{$inst->{"binddoc"}}= @{$for->{"doc"}->{"description"}}
          if $for->{"doc"}->{"description"};
      push @{$inst->{"binddoc"}}, @{$use->{"doc"}->{"description"}}
                  if $use->{"doc"}->{"description"};
# TODO: handle open bindings, also in docs
#     next bindcompinst if $use->{"subtype"} eq "open";
      $inst->{"bindname"}= $use->{"name"};
      $inst->{"binding"}= find_selname($use->{"name"},
                              $use->{"subtype"}, $arch->{"libname"});
      if( $inst->{"binding"} ) {
        $inst->{"bindname"}= $inst->{"binding"}->{"fullname"};
        if( $use->{"archname"} ) {
          $inst->{"archname"}= $use->{"archname"};
          $inst->{"bindarch"}= elem { $_->{"name"} eq $use->{"archname"} }
                                @{$inst->{"binding"}->{"architectures"}};
        }
        elsif( @{$inst->{"binding"}->{"architectures"}} ) {
          $inst->{"bindarch"}= $inst->{"binding"}->{"architectures"}->[0];
          $inst->{"archname"}= $inst->{"bindarch"}->{"name"};
        }
      }
      elsif( $use->{"archname"} ) {
        $inst->{"archname"}= $use->{"archname"};
        my @candidates= grep $_->{"name"} eq $inst->{"archname"} &&
                  $_->{"objname"} eq $inst->{"objname"}, @orphanedarchs;
        $inst->{"bindarch"}= elem( sub { $_->{"libname"} eq
                        $arch->{"libname"} }, @candidates) || $candidates[0];
      }
      $inst->{"bindgen"}= $use->{"genericmap"};
      next bindcompinst;
    }
    # Without an explicit binding specification we bind to the binding of the
    # matching component declaration, if any.
    if( $inst->{"component"} ) {
      $inst->{"binding"}= $inst->{"component"}->{"binding"};
    }
    # Aaargh... the component is not even declared.  Sloppy designer!  So we
    # resolve the instantiation by name.
    else {
      $inst->{"binding"}= find_selname($inst->{"objname"}, "entity",
                                          $arch->{"libname"});
    }
    if( $inst->{"binding"} && @{$inst->{"binding"}->{"architectures"}} ) {
      $inst->{"bindarch"}= $inst->{"binding"}->{"architectures"}->[0];
      $inst->{"archname"}= $inst->{"bindarch"}->{"name"};
    }
  }

  for my $inst (@noncompinsts) {
    $inst->{"binding"}= find_selname($inst->{"objname"}, $inst->{"subtype"});
    # If the name is abiguous, go looking in current library and use clauses.
    if( defined($inst->{"binding"}) && $inst->{"binding"} == 0 ) {
      $inst->{"binding"}= find_selname($inst->{"objname"}, $inst->{"subtype"},
                                        $arch->{"libname"});
      unless( $inst->{"binding"} ) {
# TODO: do entity and configuration declarations even exist in packages?
        for my $useclause (@topuses) {
          my $name= merge_selname($useclause->{"name"}, $inst->{"name"});
          next unless $name;
          $inst->{"binding"}= find_selname($name, $inst->{"subtype"});
          last if $inst->{"binding"};
        }
      }
    }
    next unless $inst->{"subtype"} eq "entity";
    if( $inst->{"binding"} ) {
      if( $inst->{"archname"} ) {
        $inst->{"bindarch"}= elem { $_->{"name"} eq $inst->{"archname"} }
                                @{$inst->{"binding"}->{"architectures"}};
      }
      elsif( @{$inst->{"binding"}->{"architectures"}} ) {
        $inst->{"bindarch"}= $inst->{"binding"}->{"architectures"}->[0];
        $inst->{"archname"}= $inst->{"bindarch"}->{"name"};
      }
    }
    elsif( $inst->{"archname"} ) {
      my @candidates= grep $_->{"name"} eq $inst->{"archname"} &&
                      $_->{"objname"} eq $inst->{"objname"}, @orphanedarchs;
      $inst->{"bindarch"}= elem(sub { $_->{"libname"} eq $arch->{"libname"} },
                                    @candidates) || $candidates[0];
    }
  }
}


# The following data structures represent the instantiation hierarchy.  They
# also form a tree structure like our hashes representing declarative items,
# but have a different format.  The hashes representing hierarchy nodes may
# have the entries "architecture", "entity", "configuration", "archname",
# "entname" and "confname".  (Other entries serve to indicate whether the
# node's object is itself instantiated somewhere, or to reference other nodes).
# The tree structure is formed by having a "children" entry referencing an
# array of hash references, as with the declarative items.
my @hierarchy;
my @ahier;

# Create instantiation hierarchy nodes representing architectures:
for my $arch (@architectures) {
  my $node= { "entname" => $arch->{"objname"}, "entity" => $arch->{"entity"},
              "architecture" => $arch, "archname" => $arch->{"name"} };
  push @hierarchy, $node;
  push @ahier, $node;
  $node->{"children"}= [];
  for my $inst (@{$arch->{"allinstances"}}) {
    if( $inst->{"subtype"} eq "configuration" || ($inst->{"binding"} &&
        $inst->{"binding"}->{"type"} eq "configuration") ) {
      my $new;
      if( $inst->{"binding"} ) {
        $new= { "configuration" => $inst->{"binding"},
                "confname" => ($inst->{"subtype"} eq "configuration"?
                          $inst->{"objname"} : $inst->{"binding"}->{"name"}) };
      }
      else {
        $new= { "confname" => $inst->{"objname"} };
      }
      push @{$node->{"children"}}, $new
        unless grep_hier($new, $node->{"children"});
    }
    else {
      my $new;
      if( $inst->{"binding"} ) {
        $new= { "entity" => $inst->{"binding"}, "entname"=> $inst->{"bindname"},
                "architecture" => $inst->{"bindarch"}, 
                "archname" => $inst->{"archname"} };
      }
      else {
        $new= { "entname" => $inst->{"bindname"} || $inst->{"objname"},
                "archname" => $inst->{"archname"} };
      }
      push @{$node->{"children"}}, $new
        unless grep_hier($new, $node->{"children"});
    }
  }
}

# Create instantiation hierarchy nodes representing configurations:
my @chier= map +{ "configuration" => $_, "confname" => $_->{"name"} },
                @configurations;
push @hierarchy, @chier;
# Build sub-hierarchy of configuration:
map { configure_hierarchy($_, \@ahier, \@chier); } @chier;

# Match architectures' instantiations to nodes:
for my $anode (@ahier) {
  for my $child (@{$anode->{"children"}}) {
    my ($cnode)= grep_hier($child, \@hierarchy);
    if( $cnode ) {
      $child= $cnode;
      $cnode->{"instantiated"}= 1;
    }
  }
}

@hierarchy= sort hier_sort_cmp @hierarchy;

# Create links from modules to hierchy nodes of architectures and
# configurations instantiating them
for my $node (@hierarchy) {
  for my $child (@{$node->{"children"}}) {
    # The following conditions for configuration nodes are meant to ensure that
    # configurations are only linked to when the instantiation binding was
    # determined by them.  (Caveat: these conditions will fail if the
    # configuration "skips" a binding for a level of the hierarchy, but is this
    # legal?)
    if( ! $node->{"configuration"} || ($child->{"configuration"} &&
                $node->{"configuration"} == $child->{"configuration"}) ) {
      push @{$child->{"entity"}->{"instantiated"}}, $node
          if $child->{"entity"};
      push @{$child->{"architecture"}->{"instantiated"}}, $node
          if $child->{"architecture"};
    }
    push @{$child->{"configuration"}->{"instantiated"}}, $node
        if $child->{"configuration"} && (!$node->{"configuration"}
            || $child->{"configuration"} != $node->{"configuration"});
  }
}


# Resolve PSL definition references
if( $config{"psl"} ) {
  for my $du (@architectures, @packages) {
    next unless $du->{"allpsldefs"};
    my @topuses= reverse grep $_->{"subtype"} eq "package", @{$du->{"uses"}};
    # Local PSL definitions:
    my @psldefs= grep $_->{"subtype"} =~ /^(?:property|sequence|endpoint)$/i,
                      @{$du->{"allpsldefs"}};
    my %psldefdict= map { $_->{"name"} => $_; } @psldefs;
    for my $psl (@{$du->{"allpsldefs"}}) {
      my $code= $psl->{"value"} || $psl->{"property"} || $psl->{"sequence"};
      my @ids= $code =~ /$ID/g;
      for my $id (@ids) {
        my $ref= $psldefdict{$id};
        unless( $ref ) {
          for my $use (@topuses) {
            my $selname= merge_selname($use->{"name"}, $id);
            next unless $selname;
            $ref= find_selname($selname, "psl");
            last if $ref;
          }
        }
        push @{$psl->{"defrefs"}}, $ref if $ref;
      }
    }
  }
}

benchmark("to process") if $config{"benchmark"};


# Now generate documentation

print "Generating docs...\n" unless $config{"quiet"};
benchmark() if $config{"benchmark"};

# Find targets of cross references, if any
for my $obj (@entities, @architectures, @configurations, @packages,
                @packagebodies) {
  next unless $obj->{"doc"}->{"see"};
  resolve_seealso($obj->{"doc"}->{"see"}, \%libraries,
                $obj->{"file"}->{"libname"});
}

entitylisthtml(\@entities, \@orphanedarchs, \@orphanedconfs, scalar(@configurations));
packagelisthtml(\@packages, \@orphanedpbodies);
instantiationhtml(\@hierarchy, scalar(@chier));
hierarchyhtml(\@hierarchy, scalar(@chier));
sourcelisthtml(\@vhdlfiles);

for my $ent (@entities) {
  entityhtml($ent);
}

for my $conf (@configurations) {
  configurationhtml($conf);
}

for my $arch (@architectures) {
  architecturehtml($arch);
}

for my $pack (@packages, @orphanedpbodies) {
  packagehtml($pack);
}

if( $config{"javasyntax"} ) {
  makemarkupjs();
}
for my $file (@vhdlfiles) {
  if( $config{"javasyntax"} ) {
    sourcehtml_js($file);
  }
  else {
    sourcehtml($file);
  }
}

benchmark("to generate HTML") if $config{"benchmark"};

exit 0;

# vim: set ts=2 sw=2 et:
