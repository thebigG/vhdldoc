#!/usr/bin/perl

#    This is VHDocL, a VHDL documentation utility.
#    Copyright (c) 2007-10 Volker Schatz (vhdocl at volkerschatz dot com).
#
#    VHDocL is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 3 of the License, or
#    (at your option) any later version.
#
#    VHDocL is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with VHDocL; if not, see <http://www.gnu.org/licenses/>.


use strict;
use warnings;
use File::Spec;
use File::Path;
use File::Copy;
use Digest::MD5;
use Cwd 'abs_path';
use Time::HiRes;

my $version= "0.2.0";

my %config= ( "outputdir" => "doc", "prefix" => "", "curlib" => "work",
  "compat" => 0, "cwd" => "", 
  "parsedebug" => 0, "quiet" => 0, "cellpadding" => 3, "indentation" => 50, 
  "stylesheet" => "", "leftlogo" => "", "rightlogo" => "", "toplink" => "",
  "title" => "" );

my %requisites= ( "treestyle" => "treeview.css", "treejava" => "treeview.js",
    "nodeimg" => "node.png", "subtrimg" => "subtree.png",
    "leafimg" => "leaf.png",
    "synstyle1" => "shCore.css", "synstyle2" => "shThemeDefault.css",
    "synimg1" => "wrapping.png", "synimg2" => "help.png",
    "synimg3" => "printer.png", "synimg4" => "page_white_code.png",
    "synjava1" => "shCore.js", "synjava2" => "shBrushVhdl.js" );

my $cp;
my $iw;


##############################################################################
##############################################################################
####                    Auxiliary functions
##############################################################################
##############################################################################

# Return the first element of a list which matches a criterion.
# -> Anonymous test subroutine operating on $_ and returning a true value for
#    matches
#    List to search
# <- The first matching element, or undef
sub elem(&@)
{
  my $test= shift @_;
  for (@_) {
    return $_ if &$test;
  }
  return undef;
}


# Generate a regex which matches one of a list of words.  Wourd boundary
# matches are put before and after the word match, and the match is made case
# insensitive.
# -> List of words (not an array ref, but the actual list)
# <- Regex
sub wordregex
{
  return "(?:\\b(?i:" . join("|", @_) . ")\\b)";
}


# An auxiliary function for obtaining the canonical form of a file name.
# Required to work around Cwd::abs_path()'s intolerance towards non-existing
# files and directories.
# -> File name including path
# <- File name made canonical with Cwd::abs_path() if possible, with
#    File::Spec->canonpath() otherwise.  The latter does not consult the file
#    system and therefore cannot resolve symbolic links.
sub mycanonpath
{
  my ($file)= @_;
  my $canonfile= eval { Cwd::abs_path($file) };
  return $canonfile unless $@ || !defined($canonfile);
  return File::Spec->canonpath($file);
}


# Transforms a file name which is relative to a different directory to one
# which is relative to the current working directory.  Absolute file names and
# URLs are left unchanged
# -> File name
#    Directory path
# <- Transformed file name
sub fixpath
{
  my ($file, $dir)= @_;

  if( $file =~ /^\w+:\/\//i || File::Spec->file_name_is_absolute($file) ) {
    return $file;
  }
  else {
    $file= File::Spec->rel2abs($file, $dir);
    $file= mycanonpath($file);          # get rid of interior /../ if possible
    $file= File::Spec->abs2rel($file, $config{"cwd"});
    $file ||= ".";              # some versions of abs2rel return "" for "."
    return $file;
  }
}


{
my $pathsep;

# Return a hyperlink to a source file from a top-level HTML file.
# -> File name (absolute or relative to current directory)
# <- Hyperlink to file relative to output directory
sub sourcelink
{
  my ($filename)= @_;

  # We convert non-"/" path separators to slashes.  This will work for Windoze,
  # for other systems we would probably have to use URI::file.
  $pathsep ||= File::Spec->catdir("","") || "/";
  if( File::Spec->file_name_is_absolute($filename) ) {
    $filename =~ s!$pathsep!/!g unless $pathsep eq "/";
    return "file://$filename";
  }
  else {
    $filename= File::Spec->abs2rel($filename, $config{"absoutputdir"});
    $filename =~ s!$pathsep!/!g unless $pathsep eq "/";
    return $filename;
  }
}

}


# Return the file extension of a file name (i.e. the portion after the last
# ".").
# -> File name
# <- Extension (without the ".")
sub fileext
{
  my ($fname)= @_;

  (undef, undef, $fname)= File::Spec->splitpath($fname);
  $fname =~ /\.([^\.]*)$/;
  return $1 || "";
}


# Compare two code snippets.  White space is compressed to one space character
# between words and completely removed elsewhere.  The contents of strings are
# not treated specially, so if two snippets differ only by the amount of white
# space in strings, they will erroneously compare as equal.
# -> Strings to compare
# <- 0 if equivalent
sub codecmp
{
  my ($a, $b)= @_;

  return 0 if $a eq $b;
  $a =~ s/\s+/ /g;
  $a =~ s/^ //;
  $a =~ s/ $//;
  $a =~ s/ (?=\W)//g;
  $a =~ s/(?<=\W) //g;
  $b =~ s/\s+/ /g;
  $b =~ s/^ //;
  $b =~ s/ $//;
  $b =~ s/ (?=\W)//g;
  $b =~ s/(?<=\W) //g;
  return $a cmp $b;
}


# Copy a file.  Uses File::Copy->copy() but prevents croaking.
# -> Source file name
#    Destination file name or target directory
# <- 1 if successful, 0 on error
sub copyfile
{
  my ($from, $to)= @_;
  my $status;

  $status= eval { File::Copy::copy($from, $to); };
  return !$status || $@? 0 : 1;
}


# Print file error messages at most three times, and print a note when
# suppressing further error messages.
# -> Error message
#    Reference to scalar for counting errors (incremented up to 4)
sub limitfileerr
{
  my ($msg, $errcount)= @_;
  my $limit= $config{"quiet"}? 1 : 3;

  return if $$errcount > $limit;
  if( $$errcount < $limit ) {
    print STDERR "$msg - $!\n";
  }
  else {
    print STDERR "(additional errors suppressed)\n";
  }
  ++$$errcount;
}


# Another auxiliary function which exits the program with return value 1 after
# optionally printing a message to STDERR.  Akin to die but without the silly
# line number output which users don't have any use for.
# -> Error message
sub croak
{
  my ($msg)= @_;

  print STDERR "$msg\n" if defined($msg) && "$msg";
  exit 1;
}


{
my $starttime;

sub benchmark
{
  my ($msg, $lines)= @_;

  if( !$msg ) {
    $starttime= [ Time::HiRes::gettimeofday() ];
  }
  else {
    my $secs= Time::HiRes::tv_interval($starttime);
    my $perline= "";
    $perline= ", " . sprintf("%g", $secs / $lines) . " s per line"
        if $lines;
    $secs= sprintf "%g", $secs;
    print "Took $secs s $msg$perline.\n";
  }
}

}


##############################################################################
##############################################################################
####                    Command line parsing functions
##############################################################################
##############################################################################

my @options= (
[ "h", "help", "&", \&printhelp ],
[ "", "version", "&", \&printversion ],
[ "o", "outputdir", "/", "outputdir" ],
[ "f", "configfile", "<", 0 ],
[ "p", "prefix", "w", "prefix" ],
[ "l", "library", "w", "curlib" ],
[ "", "parsedebug", "?", "parsedebug" ],
[ "", "benchmark", "?", "benchmark" ],
[ "q", "quiet", "?", "quiet" ],
[ "c", "cellpadding", "#", "cellpadding" ],
[ "i", "indentation", "#", "indentation" ],
[ "m", "compatibility", "?", "compat" ],
[ "", "stylesheet", "/", "stylesheet" ],
[ "", "leftlogo", "/", "leftlogo" ],
[ "", "rightlogo", "/", "rightlogo" ],
[ "", "title", "*", "title" ],
[ "", "toplink", "/", "toplink" ] );


# Parse command line argument arrray.
# -> Reference to array of command-line arguments.
# <- Reference to array of source files.  Options values are written to %config.
sub parseargv
{
  my ($argv)= @_;
  my $files= [];
  my $status;

  # Don't use File::Spec->curdir(), it takes 1 second (!)
  $config{"cwd"}= Cwd->cwd();
  while( @$argv ) {
    $status= parseopt($argv, $files);
    next if $status;
    if( $$argv[0] eq "-" ) {
      shift @$argv;
      while( <STDIN> ) {
        my @inargs= split;
        while( @inargs && parseopt(\@inargs, $files) ) {}
      }
    }
    else {
      print STDERR "The option ", $$argv[0], " requires an argument.  ",
                        "Aborting.\n";
      croak;
    }
  }
  if( $#$files == 0 && $files->[0]->{"name"} =~ /\.vhdocl$/i ) {
    my $cfile= $files->[0]->{"name"};
    $files= [];
    parsecfgfile($cfile, $files, $config{"cwd"});
  }
  return $files;
}


# Parse one option or input file from an array.  The parsed option (and
# possibly its argument) is removed from the array.  A parsed option is entered
# into %config, an input file name generates a new entry in the file list.
# Hashes representing files have the entries "type" (= "file"), "name" (the
# file name) and "libname" (the library name).
# -> Reference to array containing options, their arguments and input files
#    Reference to array containing references to hashes representing input
#    files
# <- 1 if something could be parsed, 0 if an argument is missing or the option
#    was "-" (read from stdin).
sub parseopt
{
  my ($arglist, $filelist)= @_;
  my $nextarg= shift @$arglist;
  my $opt;
  my $value;

  if( $nextarg =~ /^--/ ) {
    $nextarg =~ /^--([^=]*)(?:=(.*))?$/;
    my $optname= lc($1);
    my $onoff= 1;
    $value= $2;
    croak "Unknown long option $nextarg.  Aborting."
        unless $optname =~ /^\w+$/;
    my @opts= grep($_->[1] =~ /^$optname/i, @options);
    if( !@opts && $optname =~ s/^no(.)/$1/i ) {
      @opts= grep($_->[2] eq "?" && $_->[1] =~ /^$optname/i, @options);
      $onoff= 0;
    }
    croak "Unknown long option $nextarg.  Aborting."
        unless @opts;
    if( @opts > 1 ) {
      print STDERR "Ambiguous long option $nextarg.  (Could be --",
                join(", --", map($_->[1], @opts[0..$#opts-1])), " or --",
                $opts[$#opts]->[1], ".)  Aborting.\n";
      croak;
    }
    if( $opts[0]->[2] eq "?" ) {
      $config{$opts[0]->[3]}= $onoff;
      return 1;
    }
    elsif( $opts[0]->[2] eq "&" ) {
      &{$opts[0]->[3]}();
      return 1;
    }
    $opt= $opts[0];
  }
  elsif( $nextarg =~ /^[+-]\S/ ) {
    $nextarg =~ /^([+-])(\S)(.*)$/;
    my $onoff= $1 eq "-";
    my $firstchar= $2;
    my $remainder= $3;
    my ($thisopt)= grep($_->[0] eq $firstchar, @options);
    croak "Unknown short option -$firstchar.  Aborting."
      unless $thisopt;
    if( $thisopt->[2] eq "?" || $thisopt->[2] eq "&" ) {
      if( $thisopt->[2] eq "?" ) {
        $config{$thisopt->[3]}= $onoff;
      }
      elsif( $thisopt->[2] eq "&" ) {
        &{$thisopt->[3]}();
      }
      my @optchars= split(//, $remainder);
      for my $optchar (@optchars) {
        ($thisopt)= grep($_->[0] eq $optchar, @options);
        croak "Unknown short option -$optchar.  Aborting."
          unless $thisopt;
        if( $thisopt->[2] eq "?" ) {
          $config{$thisopt->[3]}= $onoff;
        }
        elsif( $thisopt->[2] eq "&" ) {
          &{$thisopt->[3]}();
        }
        else {
          print STDERR "Cannot bundle short options with arguments (-",
                       $thisopt->[0], ").  Aborting.\n";
          croak;
        }
      }
      return 1;
    }
    elsif( $remainder =~ /^=/ ) {
      $value= substr($remainder, 1);
    }
    elsif( length($remainder) ) {
      print STDERR "Cannot bundle short options with arguments (-",
                   $thisopt->[0], ").  Aborting.\n";
      croak;
    }
    else {
      $value= undef;
    }
    # $value= $remainder if $remainder; # value without space
    $opt= $thisopt;
  }
  elsif( $nextarg eq "-" ) {
    unshift @$arglist, $nextarg;
    return 0;
  }
  elsif( -d $nextarg ) {
    $nextarg= File::Spec->catfile($nextarg, "*.[vV][hH][dD]{,[lL]}");
    my @vhdl= grep -f, glob($nextarg);
    push @$filelist, map +{ "type", "file", "name", $_,
                            "libname", $config{"curlib"} }, @vhdl;
    return 1;
  }
  elsif( $nextarg !~ /\.vhdl?$/i && !-e $nextarg ) {
    my ($fname)= grep -f, glob("$nextarg.[vV][hH][dD]{,[lL]}");
    push @$filelist, { "type", "file", "name", $fname || $nextarg,
                        "libname", $config{"curlib"} };
    return 1;
  }
  else {
    push @$filelist, { "type", "file", "name", $nextarg,
                        "libname", $config{"curlib"} };
    return 1;
  }
  # Now take care of options with arguments.  Their value may already have been
  # assigned to $value if it was in the same command line argument as the
  # option.
  unless( defined($value) ) {
    $value= shift @$arglist;
    unless( defined($value) ) {
      unshift @$arglist, $nextarg;
      return 0;
    }
  }
  if( $opt->[2] eq "w" ) {
    unless( $value =~ /^\w*$/ ) {
      print STDERR "The argument of", ($opt->[0]? " -".$opt->[0]." /": ""),
                   " --", $opt->[1], " may only contain letters, digits and ",
                   "the underscore.  Aborting.\n";
      croak;
    }
  }
  elsif( $opt->[2] eq "#" ) {
    unless( $value =~ /^\d+$/ ) {
      print STDERR "The argument of", ($opt->[0]? " -".$opt->[0]." /": ""),
                   " --", $opt->[1], " must be numerical.  Aborting.\n";
      croak;
    }
  }
  if( $opt->[2] eq "<" ) {
    parsecfgfile($value, $filelist);
  }
  else {
    $config{$opt->[3]}= $value;
  }
  return 1;
}


# Parse options and input files from a config file
# <- Configuration file name
#    Reference to array containing references to hashes representing input
#    files
#    Directory from which the config file was included
#    (optional) Reference to array of config file names from which this one was
#    included, to avoid include loops
sub parsecfgfile
{
  my ($fname, $filelist, $track)= @_;
  my ($vol, $dir)= File::Spec->splitpath($fname);
  my $basedir= File::Spec->catpath($vol, $dir, "") || ".";
  $basedir= mycanonpath($basedir);
  my $line;

  $track ||= [];
  open(CFG, "<$fname") or croak "Could not open config file $fname - $!";
  while( <CFG> )
  {
    s/#.*$//;
    chomp;
    next unless $_;
    $line .= " " . $_;
    next if $line =~ s/\s*\\$//;
    $line =~ /^\s*([^\s=]+)\s*(=)?\s*([^=]*?)\s*$/
        or croak "Cannot understand line $. in $fname: $line";
    my $optname= $1;
    my $value= $3;
    my $onoff= 1;
    croak "Unknown option $optname in $fname, line $..  Aborting."
        unless $optname =~ /^\w+$/;
    $line= "";
    $value =~ s/^\s+//;
    $value =~ s/\s+$//;
    if( $optname eq "input" ) {
      my @files= split /\s+/, $value;
      for my $file (@files) {
        $file= fixpath($file, $basedir);
        my @vhdl;
        if( $file =~ /\?|\*|\[|\]|\{|\}|\~/ ) {
          @vhdl= grep -f, glob($file);
          push @$filelist, map +{ "type", "file", "name", $_,
                                  "libname", $config{"curlib"} }, @vhdl;
        }
        elsif( -d $file ) {
          @vhdl= grep -f, glob("$file/*.[vV][hH][dD]{,[lL]}");
          push @$filelist, map +{ "type", "file", "name", $_,
                                  "libname", $config{"curlib"} }, @vhdl;
        }
        elsif( $file !~ /\.vhdl?$/i && !-e $file ) {
          my ($fname)= grep -f, glob("$file.[vV][hH][dD]{,[lL]}");
          push @$filelist, { "type", "file", "name", $fname || $file,
                              "libname", $config{"curlib"} };
        }
        else {
          push @$filelist, { "type", "file", "name", $file,
                              "libname", $config{"curlib"} };
        }
      }
      next;
    }
    my @opts= grep($_->[1] =~ /^$optname/i, @options);
    if( !@opts && $optname =~ s/^no(.)/$1/i ) {
      @opts= grep($_->[2] eq "?" && $_->[1] =~ /^$optname/i, @options);
      $onoff= 0;
    }
    croak "Unknown option $optname in $fname, line $..  Aborting."
        unless @opts;
    if( @opts > 1 ) {
      print STDERR "Ambiguous option $optname in $fname, line $..  (Could be ",
                   join(", ", map($_->[1], @opts[0..$#opts-1])), " or ",
                   $opts[$#opts]->[1], ".)  Aborting.\n";
      croak;
    }
    if( $opts[0]->[2] eq "&" ) {
      print STDERR "Ignoring option $optname in $fname.\n";
    }
    elsif( $optname eq "configfile" ) {
      push @$track, $fname;
      $value= fixpath($value, $basedir);
      if( grep($_ eq $value, @$track) ) {
        print STDERR "Ignoring recursive include in $fname, line $..\n";
      }
      else {
        parsecfgfile($value, $filelist, $track);
      }
      pop @$track;
    }
    elsif( $opts[0]->[2] eq "?" ) {
      if( $value ) {
        if( !$onoff ) {
          croak "Cannot give value for negated option $optname in $fname, line $..  Aborting.";
        }
        elsif( $value =~ /^(?:1|yes|on|true)$/i ) {
          $config{$opts[0]->[3]}= 1;
        }
        elsif( $value =~ /^(?:0|no|off|false)$/i ) {
          $config{$opts[0]->[3]}= 0;
        }
        else {
          croak "Illegal value for boolean option $optname in $fname, line $..  Aborting.";
        }
      }
      else {
        $config{$opts[0]->[3]}= $onoff;
      }
    }
    else {
      if( $opts[0]->[2] eq "w" ) {
        unless( $value =~ /^\w*$/ ) {
          print STDERR "The argument of option $optname may only contain ",
                       "letters, digits and the underscore in $fname, line ",
                       "$..  Aborting.\n";
          croak;
        }
      }
      elsif( $opts[0]->[2] eq "#" ) {
        unless( $value =~ /^\d+$/ ) {
          print STDERR "The argument of option $optname must be numerical ",
                       "in $fname, line $..  Aborting.\n";
          croak;
        }
      }
      elsif( $opts[0]->[2] eq "/" ) {
        $value= fixpath($value, $basedir);
      }
      $config{$opts[0]->[3]}= $value;
    }
  }
  close CFG;
}


# Print version
sub printversion
{
  print "This is VHDocL version $version.\n";
  exit;
}


# Print brief usage message
sub printhelp
{
  print <<EOF;
VHDocL is a VHDL documentation and structure examination utility.
Usage:
    vhdocl [options] input files... [ [-l <library>] input files...]
VHDocL generates HTML documentation for hardware designs written in VHDL.  It
outputs an HTML page for each entity, architecture, configuration and package
and a list of entities and of packages and the design's instantiation
hierarchy.
The most important command-line options are:
    -o, --outputdir     Output directory (default: "doc")
    -p, --prefix        Prefix for all HTML files
    -l, --library       Library to which the following source files belong
    -c, --cellpadding   Cell padding in pixels for HTML tables
    -i, --indentation   Indentation in pixels for HTML tables
Long options may be abbreviated.

VHDocL's manual is contained in the file vhdocl.pod in its distribution package
in POD format and can be extracted using pod2man, pod2html and similar programs
which come with Perl.  For instance, a manual page can be generated and viewed
as follows:
  pod2man vhdocl.pod > vhdocl.1
  man ./vhdocl.1
It can also be read online at http://www.volkerschatz.com/hardware/vhdocl.html.

In order to install VHDocL on your system, obtain the distribution package from
http://www.volkerschatz.com/hardware/vhdocl.html and execute the perl script
install-vhdocl.pl.  Run it with the option -h first to view available options.
You will need administrator privileges to install vhdocl for all users.  On
non-UNIX systems, a target directory has to be provided.
EOF
  exit;
}


##############################################################################
##############################################################################
####                    VHDL parsing functions
##############################################################################
##############################################################################

# Parse documentation (--*) comment.  Escape HTML's reserved characters but
# leave some tags untouched which are allowed in descriptions.
# -> String containing documentation with --* already removed
# <- Reference to hash containing extracted documentation items
sub parsedoccom
{
  my %doc;
  my $dcom= shift;
  my $tags= qr/b|i|tt|u|big|small|sub|sup|em|strong|code|var|ul|ol|li|
                br|center|pre|table|tr|td|th|(?:a|span|img)(?:\s+[^>]+)?/ix;
  my $svnkeys= qr/(?:LastChanged)?(?:Date|Revision)|Rev|Id|Author|(?:Head)?URL/;

  $dcom =~ s/<(\/?$tags)>/\x01$1\x02/go;
  $dcom =~ s/&/&amp;/g;
  $dcom =~ s/</&lt;/g;
  $dcom =~ s/>/&gt;/g;
  $dcom =~ s/"/&quot;/g;
  $dcom =~ tr/\x01\x02/<>/;
  my @doclines= split /\s+(?=\@)|\n[ \t\r]*\n/, $dcom;
  chomp(@doclines);
  # Remove supported Subversion keywords:
  map { $_ =~ s/\$$svnkeys:\s*(.*?)\s*\$/$1/go; } @doclines;
  for my $line ( @doclines )
  {
    next if $line =~ /^$/;
    if( $line =~ /^\@/ ) {
      if( $line =~ /^\@(short|brief|date|version|id)\s+(.*)$/is ) {
        $doc{$1}= $2;
      }
      elsif( $line =~ /^\@author\s+(.*)$/is ) {
        $doc{"author"} .= "$1, ";
      }
      elsif( $line =~ /^\@see\s+(.*)$/is ) {
        push @{$doc{"see"}}, map( [ $_ ], split(/\s*,\s*/, $1));
      }
      elsif( $line =~ /^\@(deprecated|internal|simulation|synthesis|testbench)\b/is ) {
        $doc{$1}= 1;
      }
      elsif( $config{"compat"} && $line =~ /^\@li\s/is ) {
        push @{$doc{"description"}}, $line;
      }
      elsif( $config{"compat"} && $line =~ /^\@(generic|port)\s+(\S*)\s+(.*)$/is ) {
        $doc{$1}->{$2}= $3;
      }
      elsif( !$config{"quiet"} ) {
        $line =~ /^(\@\w+)\b/;
        print STDERR "Unknown markup code $1 on or before line $..\n";
      }
    }
    else {
      push @{$doc{"description"}}, $line;
    }
  }
  $doc{"id"} =~ s/\$Id:\s*(.*?)\s*\$/$1/ if $doc{"id"};
  return \%doc;
}


# VHDL identifier:
my $ID= qr/\b[a-zA-Z](?:\w*[a-zA-Z0-9])?\b/;
# List of identifiers for variable, signal and other declarations:
my $IDLIST= qr/$ID(?:\s*,\s*$ID)*/o;
# Operator name for overloading etc.:
my $OP= qr!"(?:\W|[/<>]=|[a-zA-Z]+)"!;
# Selected name for use clause and others:
my $SID= qr/(?:$ID\s*\.\s*)*(?:$ID|$OP|'.')/o;
# Selected name list:
my $SIDLIST= qr/$SID(?:\s*,\s*$SID)*/o;
# Block type for parsing "end...":
my $BLK= qr/(?:entity|architecture|configuration|package|packagebody|process|postponedprocess|if|loop|block|units|record)/;
# Item in an attribute specification:
my $AI= qr/(?:$ID|$OP|'.')(?:\s*\[[^]]*\])?/o;
# List of attribute spec items:
my $AILIST= qr/$AI(?:\s*,\s*$AI)*/o;

# Quoted strings and chars (or bit vectors and bits) have to be treated
# separately:
my $QUOT= qr/"[^"\n]*"|'[^'\n]'/;
# Quoted strings or chars or single apostrophe:
my $QUOTA= qr/"[^"\n]*"|'[^'\n]'|'/;
# A non-empty expression without a semicolon:
my $STUFF= qr/(?:$QUOT|[^;"])[^;"']*(?:$QUOTA[^;"']*)*/o;
# Same, but not greedy:
my $MSTUFF= qr/(?:$QUOT|[^;"])[^;"']*?(?:$QUOTA[^;"']*?)*?/o;
# Possibly empty expression containing anything at all, with matched quotes (if
# any):
my $ANY= qr/[^"']*(?:$QUOTA[^"']*)*/o;
# Same, but not greedy:
my $MANY= qr/[^"']*?(?:$QUOTA[^"']*?)*?/o;
# Possibly nested parenthetical expression:
my $PAREN;
# This needs Perl 5.10:
eval { $PAREN= qr/(\([^()"']*(?:(?:(?-1)|$QUOTA)[^()"']*)*\))/o; };
if( $@ ) {      # fallback for older Perls
  use re 'eval';
  $PAREN= qr/\([^()"']*(?:(?:(??{$PAREN})|$QUOTA)[^()"']*)*\)/o;
  print "" if "foo" =~ /$PAREN/;
};
# Code containing no parentheses outside quotes: (currently unused)
# my $NOPAREN= qr/[^()"']*(?:$QUOTA[^()"']*)*/o;
# Entry in a comma-separated list, accounting for quotes and parentheses:
my $COMMAENTRY= qr/[^,()"']*(?:(?:$PAREN|$QUOTA)[^,()"']*)*/o;
# Same for semicolon-separated list:
my $SEMIENTRY= qr/[^;()"']*(?:(?:$PAREN|$QUOTA)[^;()"']*)*/o;


{   # Start of scope of parsing variables

my $vhandle;
my $vline;
my ($doccomment, $aheaddoccom, $keepdoccom, $keepaheaddoc);


# Read and preprocess next line from VHDL file.
# -> Flag indicating readahead
# <- 0 on end of file, otherwise 1
sub getnextline
{
  my ($ahead)= @_;

  my $new= <$vhandle>;
  return 0 unless defined($new);
  preprocessline($new, $ahead);
  return 1;
}


# Preprocess next line from VHDL file.
# -> New (single) line of VHDL code
#    Flag indicating readahead
sub preprocessline
{
  my ($new, $ahead)= @_;

  $new =~ s/^\s*//;
  $new =~ s/^($MANY)--(.*)$/$1/o;
  if( $2 && $2 =~ /^([+*])([^+*].*|)$/ ) {
    ($ahead ? $keepaheaddoc : $keepdoccom) = $1 eq "+" unless $config{"compat"};
    ($ahead ? $aheaddoccom : $doccomment) .= $2 . "\n";
  }
  chomp $new;
  $vline .= " " . $new;
  # Simplifications to facilitate parsing
  $vline =~ s/\bpackage\s+body\b/packagebody/ig;
  $vline =~ s/\bprotected\s+body\b/protectedbody/ig;
  $vline =~ s/\bpostponed\s+process\b/postponedprocess/ig;
}


# Skip until first semicolon outside string literals and comments.
# (<->) $vline: Remainder of current code line
sub skipstatement
{
  my $comment;

  while( defined($vline) ) {
    if( $vline =~ /;/ ) {
      chomp $vline;
      $vline =~ s/^($MANY)(--.*)$/$1/;
      $comment= $2;
      if( $vline =~ s/^(?:|$STUFF);// ) {
        $vline .= $comment if $vline !~ /^\s*$/ && defined($comment);
        return;
      }
    }
    $vline= <$vhandle>;
  }
}


# Skip part of a statement until a given regex matches outside quotes.  If no
# match is found, the whole statement until `;' is skipped unless EOF is
# encountered.
# -> Regex indicating when to stop skipping
# <- 1 if match was found before `;' ending the statement or EOF, 0 otherwise
# (<-) $vline contains the read text
sub skipuntil
{
  my ($until)= @_;

  while( 13 ) {
    $vline =~ s/^$MSTUFF(?:$until|(;))// and return !defined($1);
    getnextline(0) or return 0;
  }
}


# Read part of a statement until a given regex matches outside quotes.
# -> Regex indicating when to stop reading
# <- 1 if match was found before `;' ending the statement, 0 otherwise, undef
#    on EOF
# (<-) $vline contains the read text
sub readuntil
{
  my ($until)= @_;

  while( 13 ) {
    $vline =~ /^(?:$MSTUFF)?(?:$until|(;))/ and return !defined($1);
    getnextline(0) or return undef;
  }
}


# Read generic or port declaration list.  Nested parentheses are tracked.
# Documentation comments are assigned to individual ports or generics.  Before
# returning, the doc comment variables are cleared to avoid reuse at the end of
# the main loop in parsefile().
# -> String to write to the "type" entry of the resulting hashes, "port" or
#    "generic"
# <- List of hashes representing ports or generics
sub readportlist
{
  my ($type)= @_;
  my ($port, @ports);
  my $lastdoccom;

  while( 13 ) {
    $port= "";
    while( 13 ) {
      $vline =~ s/^($SEMIENTRY)//o or print "no match: $vline\n";
      $port .= $1;
      last if $vline =~ /^[;)]/;
      my $new= <$vhandle>;
      return unless defined($new);
      $new =~ s/^\s*//;
      $new =~ s/^($MANY)--(.*)$/$1/o;
      if( $2 && $2 =~ /^([+*])([^+*].*|)$/ ) {
        $keepdoccom= $1 eq "+" unless $config{"compat"};
        $doccomment .= $2 . "\n";
      }
      chomp $new;
      $vline .= " " . $new;
    }
    $vline =~ s/^([;)])//;
    my $delimiter= $1;
    if( $port =~ /^\s*($IDLIST)\s*:\s*(?:(in|out|inout)\b)?\s*
                                  ($MSTUFF)(?:\s*:=\s*($STUFF))?\s*$/iox ) {
      $doccomment ||= $lastdoccom if $keepdoccom;
      my $doc= $doccomment? parsedoccom($doccomment) : undef;
      my @newports= map +{ "type", $type, "name", $_, "doc", $doc,
                          "direction", $type eq "port" ? lc($2 || "in") : "",
                          "subtype", $3, "value", $4 }, split(/\s*,\s*/, $1);
      push @ports, @newports;
      if( $config{"parsedebug"} ) {
        print "$.: found $type";
        print "s" if $#newports;
        print " ", join(", ", map($_->{"name"}, @newports)), "\n";
      }
    }
    last if $delimiter eq ")";
    $lastdoccom= $doccomment if $keepdoccom;
    $doccomment= "";
  }
  $doccomment= "";
  $keepdoccom= 0;
  return @ports;
}


# Read function or procedure declaration argument list.  Nested parentheses are
# tracked.
# -> optional: Reference to array for hashes representing arguments
# <- String containing complete argument list
sub readarglist
{
  my ($list)= @_;
  my ($arg, $allargs);

  $allargs= "";
  while( 13 ) {
    $arg= "";
    while( 13 ) {
      $vline =~ s/^($SEMIENTRY)//o;
      $arg .= $1;
      last if $vline =~ /^[;)]/;
      my $new= <$vhandle>;
      return undef unless defined($new);
      chomp $new;
      $new =~ s/^($MANY)--.*$/$1/;
      $vline .= " " . $new;
    }
    $allargs .= $arg;
    $vline =~ s/^([;)])//;
    my $delimiter= $1;
    if( $list ) {
      $arg =~ /^\s*(?:(constant|signal|variable|file)\s+)?($IDLIST)\s*:\s*
                  (?:(in|out|inout|buffer|linkage)\s+)?($MSTUFF)
                  (?:\s*:=\s*(\S.*?\S))?\s*$/iox
      and
      push @$list, (map +{ "name", $_, "type", $4, "subtype", lc($1 || ""), 
            "direction", lc($3 || ""), "value", $5 }, split(/\s*,\s*/, $2));
    }
    last if $delimiter eq ")";
    $allargs .= ";";
  }
  return $allargs;
}


# Read a comma-separated list such as a process sensitivity list or a generic
# map.  Nested parentheses are tracked.
# -> optional: Reference to array for two-element arrays representing generic
#    associations.  The first element is the generic name, the second the value.
# <- Complete comma-separated list
sub readcommalist
{
  my ($map)= @_;
  my ($entry, $allentries);

  $allentries= "";
  while( 13 ) {
    $entry= "";
    while( 13 ) {
      $vline =~ s/^($COMMAENTRY)//o;
      $entry .= $1;
      last if $vline =~ /^[,)]/;
      my $new= <$vhandle>;
      return undef unless defined($new);
      chomp $new;
      $new =~ s/^($MANY)--.*$/$1/;
      $vline .= " " . $new;
    }
    $allentries .= $entry;
    $vline =~ s/^([,)])//;
    my $delimiter= $1;
    if( $map && $entry =~ /^\s*($ID)\s*=>(.*)$/io ) {
      my ($key, $val)= ($1, $2);
      $val =~ s/^\s+//;
      $val =~ s/\s+$//;
      push @$map, [ $key, $val ];
    }
    last if $delimiter eq ")";
    $allentries .= ",";
  }
  return $allentries;
}


# Parse VHDL file (to some extent).
# -> Reference to hash representing file.  It has to have a "type" entry and a 
#    "name" entry giving the file name.
# (<-) All top-level declarative items found in the file are entered into the
#    file object's "children" entry which is an array reference.  All children
#    receive entries "file" and "filename" which contain a reference to the
#    file hash and the file name, respectively.
#
# Format of the data structure representing declarative items:
# Each VHDL declarative item is represented by a hash.  These hashes all have a
# "type" entry representing the declaration, such as "entity", "architecture",
# "if" for an if clause, "generate" for a generate statement and so on.  Those
# declarations which have identifiers or labels give rise to a "name" entry.
# Sub-declarations such as an entity's ports and generics, nested if clauses,
# loops or generate statements are stored in an array the reference to which is
# the "children" entry in the hash of the parent object.  Other common entries
# are "subtype" (the definition part of a type declaration, a function's return
# type, the type of loop or generate, or type of a variable or constant),
# "objname" (entity or component of an architecture or instantiation) and
# "architecture" (of an instance).  If documentation comments (--*) relating to
# a declarative item are found, they are parsed with parsedoccom(), and the
# resulting array reference is stored in the item's "doc" entry.
sub parsefile
{
  my ($file)= @_;

  my $fname= $file->{"name"};
  my $errflag= 0;
  my $parsdbg= $config{"parsedebug"};
  my @parsestack;
  my @topuses;
  my $parent= $file;
  my $inconfiguration= 0;
  my $label= "";
  my ($lastdoccom, $keepdoctype);

  ($vline, $doccomment, $aheaddoccom, $keepdoccom, $keepaheaddoc)= ("") x 5;
  open($vhandle, $fname) or croak "Could not open $fname!  Aborting.";
  print "Parsing $fname...\n" unless $config{"quiet"};
  benchmark() if $config{"benchmark"};
vhdlline:
  while( 13 )
  {
    my $newchild;
    my @newentries;

    while( 13 ) {
      $vline =~ s/^\s+//;
      if( $vline =~ s/^($ID)\s*:\s*// ) {
        $label= $1;
      }
      unless( $vline ) {
        getnextline(0) or last vhdlline;
        next;
      }
      if( $vline =~ /\b(?:protected|postponed|package)\s*$/i ) {
        getnextline(0) and next;
      }
      last;
    }
#    print "investigating $vline\n";
    if( $vline =~ /^(?:end|library|constant|attribute)\b/i ) {
      readuntil( qr/;/ ) or last vhdlline;
      if( $vline =~ s/^end(?:\s+($ID))?(?:\s+($ID|$OP))?\s*;//io ) {
        my ($endtype, $endname, $enditem);
        if( $1 && $2 ) {
          $endtype= lc($1);
          $endname= lc($2);
          $enditem= "$endtype $endname";
        }
        else {
          $enditem= lc($1 || $2 || "");
        }
        if( !@parsestack ) {
          $errflag= 1;
          unless( $config{"quiet"} ) {
            print STDERR "Spurious \"end";
            print STDERR " $enditem" if $enditem;
            print STDERR "\" on or before line $..\n";
          }
        }
        else {
          my $lastlevel= pop(@parsestack);
          if( $enditem && ($endtype ?  $endtype ne $lastlevel->{"type"} || 
                            $endname ne lc($lastlevel->{"name"} || "") :
                            $enditem ne $lastlevel->{"type"} &&
                            $enditem ne lc($lastlevel->{"name"} || "") ) ) {
            $errflag= 1;
            unless( $config{"quiet"} ) {
              print STDERR "\"end $enditem\" does not match beginning of block \"",
                            $lastlevel->{"type"};
              print STDERR " ", $lastlevel->{"name"} if $lastlevel->{"name"}; 
              print STDERR "\" on or before line $. in $fname.\n";
            }
          }
          $inconfiguration= 0 if $parent->{"type"} eq "configuration";
          $parent= $lastlevel->{"backtrack"};
          if( $parsdbg ) {
            print "$.: backtracking to ", $parent->{"type"};
            print " ", $parent->{"name"} if $parent->{"name"};
            print "\n";
          }
        }
      }
      elsif( $vline =~ s/^library\s+($IDLIST)\s*;//io ) {
        @newentries= map +{ "type", "library", "name", $_ },
                            split(/\s*,\s*/, $1);
      }
      elsif( $vline =~ s/^attribute\s+($ID)\s+of\s+($AILIST)\s*:\s*
                        ($ID)\s+is\s+($STUFF)\s*;//iox ) {
        my $template= { "type", "attrspec", "name", $1,
                        "objtype", lc($3), "value", $4 };
        my $ailist= $2;
        while( $ailist =~ s/^($AI)(?:\s*,\s*)?//o ) {
          $template->{"objname"}= $1;
          push @newentries, { %$template };
        }
      }
      elsif( $vline =~ s/^(constant|attribute)\s+($IDLIST)\s*:($MSTUFF)
                        (?::=($STUFF))?;//iox ) {
        my ($type, $ids, $subtype, $val)= (lc($1), $2, $3, $4 || "");
        $subtype =~ s/^\s+//;   $subtype =~ s/\s+$//;
        $val =~ s/^\s+//;   $val =~ s/\s+$//;
        @newentries= map +{ "type", $type, "name", $_, 
                "subtype", $subtype, "value", $val }, split(/\s*,\s*/, $ids);
      }
      else {
        $vline =~ s/^$STUFF;//o;
      }
    }
    elsif( !$label && $vline =~ s/^(entity|component|package|packagebody)\b//i ) {
      my $type= lc($1);
      while( $vline !~ /\S/ ) {
        getnextline(0) or last vhdlline;
      }
      if( $vline =~ s/\s+($ID)(?:\s+is\b)?//io  ) {
        $newchild= { "type", $type, "name", $1 };
      }
      else {
        goto skipnext;
      }
    }
    elsif( !$label && $vline =~ /^(?:architecture|configuration|case)\b/i ) {
      last vhdlline unless defined(readuntil( qr/\sis\b/i ));
      if( $vline =~ s/^(architecture|configuration)\s+($ID)\s+
                                of\s+($SID)\s+is\b//iox  ) {
        $newchild= { "type", lc($1), "name", $2, "objname", $3 };
        $newchild->{"objname"} =~ s/\s+//g;
      }
      elsif( $vline =~ s/^case\b$MSTUFF\bis\b//io ) {
        $newchild= { "type", "case", "name", $label };
      }
      else {
        goto skipnext;
      }
    }
    elsif( $vline =~ s/^(?:(procedure|function)|((?:im)?pure))\b//i ) {
      my ($type, $pure)= (lc($1 || ""), lc($2 || "pure"));
      my ($is, $return, $parlist, $params)= ("", "", "", []);
      if( ! $type ) {   # if this started with "pure" or "impure"
        while( $vline !~ /\S/ ) {
          getnextline(0) or last vhdlline;
        }
        goto skipnext unless $vline =~ s/^\s*function\b//i;
        $type= "function";
      }
      last vhdlline unless defined(readuntil( qr/\(|\b(?:is)\b/i ));
      goto skipnext unless $vline =~ s/^\s*($ID|$OP)\s*//o;
      my $name= $1;
      while( 13 ) {
        goto skipnext unless $vline =~ s/^\s*(\(|\b(?:is|return)\b|;)//i;
        if( $1 eq "(" && !$parlist ) {
          $parlist= readarglist($params);
          last vhdlline unless defined(readuntil( qr/\bis\b/i ));
        }
        elsif( lc($1) eq "return" ) {
          goto skipnext if $type eq "procedure";
          $vline =~ s/^($MSTUFF)(?:\b(is)\b|;)//io;
          ($return, $is)= ($1, $2);
          $return =~ s/^\s+//;
          $return =~ s/\s+$//;
          last;
        }
        elsif( lc($1) eq "is" || $1 eq ";" ) {
          $is= $1 ne ";";
          next vhdlline if $type eq "function";
          # We will get here for a function only if no return type is present.
          # We do not use "goto skipnext" because the ";" may already have been
          # removed.
          last;
        }
      }
      $newchild= { "type", $type, "name", $name, "parlist", $parlist,
                    "parameters", $params };
      @$newchild{qw(subtype pure)}= ($return, $pure) if $type eq "function";
      if( !$is ) {
        @newentries= ( $newchild );
        $newchild= undef;
      }
      if( @parsestack == 1 ) {
        push @{$parent->{"childtype"}->{"funcproc"}}, @newentries;
        push @{$parent->{"childtype"}->{"funcproc"}}, $newchild if $newchild;
      }
    }
    elsif( $vline =~ s/^((?:postponed)?process|block)\b//i &&
            ($label || lc($1) ne "block") ) {
      my ($name, $type, $post)= ($label, lc($1) eq "block"? "block":"process",
                                    lc($1) eq "postponedprocess", "");
      my $list= "";
      while( 13 ) {
        if( $vline =~ s/^\s*(\S)// ) {
          if( $1 eq "(" ) {
            $doccomment .= $aheaddoccom;
            $keepdoccom ||= $keepaheaddoc;
            $aheaddoccom= "";
            $keepaheaddoc= 0;
            $list= readcommalist();
          }
          else {
            $vline= $1 . $vline;
          }
          last;
        }
        getnextline(1) or last vhdlline;
      }
      $newchild= { "type", $type, "name", $name };
      if( $type eq "block" ) {
        $newchild->{"guard"}= $list;
      }
      else {
        @$newchild{qw(postponed sensitivity)}= ($post, $list);
      }
    }
    elsif( $vline =~ s/^if\b//i ) {
      last vhdlline unless defined(readuntil( qr/\b(?:generate|then)\b/i ));
      if( $vline =~ s/^($MSTUFF)(\b(?:generate|then)\b|;)//io )  {
        my ($stuff, $keyword)= ($1, lc($2));
        if( $keyword eq "then" ) {
          $newchild= { "type", "if", "name", $label };
        }
        elsif( $label ) {
          $stuff =~ s/^\s+//;
          $stuff =~ s/\s+$//;
          $newchild= { "type", "generate", "subtype", "if", "name", $label,
                      "parameters", $stuff };
        }
      }
    }
    elsif( $vline =~ s/^(while|loop)\b//i ) {
      $newchild= { "type", "loop", "name", $label, "subtype", lc($1) };
      if( $newchild->{"subtype"} ne "loop" ) {
        skipuntil( qr/\bloop\b/i );
      }
    }
    elsif( $vline =~ s/^(sub)?type\b//i ) {
      my $sub= defined($1);
      last vhdlline unless
       defined(readuntil( qr/\b(?:record|protected|protectedbody)\b/i ));
      if( $vline =~ s/^\s*($ID)\s+is\b\s*
            (?:\b(record|protected|protectedbody)\b|($MSTUFF);)//iox ) {
        if( $2 ) {
          $newchild= { "type", lc($2), "name", $1, "sub", $sub };
        }
        else {
          my ($name, $typedef)= ($1, $3);
          $typedef =~ s/^\s+//;
          $typedef =~ s/\s+$//;
          if( $typedef =~ s/\s*\bunits\s+($ID)$//i ) {
            $newchild= { "type", "units", "baseunit", $1, "sub", $sub,
                                "name", $name, "subtype", $typedef };
          }
          else {
            @newentries= ( { "type", "type", "sub", $sub,
                                "name", $name, "subtype", $typedef } );
          }
        }
      }
      else {
        goto skipnext;
      }
    }
    elsif( $vline =~ s/^for\b//i ) {
      while( 13 ) {
        if( $inconfiguration && $vline =~ s/^\s*($ID)\s*(for)/$2/io ) {
          $newchild= { "type", "for", "subtype", "architecture", "objname", $1 };
          last;
        }
        elsif( $vline =~ s/^$MSTUFF\bloop\b//io ) {
          $newchild= { "type", "loop", "name", $label, "subtype", "for" };
        }
        elsif( $label && $vline =~ s/^\s*($MSTUFF)\s*\bgenerate\b//io ) {
          $newchild= { "type", "generate", "subtype", "for", "name", $label,
                      "parameters", $1 };
        }
        elsif( $vline =~ s/^\s*($IDLIST)\s*:\s*($ID)//io ) {
          $newchild= { "type", "for", "subtype", "instance", "objtype", $2,
                                         "objnames", [split(/\s*,\s*/, $1)] };
          unless( $inconfiguration ) {
            @newentries= ( $newchild );
            undef $newchild;
          }
        }
        elsif( $vline =~ s/^$STUFF;//o ) {
          last;
        }
        else {
          getnextline(1) or last vhdlline;
          next;
        }
        $doccomment .= $aheaddoccom;
        $keepdoccom ||= $keepaheaddoc;
        $aheaddoccom= "";
        $keepaheaddoc= 0;
        last;
      }
    }
    elsif( $vline =~ s/^use\b//i ) {
      last vhdlline unless defined(readuntil( qr/\b(?:generic|port)\b/i ));
      if( $vline =~ s/^\s*(?:(entity)\s+($SID)(?:\s*\(\s*($ID)\s*\))?|
                        (configuration)\s+($SID)|(open)\b)//iox ) {
        @newentries= ( { "type", "use", "subtype", lc($1 || $4 || $6), 
                            "name", $2 || $5, "archname", $3 } );
        $newentries[0]->{"name"} =~ s/\s+//g;
        $newentries[0]->{"for"}= $parent->{"children"}->[-1]
              if $parent->{"children"} && @{$parent->{"children"}}
                && $parent->{"children"}->[-1]->{"type"} eq "for"
                && $parent->{"children"}->[-1]->{"subtype"} eq "instance";
      }
      elsif( $vline =~ s/^\s*($SIDLIST)\s*;//o ) {
        @newentries= map +{ "type", "use", "subtype", "package", "name", $_ },
                                                  split(/\s*,\s*/, $1);
        map { $_->{"name"} =~ s/\s+//g; } @newentries;
      }
      else {
        goto skipnext;
      }
    }
    elsif( $vline =~ s/^(generic|port)\b//i ) {
      my $type= lc($1);
      last vhdlline unless defined(readuntil( qr/\(/ ));
      if( $vline =~ s/^\s*\(//i ) {
        @newentries= readportlist($type);
      }
      elsif( $type eq "generic" && $vline =~ s/^\s*map\s*\(//i ) {
        my $genmap= [];
        readcommalist($genmap);
        @newentries= ( { "type", "genericmap", "map", $genmap } );
        skipstatement();
        if( $parent->{"children"} && @{$parent->{"children"}} ) {
          $parent->{"children"}->[-1]->{"genericmap"}= $newentries[0];
        }
        else {
          $parent->{"genericmap"}= $newentries[0];
        }
      }
      else {
        goto skipnext;
      }
    }
    # Instantiations
    elsif( $label && $vline =~ /^$SID/o ) {
      last vhdlline unless defined(readuntil( qr/\bmap\s*\(/i ));
      goto skipnext unless
          $vline =~ s/^(?>(?:(component|configuration|entity)\s+)?)
            ($SID)(?:\s*\(\s*($ID)\s*\))?\s*(generic|port)\s+map\s*\(//iox;
      my $genmap= [];
      @newentries= ( { "type", "instance", "name", $label, "objname", $2,
                          "subtype", lc($1 || "component"), "archname", $3,
                          "genericmap", $genmap, "uses",
                      [ @parsestack ? @{$parsestack[-1]->{"uses"}} : () ] } );
      $newentries[0]->{"objname"} =~ s/\s+//g;
      readcommalist($genmap) if $4 eq "generic";
    }
    elsif( $vline =~ s/^(?:(?:else|begin|is)\b|;)//i ) {}
    elsif( $vline =~ s/^elsif\b//i ) {
      skipuntil(qr/\bthen\b/i);
    }
    elsif( $vline =~ s/^when\b//i ) {
      skipuntil(qr/=>/i);
    }
    else {
skipnext:
      skipstatement();
      next vhdlline;
    }
    if( $newchild ) {
      $keepdoccom= 0;
      $newchild->{"doc"}= parsedoccom($doccomment) if $doccomment;
      $doccomment= $aheaddoccom;
      $keepdoccom ||= $keepaheaddoc;
      $aheaddoccom= "";
      push @{$parent->{"children"}}, $newchild;
      if( @parsestack == 0 ) {
        $newchild->{"uses"}= [ @topuses ];
      }
      elsif( @parsestack == 1 ) {
        # List children by type for top-level constructs
        push @{$parent->{"childtype"}->{$newchild->{"type"}}}, $newchild;
      }
      push @parsestack, { "backtrack", $parent, 
              "type", $newchild->{"type"}, "name", $newchild->{"name"},
              "uses" => [ @parsestack ? @{$parsestack[-1]->{"uses"}} : () ] };
      $inconfiguration= 1 if $newchild->{"type"} eq "configuration";
      $parent= $newchild;
      if( @parsestack > 1 && $newchild->{"type"} eq "process" ) {
        # List all processes to avoid recursive searches later
        push @{$parsestack[1]->{"backtrack"}->{"allprocesses"}}, $newchild;
      }
      if( $parsdbg ) {
        print "$.: descending into ", $newchild->{"type"};
        print " ", $newchild->{"name"} if $newchild->{"name"};
        print "\n";
      }
    }
    elsif( @newentries ) {
      if( !$doccomment && $keepdoccom ) {
        $keepdoccom= 0 unless $newentries[0]->{"type"} eq $keepdoctype;
        $doccomment ||= $lastdoccom if $keepdoccom;
      }
      if( $doccomment && !($config{"compat"} && !@parsestack) ) {
        if( $keepdoccom ) {
          $lastdoccom= $doccomment;
          $keepdoctype= $newentries[0]->{"type"};
        }
        $doccomment= parsedoccom($doccomment);
        foreach (@newentries) { $_->{"doc"}= $doccomment; }
        # non-empty $aheaddoccom occurs only for $newchild blocks
        $doccomment= "";
      }
      push @{$parent->{"children"}}, @newentries;
      if( @parsestack == 1 ) {
        # List children by type for top-level constructs.  This relies on all
        # new entries having the same type.
        push @{$parent->{"childtype"}->{$newentries[0]->{"type"}}}, @newentries;
      }
      if( @parsestack && $newentries[0]->{"type"} eq "instance" ) {
        # List all instances to avoid recursive searches later
        my $top= @parsestack > 1? $parsestack[1]->{"backtrack"} : $parent;
        push @{$top->{"allinstances"}}, @newentries;
      }
      elsif( $newentries[0]->{"type"} eq "use" ) {
        # List all use clauses to avoid recursive searches later
        if( @parsestack ) {
          my $top= @parsestack > 1? $parsestack[1]->{"backtrack"} : $parent;
          push @{$top->{"alluses"}}, @newentries;
          push @{$parsestack[-1]->{"uses"}}, @newentries;
        }
        else {
          push @topuses, @newentries;
        }
      }
      if( $parsdbg && $newentries[0]->{"type"} !~ /^(?:port|generic)$/ ) {
        # "found..." message already output in readportlist() for ports/gens
        print "$.: found ", $newentries[0]->{"type"};
        print "s" if $#newentries;
        print " ", join(", ", map($_->{"name"}, @newentries))
              if $newentries[0]->{"name"};
        print "\n";
      }
    }
  }
  continue {
    $doccomment= "" unless $config{"compat"} && !@parsestack;
    $label= "";
  }
done:
  benchmark("to parse", $.) if $config{"benchmark"};
  close $vhandle;
  if( @parsestack ) {
    print STDERR "Not all blocks were closed - missing one or more \"end\"s.\n";
    $errflag= 1;
  }
  $file->{"uses"}= \@topuses;
  # Remove the declarative blocks we are not interested in, which we parsed
  # only to keep track of nesting:
  prune_all($file, "type", "loop");
  prune_all($file, "type", "if");
  prune_all($file, "type", "case");
  map { $_->{"filename"}= $fname; $_->{"file"}= $file; } @{$file->{"children"}};
  print STDERR "There were errors parsing $fname.  Continuing regardless.\n"
        if $errflag;
}

}


# Compare the hash representations of two functions or procedures for finding
# equivalent declarations in a package and its package body.  The types of the
# two declarations (function or procedure) are not compared and are assumed to
# be equal.
# -> Two references to hashes representing declarative items
# <- 1 if equal, 0 otherwise
sub packsubeq
{
  my ($a, $b)= @_;

  return 0 if lc($a->{"name"}) ne lc($b->{"name"});
  if( $a->{"type"} eq "function" ) {
    return 0 if $a->{"pure"} ne $b->{"pure"} ||
                codecmp($a->{"subtype"}, $b->{"subtype"});
  }
  return 0 if @{$a->{"parameters"}} != @{$b->{"parameters"}};
  for my $ind (0..$#{$a->{"parameters"}}) {
    my $pa= $a->{"parameters"}->[$ind];
    my $pb= $b->{"parameters"}->[$ind];
    return 0 if lc($pa->{"name"}) ne lc($pb->{"name"}) ||
                $pa->{"subtype"} ne $pb->{"subtype"} ||
                $pa->{"direction"} ne $pb->{"direction"} ||
                codecmp($pa->{"type"}, $pb->{"type"}) ||
                defined($pa->{"value"}) != defined($pb->{"value"}) ||
          (defined($pa->{"value"}) && codecmp($pa->{"value"}, $pb->{"value"}));
  }
  return 1;
}


##############################################################################
##############################################################################
####                    Data handling functions
##############################################################################
##############################################################################


# Make list of source file unique.  A warning message is output if duplicates
# are found, and all but one of them are removed from the file list.
# -> Reference to array of references to hashes representing files
# <- 1 if duplicates were found and removed.
sub uniq_files
{
  my ($files)= @_;
  my $removed= 0;
  # Don't use File::Spec->curdir(), it takes 1 second (!)
  my $cwd= $config{"cwd"};

  for my $elem (@$files) {
    my $absname= mycanonpath(File::Spec->rel2abs($elem->{"name"}, $cwd));
    for my $elem2 (@$files) {
      next unless defined($elem2);
      last if $elem2 == $elem;
      if( $absname eq
                mycanonpath(File::Spec->rel2abs($elem2->{"name"}, $cwd)) ) {
        unless( $config{"quiet"} ) {
          print STDERR "Duplicate source file ", $elem2->{"name"};
          if( $elem->{"libname"} ne $elem2->{"libname"} ) {
            print STDERR ", in libraries ", $elem2->{"libname"}, " and ",
                      $elem->{"libname"}, ".  Discarding the one in library ",
                      $elem->{"libname"}, ".\n";
          }
          else {
            print STDERR " in library ", $elem->{"libname"}, ".\n";
          }
        }
        $elem= undef;
        $removed= 1;
        last;
      }
    }
  }
  @$files= grep defined($_), @$files;
  return $removed;
}


# Find children of a declarative item which fulfil a condition
# -> Reference to declarative item represented as hash
#    Key to compare
#    Requested value of that key in a (direct) child of the decl. item
# <- Array of matching children
sub find_children
{
  my ($obj, $key, $val)= @_;

  return () unless $obj->{"children"};
  return grep lc($_->{$key}) eq lc($val), @{$obj->{"children"}};
}


# Returns the maximal depth of a part of the declaration hierarchy
# -> Reference to the hash which is the root of the appropriate part of the
#    hierarchy
# <- Depth (0 if the root has no children, and so on)
sub max_depth
{
  my ($root)= @_;
  my $maxd= 0;

  if( !$root->{"children"} || !@{$root->{"children"}} ) {
    return 0;
  }
  for my $child (@{$root->{"children"}}) {
    my $childd= max_depth($child);
    $maxd= $childd if $maxd < $childd;
  }
  return $maxd+1;
}


# Finds all nodes of a certain type in a subtree
# -> Reference to hash representing root node
#    Key of entry to be compared
#    Value of that key in the searched-for nodes (case insensitive string 
#    comparison)
# <- Array of hash (node) references
sub find_all
{
  my ($root, $key, $val)= @_;
  my @all;

  $val= lc($val);
  push @all, $root if lc($root->{$key}) eq $val;
  for my $child (@{$root->{"children"}}) {
    push @all, (find_all($child, $key, $val));
  }
  return @all;
}


# Finds all nodes of a certain type in a subtree and returns their paths in the
# tree
# -> Reference to hash representing root node
#    Key of entry to be compared
#    Value of that key in the searched-for nodes (case insensitive string 
#    comparison)
# <- Array of references to arrays of hash (node) references
sub trace_all
{
  my ($root, $key, $val)= @_;
  my @all;

  $val= lc($val);
  push @all, [ ] if lc($root->{$key}) eq $val;
  for my $child (@{$root->{"children"}}) {
    my @new= trace_all($child, $key, $val);
    map { unshift @$_, $child } @new;
    push @all, @new;
  }
  return @all;
}


# Deletes all nodes of a certain type in a subtree, including their children
# -> Reference to hash representing root node
#    Key of entry to be compared
#    Value of that key in the nodes to be pruned (string comparison)
sub prune_all
{
  my ($root, $key, $val)= @_;

  return unless $root->{"children"};
  $val= lc($val);
  @{$root->{"children"}}= grep(lc($_->{$key}) ne $val, @{$root->{"children"}});
  for my $child (@{$root->{"children"}}) {
    prune_all( $child, $key, $val );
  }
}


# Remove equivalent objects (references to their hashes) from an array.  All
# objects in the array have to be of the same type and situated in the same
# library.  They are considered equivalent if their names are equal and (for
# architectures and configurations) if their entity has the same name.  A
# warning is printed if there are duplicates and unless $config{"quiet"}.
# -> Reference to the array
# <- 1 if elements were removed
sub uniq_objs
{
  my ($ary)= @_;
  return 0 unless @$ary;
  my $type= $ary->[0]->{"type"};
  my $archtype= $type eq "architecture" || $type eq "configuration";
  my $removed= 0;

  for my $elem (@$ary) {
    for my $elem2 (@$ary) {
      next unless defined($elem2);
      last if $elem2 == $elem;
      if( lc($elem->{"name"}) eq lc($elem2->{"name"}) ) {
        next if $archtype && lc($elem->{"objname"}) ne lc($elem2->{"objname"});
        unless( $config{"quiet"} ) {
          print STDERR ucfirst($type), " ", $elem->{"name"};
          print STDERR " of ", $elem->{"objname"} if $archtype;
          print STDERR " was found twice";
          if( $elem->{"filename"} ne $elem2->{"filename"} ) {
            print STDERR ", in ", $elem2->{"filename"}, " and ",
                        $elem->{"filename"}, ".  Discarding the one from ",
                        $elem->{"filename"}, ".\n";
          }
          else {
            print STDERR " in ", $elem->{"filename"}, ".\n";
          }
        }
        $elem= undef;
        $removed= 1;
        last;
      }
    }
  }
  @$ary= grep defined($_), @$ary;
  return $removed;
}


# Finds the corresponding declarations for each attribute specification, and
# assigns the specifications to their targets.  The targets receive a new entry
# "attributes" in their hash which references a hash in which the keys are
# references to the attribute declarations and the values to the
# specifications.
# -> Hash reference representing top-level declarative item.  Only its
#    (first-level) children are considered when searching for attributes, and
#    only its children and itself are candidates for targets.
sub match_attributes
{
  my ($top)= @_;
  my @aspecs= @{$top->{"childtype"}->{"attrspec"} || []};
  my @adecls= @{$top->{"childtype"}->{"attribute"} || []};

  for my $aspec (@aspecs) {
    for my $adecl (@adecls) {
      if( lc($adecl->{"name"}) eq lc($aspec->{"name"}) ) {
        $aspec->{"attribute"}= $adecl;
        last;
      }
    }
  }
  for my $aspec (@aspecs) {
    if( $top->{"type"} eq $aspec->{"objtype"} && 
        lc($top->{"name"}) eq lc($aspec->{"objname"}) ) {
      $top->{"attributes"}->{$aspec->{"name"}}= $aspec;
      next;
    }
    my @targets;
    if( $aspec->{"objtype"} eq "label" ) {
      @targets= ( @{$top->{"allinstances"}}, @{$top->{"allprocesses"}} );
      # Many other labels can have attributes but only those of instances and
      # processes are of interest to us
    }
    elsif( $aspec->{"objtype"} =~
        /^(?:entity|architecture|configuration|package|packagebody)$/ ) {
      @targets= ( $top )
        if $aspec->{"objtype"} eq $top->{"type"};
    }
    else {
      @targets= @{$top->{"childtype"}->{$aspec->{"objtype"}} || []};
    }
    next unless @targets;
    if( lc($aspec->{"objname"}) eq "all" ) {
      map { $_->{"attributes"}->{$aspec->{"name"}}= $aspec; } @targets;
    }
    elsif( lc($aspec->{"objname"}) eq "others" ) {
      for my $target (@targets) {
        $target->{"attributes"}->{$aspec->{"name"}}= $aspec
                unless $target->{"attributes"}->{$aspec->{"name"}};
      }
    }
    else {
      my $truncname= $aspec->{"objname"};
      $truncname =~ s/\s*\[.*$//;
      $truncname= lc($truncname);
      @targets= grep lc($_->{"name"}) eq $truncname, @targets;
      next unless @targets;
      if( ($aspec->{"objtype"} eq "function" || 
        $aspec->{"objtype"} eq "procedure") && $aspec->{"objname"} =~ /\[/ ) {
        my @argtypes;
        my $arglist;
        $arglist= $aspec->{"objname"};
        $arglist =~ s/^.*\[\s*//;
        $arglist =~ s/\s*\]\s*$//;
        @argtypes= split /\s*(?:,|\breturn\b)\s*/i, $arglist;
        my $returntype= pop @argtypes if $arglist =~ /\breturn\b/i;
tryfunctarget:
        for my $target (@targets) {
          next if $returntype && $target->{"subtype"} !~ /\b$returntype\b/i;
          next if $#argtypes != $#{$target->{"parameters"}};
          for my $ind (0..$#argtypes) {
            my $type= $argtypes[$ind];
            next tryfunctarget
                if $target->{"parameters"}->[$ind]->{"type"} !~ /\b$type\b/i;
          }
          $target->{"attributes"}->{$aspec->{"name"}}= $aspec;
        }
      }
      else {
        map { $_->{"attributes"}->{$aspec->{"name"}}= $aspec; } @targets;
      }
    }
  }
}


# Try to merge the selected name in a package use clause with the selected name
# describing an entity, component, configuration or similar.  The rightmost
# part of the use clause name has to be the same as the leftmost part of the
# entity selected name, or the rightmost part of the use clause name has to be
# "all" for this to succeed.  The total number of components (separated by ".")
# of the result must be at most 3.
# -> Selected name from use clause
#    Selected name of object
# <- Merged name or undef
sub merge_selname
{
  my ($suse, $sobj)= @_;
  my $selname;

  $suse =~ s/\.all$//i;
  $selname= $suse . "." . $sobj;
  $selname =~ s/\.([^.]+)\.\1\./.$1./;
  return ($selname =~ tr/././) <= 2 ? $selname : undef;
}


{

# Table of selected names.  Those tables which will be searched are initialised
# up-front to avoid "can't use undef as hash ref" errors.
my %selnames= map { $_ => {}; }
          qw(entity architecture configuration package packagebody component);
# Dummy scalar the reference to which indicates that multiple objects with that
# name and type exist.
my $multiple;

# Add objects to the table of selected names applicabel for their type.
# -> Prefix (for to-level constructs, this is the library name, for
#    declarations in packages, this is "library.package")
#    List of objects
sub add_selnames
{
  my $prefix= shift;

  for (@_) {
    my $table= $selnames{$_->{"type"}};
    if( $table->{lc($_->{"name"})} ) {
      $table->{lc($_->{"name"})}= \$multiple;
    }
    else {
      $table->{lc($_->{"name"})}= $_;
    }
    $table->{lc($prefix . "." . $_->{"name"})}= $_;
  }
}

# Find the object denoted by a selected name.
# -> Name of the object
#    Type of the object (if empty or undef, all tables will be searched)
#    optional: Prefix (such as library of a top-level object or
#    "library.package" for declarations in a package)
# <- Reference to object hash if found; undef if not found; defined but false
#    (0) if ambiguous and no prefix given
sub find_selname
{
  my ($name, $type, $prefix)= @_;

  if( $type ) {
    my $obj= $selnames{$type}->{lc($name)};
    return $obj if $obj && $obj != \$multiple;
    return ($obj ? 0 : undef) if !$prefix;
    return $selnames{$type}->{lc($prefix . "." . $name)};
  }
  # Try all types if type is not given:
  for my $t (keys %selnames) {
    my $obj= find_selname($name, $t, $prefix);
    return $obj if $obj;
  }
  return undef;
}

}



# Try to resolve @see cross references.  This function should only be called
# when the "docfilename" and "doclink" entries of various possible reference
# targets have already be defined.
# -> Reference to array of references to arrays containing the cross reference
#    in their first element
#    Reference to hash mapping library names to references of arrays of their
#    declarative items
#    (optional) Name of the current library
# (<-) For those references which are resolved, the second element of the array
#    will contain a reference to the target object's hash.  The third element
#    will contain a hyperlink to the target's description.
sub resolve_seealso
{
  my ($seeary, $libhash, $libname)= @_;

  for my $see (@$seeary) {
#TODO: search for types in intelligent order rather than using type ""
    my $candidate= find_selname($see->[0], "", $libname);
    next unless $candidate;
    $see->[1]= $candidate;
    if( $candidate->{"type"} eq "entity" ) {
      $see->[2]= "../entities/" . $candidate->{"docfilename"};
    }
    elsif( $candidate->{"type"} eq "architecture" ) {
      $see->[2]= "../architectures/" . $candidate->{"docfilename"};
    }
    elsif( $candidate->{"type"} eq "configuration" ) {
      $see->[2]= "../configurations/" . $candidate->{"docfilename"};
    }
    elsif( $candidate->{"type"} =~ /^package(?:body)?$/ ) {
      $see->[2]= "../packages/" . $candidate->{"docfilename"};
    }
    elsif( $candidate->{"doclink"} ) {  # declarative item in a package
      $see->[2]= $candidate->{"doclink"};
    }
  }
}


# Assign references to corresponding declarative items to the "for" and "use"
# statements in a configuration.
# -> Reference to hash representing configuration
#    Reference to hash mapping library names to references to arrays of their
#    declarations
sub resolve_configuration
{
  my ($conf, $libhash)= @_;
  my $ent;
  my $libname;
  my @topfors;
  my @todo;
  my @forothers;

  return unless $ent= $conf->{"entity"};
  $libname= $conf->{"file"}->{"libname"};
  @topfors= grep $_->{"type"} eq "for" && $_->{"subtype"} eq "architecture",
                        @{$conf->{"children"}};
  @topfors= grep { my $for= $_;
                  ($for->{"object"})= grep $_->{"name"} eq $for->{"objname"},
                                        @{$ent->{"architectures"}};
                } @topfors;
  for my $for (@topfors) {
    push @todo, map( [ $_, $for->{"object"}, $for ],
                        find_children($for, "type", "for"));
  }
  while( @todo )
  {
    my $triplet;
    my $for;
    my $parentdecl;

    $triplet= pop @todo;
    ($for, $parentdecl)= @$triplet;
    if( $for->{"subtype"} eq "architecture" ) {
      # Configuration of an architecture or of a generate or block statement
      if( $parentdecl->{"type"} eq "architecture" && 
                        $for->{"objname"} eq $parentdecl->{"name"} ) {
        $for->{"object"}= $parentdecl;
      }
      else {
        my @candidates= grep $_->{"type"} =~ /^(?:generate|block)$/,
                find_children($parentdecl, "name", $for->{"objname"});
        $for->{"object"}= $candidates[0];
      }
      my @newfors= find_children($for, "type", "for");
      push @todo, map( [ $_, $for->{"object"}, $for ], @newfors);
    }
    else {
      my @candidates= find_all($parentdecl, "type", "instance");
      @candidates= grep $_->{"subtype"} eq "component", @candidates;
      @candidates= grep lc($_->{"objname"}) eq lc($for->{"objtype"}), @candidates;
      if( lc($for->{"objnames"}->[0]) eq "others" ) {
        push @forothers, $triplet;
      }
      elsif( lc($for->{"objnames"}->[0]) ne "all" ) {
        @candidates= grep { my $cand= $_;
                    grep lc($_) eq lc($cand->{"name"}), @{$for->{"objnames"}};
                      } @candidates;
      }
      $for->{"objects"}= \@candidates;
      my ($use)= find_children($for, "type", "use");
      $for->{"use"}= $use;
      if( $use && $use->{"subtype"} ne "open" ) {
        $for->{"bindname"}= $use->{"name"};
        $use->{"object"}= find_selname($use->{"name"}, $use->{"subtype"},
                                          $libname);
        $for->{"binding"}= $use->{"object"};
        if( $use->{"subtype"} eq "entity" && $for->{"binding"} ) {
          if( $use->{"archname"} ) {
            $for->{"archname"}= $use->{"archname"};
            ($for->{"bindarch"})= ($use->{"architecture"})=
                grep lc($_->{"name"}) eq lc($use->{"archname"}),
                      @{$for->{"binding"}->{"architectures"}};
          }
          elsif( @{$for->{"binding"}->{"architectures"}} ) {
            ($for->{"bindarch"})= @{$for->{"binding"}->{"architectures"}};
            $for->{"archname"}= $for->{"bindarch"}->{"name"};
          }
          if( $for->{"bindarch"} ) {
            my @newfors= find_children($for, "type", "for");
            push @todo, map( [ $_, $for->{"bindarch"}, $for ], @newfors);
          }
        }
        $for->{"bindgen"}= $use->{"genericmap"};
      }
      else {
        $for->{"bindgen"}= $for->{"genericmap"};
      }
    }
  }
  for my $triplet (@forothers) {
    my ($for, undef, $parent)= @$triplet;
    my @siblings= find_children($parent, "type", "for");
    for my $sibl (@siblings) {
      next if $sibl == $for;
      for my $obj (@{$for->{"objects"}}) {
        $obj= undef if grep($_ == $obj, @{$sibl->{"objects"}});
      }
    }
    @{$for->{"objects"}}= grep defined($_), @{$for->{"objects"}};
  }
}


# Search for an equivalent of a child hierarchy node in an array of other child
# or top-level nodes.  This is used to prevent duplicate instantiations in the
# instantiation hierarchy.  The comparison performed is slightly asymmetrical
# as required in the situations where this function is used: Child nodes
# representing configuration instantiations need not have been resolved yet (=
# have an entity and architecture assigned to them), but top-level
# configuration nodes in the array may have.  (See the third argument, though.)
# -> Reference to the hash representing the child node
#    Reference to the array of hash references representing the other nodes
#    optional: if 1, the "confname" and "configuration" entries of the first
#    argument are ignored, and the comparison is based solely on the
#    entity and architecture to which the configuration node has been resolved.
# <- The hash reference of the node from the array if an equivalent node has
#    been found; otherwise undef
sub grep_hier
{
  my ($child, $ary, $ignoreconf)= @_;
  my $result;

  if( !$ignoreconf && $child->{"confname"} ) {
    if( $child->{"configuration"} ) {
      ($result)= grep $_->{"configuration"} &&
                    $_->{"configuration"} == $child->{"configuration"}, @$ary;
    }
    else {
      ($result)= grep !$_->{"configuration"} && $_->{"confname"} &&
                      lc($_->{"confname"}) eq lc($child->{"confname"}), @$ary;
    }
  }
  elsif( $child->{"architecture"} ) {
    ($result)= grep $_->{"architecture"} && !$_->{"confname"} &&
                    $_->{"architecture"} == $child->{"architecture"}, @$ary;
  }
  elsif( $child->{"entity"} ) {
    ($result)= grep $_->{"entity"} && !$_->{"architecture"} &&
                !$_->{"confname"} && $_->{"entity"} == $child->{"entity"} &&
          lc($_->{"archname"} || "") eq lc($child->{"archname"} || ""), @$ary;
  }
  else {
    ($result)= grep !$_->{"entity"} && !$_->{"architecture"} &&
         !$_->{"confname"} && lc($_->{"entname"}) eq lc($child->{"entname"}) &&
         lc($_->{"archname"} || "") eq lc($child->{"archname"} || ""), @$ary;
  }
  return $result;
}


# Compares two sub-hierarchies of instantiations.  Children are compared in
# order, which is sufficient if equal subtrees were generated by the same
# algorithm.
# -> Two hierarchy nodes which are the roots of the sub-hierarchies to be
#    compared.
# <- 1 if equal, 0 otherwise
sub hier_equal
{
  my ($node1, $node2)= @_;

  return 1 if $node1 == $node2;
  return 0
      if ($node1->{"configuration"} || 0) != ($node2->{"configuration"} || 0);
  return 0 if lc($node1->{"confname"} || "") ne lc($node2->{"confname"} || "");
  return 1 if $node1->{"proxy"} && $node2->{"proxy"} &&
                $node1->{"proxy"} == $node2->{"proxy"};
  return 0
        if ($node1->{"architecture"} || 0) != ($node2->{"architecture"} || 0);
  return 0 if ($node1->{"entity"} || 0) != ($node2->{"entity"} || 0);
  return 0 if lc($node1->{"archname"} || "") ne lc($node2->{"archname"} || "");
  return 0 if lc($node1->{"entname"} || "") ne lc($node2->{"entname"} || "");
  return 0 if $#{$node1->{"children"}} != $#{$node2->{"children"}};
  for my $ind (0..$#{$node1->{"children"}}) {
    return 0 unless hier_equal($node1->{"children"}->[$ind],
                                $node2->{"children"}->[$ind]);
  }
  return 1;
}


# Comparison between instantiation hierarchy nodes for use with the sort
# function.  The comparison criteria in descending order of priority are entity
# name, architecture name and configuration name.
# (->) Global variables $a and $b, provided by sort, are interpreted as
#      references to hashes representing instantiation hierarchy nodes.
# <- <0 if $a "<" $b etc.
sub hier_sort_cmp
{
  my $last= "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz";
  my $result;

  if( $result= (lc($a->{"entname"} || $last) cmp
                lc($b->{"entname"} || $last)) ) {
    return $result;
  }
  if( $result= (lc($a->{"archname"} || $last) cmp
                lc($b->{"archname"} || $last)) ) {
    return $result;
  }
  return lc($a->{"confname"} || $last) cmp lc($b->{"confname"} || $last);
}


# Find all for statements referring to an instance at the current level of a
# configuration.
# -> Reference to hash representing a configuration or a for statement in a
#    configuration
# <- Reference to array containing references to hashes representing the for
#    statements.  Only the next-level instance for statements are returned, no
#    nesting.  But intermediate for statements referring to block or generate
#    statements are searched.
sub find_forinsts
{
  my ($root)= @_;
  my @results;

  for my $for (grep $_->{"type"} eq "for", @{$root->{"children"}}) {
    if( $for->{"subtype"} eq "instance" ) {
      push @results, $for;
    }
    else {
      push @results, find_forinsts($for);
    }
  }
  return @results;
}


# Build a part of the instantiation hierarchy from a configuration
# instantiation
# -> Reference to the hierarchy node corresponding to a configuration
#    instantiation which has been resolved
#    Reference to array of all hierarchy nodes representing architectures
#    Reference to array of all hierarchy nodes representing configurations
# (<-) Nodes corresponding to bindings given in the configuration are entered
#    into the hierarchy and equal existing nodes marked as instantiated
sub configure_hierarchy
{
  my ($node, $ahier, $chier)= @_;
  my $conf= $node->{"configuration"};

  $node->{"entity"}= $conf->{"entity"}, 
  $node->{"entname"}= $conf->{"objname"};
  my ($topfor)= @{$conf->{"childtype"}->{"for"} || []};
  unless( $topfor && $topfor->{"subtype"} eq "architecture" ) {
    # Pathological case #1: empty configuration body - bind entity to its
    # first architecture.
    if( $node->{"entity"}->{"architectures"}->[0] ) {
      $node->{"architecture"}= $node->{"entity"}->{"architectures"}->[0];
      $node->{"archname"}= $node->{"architecture"}->{"name"};
      if( my ($anode)= grep_hier($node, $ahier, 1) ) {
        $node->{"proxy"}= $anode;
        $anode->{"instantiated"}= 1;
      }
    }
    return;
  }
  $node->{"archname"}= $topfor->{"objname"};
  $node->{"architecture"}= $topfor->{"object"};
  configure_hierarchy_arch($topfor, $node, $ahier, $chier);
}


# Build part of the instantiation hierarchy from one architecture-related for
# statement in a configuration
# -> Reference to hash representing the for statement (which has been resolved)
#    Reference to the hierarchy node representing the architecture (either the
#    topmost architecture node in the configuration or the parent node
#    representing an instance for statement)
#    Reference to array of all hierarchy nodes representing architectures
#    Reference to array of all hierarchy nodes representing configurations
# (<-) Nodes representing instance-related for statements of this
#    architecture-related for statement are created recursively, and other
#    instantiated entities and configurations are also listed as children.
sub configure_hierarchy_arch
{
  my ($for, $node, $ahier, $chier)= @_;

  my @nextfors= grep($_->{"use"}, find_forinsts($for));
  unless( @nextfors ) {
    # Pathological case #2: empty architecture for statement - bind entity to
    # this architecture.
    if( my ($anode)= grep_hier($node, $ahier, 1) ) {
      $node->{"proxy"}= $anode;
      $anode->{"instantiated"}= 1;
    }
    return;
  }
  my $arch= $node->{"architecture"};
  unless( $arch ) {
    for my $nfor (@nextfors) {
      push @{$node->{"children"}}, 
                configure_hierarchy_for($nfor, $node, $ahier, $chier);
    }
    return;
  }
  $node->{"children"}= [];
  my @archildren;
confarchinst:
  for my $inst (@{$arch->{"allinstances"}}) {
    my $new;
    for my $ind (0..$#nextfors) {
      my $nfor= $nextfors[$ind];
      if( grep($_ == $inst, @{$nfor->{"objects"}}) ) {
        next confarchinst if $nfor->{"hier_done"};
        $nfor->{"hier_done"}= 1;
        $new= configure_hierarchy_for($nfor, $node, $ahier, $chier);
        push @{$node->{"children"}}, $new
                unless grep hier_equal($new, $_), @{$node->{"children"}};
        next confarchinst;
      }
    }
    if( $inst->{"subtype"} eq "configuration" || ($inst->{"binding"} &&
        $inst->{"binding"}->{"type"} eq "configuration") ) {
      if( $inst->{"binding"} ) {
        ($new)= grep $_->{"configuration"} == $inst->{"binding"}, @$chier;
        $new->{"instantiated"}= 1;
      }
      else {
        $new= { "confname" => $inst->{"objname"} };
      }
    }
    else {
      if( $inst->{"binding"} ) {
        if( $inst->{"bindarch"} && (my ($anode)=
            grep($_->{"architecture"} == $inst->{"bindarch"}, @$ahier)) ) {
          $new= $anode;
          $anode->{"instantiated"}= 1;
        }
        else {
          $new= { "entity" => $inst->{"binding"},
                  "entname" => $inst->{"bindname"},
                  "architecture" => $inst->{"bindarch"}, 
                  "archname" => $inst->{"archname"} };
        }
      }
      else {
        $new= { "entname" => $inst->{"bindname"} || $inst->{"objname"},
                "archname" => $inst->{"archname"} };
      }
    }
    unless( grep_hier($new, \@archildren) ) {
      push @{$node->{"children"}}, $new;
      push @archildren, $new;
    }
  }
  for (@nextfors) {
    undef $_->{"hier_done"};
  }
}


# Build a part of the instantiation hierarchy from one instance-related for
# statement in a configuration
# -> Reference to hash representing the for statement (which has been resolved)
#    Reference to the hierarchy node representing the configuration or a
#    different node with the right confname and configuration entries
#    Reference to array of all hierarchy nodes representing architectures
#    Reference to array of all hierarchy nodes representing configurations
# <- Node (reference to hash) representing the instantiation bound by this for
#    statement
sub configure_hierarchy_for
{
  my ($for, $confnode, $ahier, $chier)= @_;
  my $use= $for->{"use"};
  my $node;

  if( $use->{"subtype"} eq "configuration" ) {
    $node= { "confname" => $use->{"name"},
              "configuration" => $for->{"binding"} };
    if( my ($cnode)= grep_hier($node, $chier) ) {
      $cnode->{"instantiated"}= 1;
      return $cnode;
    }
  }
  else {
    my $arch= $for->{"bindarch"};
    $node= { "entity" => $for->{"binding"},
             "entname" => $for->{"bindname"} || $use->{"name"},
             "architecture" => $arch, "archname" => $for->{"archname"},
             "configuration" => $confnode->{"configuration"},
             "confname" => $confnode->{"confname"} };
    my ($archfor)= grep lc($_->{"objname"}) eq lc($node->{"archname"}),
                                find_children($for, "type", "for");
    if( $archfor ) {
      configure_hierarchy_arch($archfor, $node, $ahier, $chier);
    }
    else {
      if( my ($anode)= grep_hier($node, $ahier, 1) ) {
        $node->{"proxy"}= $anode;
        $anode->{"instantiated"}= 1;
      }
    }
  }
  return $node;
}


# Returns the maximal depth of a part of the instantiation hierarchy
# -> Reference to the hash which is the root of the part-hierarchy
# <- Depth (0 if the root has no children, and so on).  Recursive instantiation
#    is cut off after the first node which indicates it.
sub hier_max_depth
{
  my ($root, $trace)= @_;
  my $maxd= 0;
 
  $trace ||= [];
  if( $root->{"proxy"} ) {
    return hier_max_depth($root->{"proxy"}, $trace);
  }
  if( !$root->{"children"} || !@{$root->{"children"}} ||
                                grep($_==$root, @$trace) ) {
    return 0;
  }
  push @$trace, $root;
  for my $child (@{$root->{"children"}}) {
    my $childd= hier_max_depth($child, $trace);
    $maxd= $childd if $maxd < $childd;
  }
  pop @$trace;
  return $maxd+1;
}


##############################################################################
##############################################################################
####                    Output functions
##############################################################################
##############################################################################

# classes and <span> tags for VHDL language elements:
my $SPDOC= "<span class=\"doccom\">";       # documentation comment text
my $SPID= "<span class=\"identifier\">";    # identifier
my $SPTID= "<span class=\"thisid\">";       # identifier of this declaration
my $SPSTR= "<span class=\"vhdlstr\">";      # quoted (bit) string or bit
my $SPIO= "<span class=\"vhdlio\">";        # in, out, inout
my $SPVA= "<span class=\"vhdlvar\">";       # signal, constant, variable, attr.
my $SPDCL= "<span class=\"vhdldecl\">";     # declarative item
my $SPWD= "<span class=\"vhdlword\">";      # other VHDL reserved word
my $SPIE= "<span class=\"vhdlieee\">";      # standard package word
my $CCO= " class=\"vhdlcode\"";
my $SPCO= "<span class=\"vhdlcode\">";      # encloses all VHDL code
my $SPNC= "<span class=\"nocode\">";        # non-code within class vhdlcode
my $SP_= "</span>";

# Try to create output directories if they do not yet exist, and localise the
# file name of style sheet and logos relative to the output directory if
# applicable.  The function dies if it cannot create the directories.
# (<->) %config
sub prepareoutput
{
  my $dir= $config{"absoutputdir"};
  my $datadir;
  my $item;

  eval { File::Path::make_path( $dir ); };
  croak "Cannot create output directory `$dir' - $@" if $@;
  for my $d ("entities", "architectures", "configurations", "packages",
            "sources", "style")
  {
    my $subdir= File::Spec->catdir($dir, $d);
    $config{"datadir"}= $datadir;
    if( opendir(DIR, $subdir) ) {
      closedir DIR;
      next;
    }
    if( open(FILE, $subdir) ) {
      close FILE;
      croak "Cannot create output directory `$subdir' - a file of the same name exists!";
    }
    if( !mkdir($subdir) ) {
      croak "Cannot create output directory `$subdir' - $!";
    }
  }
  my $styledir= File::Spec->catdir($dir, "style");
  if( $^O eq "MSWin32" || $^O eq "MacOS" ) {
    $datadir= $ENV{"VHDOCL_DATADIR"};
  }
  else {
    ($datadir)= grep $_ && -d $_, ($ENV{"VHDOCL_DATADIR"},
                            "/usr/local/share/vhdocl", "/usr/share/vhdocl");
  }
  if( $datadir ) {
    my $styledatadir= File::Spec->catdir($datadir, "style");
    if( ! -d $styledatadir ) {
      print STDERR "Directory `$styledatadir' not found.  Cannot copy style ",
                    "files.  Continuing regardless.\n"
        unless $config{"quiet"};
    }
    else {
      my $copyerr= 0;
      for $item (values %requisites) {
        $copyerr ||= ! copyfile(File::Spec->catfile($styledatadir, $item),
                                    $styledir);
      }
      if( $copyerr && !$config{"quiet"} ) {
        print STDERR "Could not copy all style files.  Continuing regardless.\n";
      }
    }
  }
  else {
    print STDERR <<EOF unless $config{"quiet"};
No data directory found.  Set the environment variable VHDOCL_DATADIR to
indicate its location.  Cannot copy style files.  Continuing regardless.
EOF
  }
  # Now copy all style files not given as URLs
  for $item ("stylesheet", "leftlogo", "rightlogo") {
    if( $config{$item} ) {
      $config{$item."url"}= $config{$item} =~ /^\w+:\/\//;
      if( !$config{$item."url"} ) {
        my $destname= $config{"prefix"} . $item . "." . fileext($config{$item});
        if( ! copyfile($config{$item}, File::Spec->catfile($styledir, $destname)) ) {
          print STDERR "Could not copy `", $config{$item}, "to style",
                    " directory.  Continuing regardless.\n"
            unless $config{"quiet"};
        }
        else {
          $config{$item}= "style/" . $destname;
        }
      }
    }
  }
  if( $config{"toplink"} ) {
    $config{"toplink"} =~ s/^([^|]*)\|//;
    $config{"toplinktext"}= $1 || "Home";
    $config{"toplinkabs"}= $config{"toplink"} =~ /^\w+:\/\// ||
             File::Spec->file_name_is_absolute($config{"toplink"});
    if( $config{"toplinkabs"} && $config{"toplink"} !~ /^\w+:\/\// ) {
      print STDERR "Warning: Absolute top link file name will not be",
                   " portable across systems.\n" unless $config{"quiet"};
    }
    $config{"toplink"}= File::Spec->abs2rel($config{"toplink"}, $dir)
        unless $config{"toplinkabs"};
  }
  else {
    $config{"toplink"}= $config{"prefix"} . "index.html";
    $config{"toplinktext"}= "Home";
    $config{"toplinkabs"}= 0;
    my $fname= $config{"outputdir"} . "/" . $config{"toplink"};
    open INDEX, ">$fname" or croak "Could not create index.html.\n";
    printhtmlheader(*INDEX{IO}, "Home", 1);
    print INDEX "<p></p>\n";
    printhtmlfooter(*INDEX{IO}, 1);
    close INDEX;
  }
  $cp= $config{"cellpadding"};
  $iw= $config{"indentation"};
}


# Print the header of an HTML documentation file
# -> File handle or scalar reference to print to
#    Page title
#    Global page flag, !=0 for entity list, instantiation hierarchy, etc., and
#    0 for documentation of single entity, architecture etc.
sub printhtmlheader
{
  my ($handle, $title, $global)= @_;
  my $prepre= ($global? "": "../");
  my $prefix= $prepre . $config{"prefix"};
  my $top;
  my $doctitle;
  my $stylesheet;
  my $leftlogo;
  my $rightlogo;
  my $toplink;
  my $html;

  $doctitle= length($config{"title"})?
                "\n<center>" . $config{"title"} . "</center><hr>\n" : "";
  $top= $config{"stylesheeturl"}? "" : $prepre;
  $stylesheet= $config{"stylesheet"}? 
                "<link rel=\"stylesheet\" type=\"text/css\" href=\"" . $top .
                $config{"stylesheet"} . "\">" : "";
  $top= $config{"leftlogourl"}? "" : $prepre;
  $leftlogo= $config{"leftlogo"}?
                "<img style=\"vertical-align:middle\" src=\"" . $top .
                $config{"leftlogo"} . "\">" : "";
  $top= $config{"rightlogourl"}? "" : $prepre;
  $rightlogo= $config{"rightlogo"}?
                "<img style=\"vertical-align:middle\" src=\"" . $top .
                $config{"rightlogo"} . "\">" : "";
  $top= $config{"toplinkabs"}? "" : $prepre;
  $toplink= $config{"toplink"}?  "<a href=\"" . $top . $config{"toplink"} .
                "\">" .  $config{"toplinktext"} .
                "</a>\n&nbsp;&nbsp; -- &nbsp;&nbsp;" : "";

  $html= <<EOF;
<html>
<head>
    <title>$title</title>
    $stylesheet
</head>
<body>
$doctitle
<table border="0" width="100%"><tr><td align="left">
$leftlogo
</td><td align="center">
$toplink
<a href="${prefix}entities.html">Entities</a>
&nbsp;&nbsp; -- &nbsp;&nbsp;
<a href="${prefix}packages.html">Packages</a>
&nbsp;&nbsp; -- &nbsp;&nbsp;
<a href="${prefix}instantiations.html">Instantiations</a>
&nbsp;&nbsp; -- &nbsp;&nbsp;
<a href="${prefix}hierarchy.html">Hierarchy</a>
&nbsp;&nbsp; -- &nbsp;&nbsp;
<a href="${prefix}sources.html">Sources</a>
</td><td align="right">
$rightlogo
</td></tr></table>

<hr>

EOF
  if( ref($handle) eq "SCALAR" ) {
    $$handle= $html;
  }
  else {
    print $handle $html;
  }
}


my @monthname= qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );

# Print the footer of a HTML documentation file
# -> File handle to print to
#    Optional flag indicating that the vertical bar should be omitted
sub printhtmlfooter
{
  my ($handle, $nobar)= @_;
  my ($sec,$min,$hour,$mday,$mon,$year)= localtime(time);

  $year += 1900;
  $mon= $monthname[$mon];
  $min= sprintf("%02d", $min);
  $sec= sprintf("%02d", $sec);
  print $handle "\n<hr>\n" unless $nobar;
  print $handle <<EOF

Generated on $mday $mon $year $hour:$min:$sec with <a
href="http://www.volkerschatz.com/hardware/vhdocl.html">VHDocL</a>
V$version

</body>
</html>
EOF
}


# Escape HTML's reserved characters.
# -> Text
# <- Text with &<>" escaped
sub html_esc
{
  my ($string)= @_;

  $string =~ s/&/&amp;/g;
  $string =~ s/</&lt;/g;
  $string =~ s/>/&gt;/g;
  $string =~ s/"/&quot;/g;
  return $string;
}


# Regular expressions for code to mark up with the CSS classes defined at the
# start of this section.
# Strings: \x01 stands for double quotes which are later converted to `&quot;',
# unlike those enclosing the class names.
my $MARKQUOT= qr/(?:\b[box])?\x04[^\x04]*\x04|'[^']'/i;
my $MARKIO= wordregex qw( in out inout buffer linkage );
my $MARKVAR= wordregex qw( constant signal variable file attribute );
# "use" should really also be matched by $MARKDECL, but only for package use
# statements.  We assume these are treated separately and are not piped through
# markvhdl.
my $MARKDECL= wordregex qw( entity architecture configuration package body
function procedure subtype type library component );
my $MARKWORD= wordregex qw( begin pure impure postponed guarded use if then
elsif for generate while until loop next case when group exit block process
array units record with port generic map open null all others range not and
nand or xor xnor mod rem sla sll sra srl ror rol assert report severity 
is return to downto in on of after wait bus new alias
select reject literal register transport inertial unaffected shared disconnect
access label end );
my $MARKIEEE= wordregex qw( integer positive natural boolean true false real
string character time delay_length severity_level note warning error failure
textio line text side width input output readline read writeline write oread
owrite hread hwrite endline bit bit_vector ieee std_logic_1164 std_ulogic
std_ulogic_vector std_logic std_logic_vector x01 x01z ux01 ux01z to_bit
to_bitvector to_stdulogic to_stdulogicvector to_stdlogicvector rising_edge
falling_edge is_x numeric_std numeric_bit signed unsigned to_integer to_signed
to_unsigned shift_left shift_right rotate_left rotate_right resize
std_logic_arith small_int shl shr ext sext conv_integer conv_unsigned
conv_signed conv_std_logic_vector std_logic_misc and_reduce or_reduce
xor_reduce std_logic_unsigned std_logic_signed cond_op cond sh_left sh_right
align_size math_real math_e math_1_e math_pi math_1_pi math_log_of_2
math_log_of_10 math_log2_of_e math_log10_of_e math_sqrt2 math_sqrt1_2
math_sqrt_pi math_deg_to_rad math_rad_to_deg sign ceil floor fmax fmin uniform
srand rand get_rand_max sqrt cbrt exp log sin cos tan asin acos atan atan2 sinh
cosh tanh acosh atanh math_complex complex complex_vector complex_polar cbase_1
cbase_j czero cabs carg cmplx conj csqrt cexp complex_to_polar polar_to_complex
);
my $MARKID= qr/$ID/i;

# Convert VHDL code to HTML with syntax markup expressed in CSS classes.
# -> VHDL-code
# <- HTML with <span> tags of the appropriate classes
sub markvhdl
{
  my ($code)= @_;

  $code =~ tr/&/\x01/;
  $code =~ tr/</\x02/;
  $code =~ tr/>/\x03/;
  $code =~ tr/"/\x04/;
  $code =~ s/(?:($MARKQUOT)|($MARKIO)|($MARKVAR)|($MARKDECL)|
            ($MARKWORD)|($MARKIEEE)|($MARKID))/
            $1 ? "$SPSTR$1$SP_" :
            $2 ? "$SPIO$2$SP_" :
            $3 ? "$SPVA$3$SP_" :
            $4 ? "$SPDCL$4$SP_" :
            $5 ? "$SPWD$5$SP_" :
            $6 ? "$SPIE$6$SP_" :
            $7 ? "$SPID$7$SP_" :
            "" /iexog;
  $code =~ s/\x01/&amp;/g;
  $code =~ s/\x02/&lt;/g;
  $code =~ s/\x03/&gt;/g;
  $code =~ s/\x04/&quot;/g;
  return $code;
}


# Print detailed description of entity etc.  List items starting with @li are
# converted to their HTML equivalent
# -> File handle to print to
#    Reference to array containing paragraphs and list items of description
sub printdescription
{
  my ($handle, $desc)= @_;
  my $listnow= 0;

  for my $line (@$desc)
  {
    if( $line =~ s/^\@li\s*//i ) {
      if( !$listnow ) {
        print $handle "<ul>\n";
        $listnow= 1;
      }
      print $handle "<li>$SPDOC$line$SP_</li>\n";
    }
    else {
      if( $listnow ) {
        print $handle "</ul>\n";
        $listnow= 0;
      }
      print $handle "<p>$SPDOC\n$line\n$SP_</p>\n";
    }
  }
  print $handle "</ul>\n" if $listnow;
}


# Print the common part of a HTML file pertaining to an entity, architecture or
# package, below the header and headline.
# -> File handle to print to
#    Reference to hash representing the entity etc.
sub printobjhtml
{
  my ($handle, $obj)= @_;

  print $handle "<p><b>", $obj->{"doc"}->{"brief"}, "</b></p>\n" 
        if $obj->{"doc"}->{"brief"};
  print $handle "<p><b>", $obj->{"doc"}->{"short"}, "</b></p>\n" 
        if $obj->{"doc"}->{"short"};
  if( $obj->{"filename"} ) {
    print $handle "<p>Defined in ";
    if( $obj->{"file"} ) {
      print $handle "<a href=\"../sources/", $obj->{"file"}->{"docfilename"},
            "\">", $obj->{"filename"}, "</a>&nbsp;&nbsp;&nbsp;<a href=\"",
            ($obj->{"file"}->{"link"} =~ /^\w+:\/\// ? "":"../"),
            $obj->{"file"}->{"link"}, "\">[source file]</a></p>\n";
    }
    else {
      print $handle $obj->{"filename"}, "</p>\n"
    }
  }
  for (qw(synthesis simulation testbench deprecated internal)) {
    print $handle "<h3><b>", ucfirst($_), "</b></h3>\n" if $obj->{"doc"}->{$_};
  }
  print $handle "<p>\n";
  if( $obj->{"doc"}->{"author"} ) {
    $obj->{"doc"}->{"author"} =~ s/,\s*$//;
    print $handle ($obj->{"doc"}->{"author"} =~ /,|;|\band\b/?
                                        "Authors: " : "Author: ");
    print $handle html_esc($obj->{"doc"}->{"author"}), "<br>\n";
  }
  print $handle "Date: ", $obj->{"doc"}->{"date"}, "<br>\n"
        if $obj->{"doc"}->{"date"};
  print $handle "Version: ", html_esc($obj->{"doc"}->{"version"}), "<br>\n"
        if $obj->{"doc"}->{"version"};
  print $handle "ID: ", html_esc($obj->{"doc"}->{"id"}), "<br>\n"
        if $obj->{"doc"}->{"id"};
  print $handle "</p>\n<hr>\n\n";
  if( $obj->{"doc"}->{"description"} && @{$obj->{"doc"}->{"description"}} ) {
    print $handle "<h2>Detailed description</h2>\n\n";
    printdescription($handle, $obj->{"doc"}->{"description"});
  }
  if( $obj->{"doc"}->{"see"} && @{$obj->{"doc"}->{"see"}} ) {
    print $handle "<p>See also: ", join(", ", map( ($_->[2]?
            "<a href=\"" . $_->[2] . "\">" . $_->[0] . "</a>" : $_->[0]),
            @{$obj->{"doc"}->{"see"}})), "</p>\n\n";
  }
  if( $obj->{"attributes"} && keys(%{$obj->{"attributes"}}) ) {
    print $handle "\n<h2>Attributes</h2>\n\n";
    printattrhtml($handle, $obj);
  }
}


my %labels= ( "function" => "func:", "procedure" => "proc:",
            "component" => "comp:", "instance" => "inst:", "type" => "type:" );

# Print HTML fragment describing the libraries and package use clauses
# affecting and object.
# -> File handle to print to
#    Reference to hash representing entity, architecture, configuration,
#    package or package body
sub printlibusehtml
{
  my ($handle, $obj)= @_;
  my (%libs, %uses);        # use hashes to make libs/packages unique

  for (@{$obj->{"file"}->{"children"}}, @{$obj->{"children"}}) {
    if( $_->{"type"} eq "library" ) {
      $libs{lc($_->{"name"})}= $_;
    }
    elsif( $_->{"type"} eq "use" && $_->{"subtype"} eq "package" ) {
      $uses{lc($_->{"name"})}= $_;
    }
  }
  return unless keys(%libs) || keys(%uses);
  print $handle "\n<h2>Libraries and global use clauses</h2>\n\n",
                    "<table border=\"0\" cellpadding=\"$cp\">\n";
  my @sortuses= sort keys %uses;
  for my $lib (sort keys %libs) {
    my $markedname= markvhdl($libs{$lib}->{"name"});
    print $handle "<tr$CCO><td colspan=\"2\"><b>${SPDCL}library$SP_ ",
                  $markedname, "</b></td></tr>\n";
    map { print $handle "<tr><td width=\"$iw\"></td><td>$SPDOC$_$SP_</td></tr>\n"; }
                          @{$libs{$lib}->{"doc"}->{"description"}};
    for my $usename (grep $_ =~ /^$lib\b/, @sortuses) {
      printusehtml($handle, $uses{$usename});
      delete $uses{$usename};
    }
  }
  for my $usename (sort keys %uses) {
    printusehtml($handle, $uses{$usename});
  }
  print $handle "</table>\n\n";
}


# Print HTML fragment describing a package use clause
# -> File handle to print to
#    Reference to hash representing use clause
sub printusehtml
{
  my ($handle, $use)= @_;
  my $markedname= markvhdl($use->{"name"});

  if( $use->{"object"} && (my $link= $use->{"object"}->{"doclink"}) ) {
    print $handle "<tr$CCO><td colspan=\"2\">${SPDCL}use$SP_ <a href=\"$link\">",
                  $markedname, "</a></td></tr>\n";
  }
  elsif( $use->{"package"} ) {
    print $handle "<tr$CCO><td colspan=\"2\">${SPDCL}use$SP_ ",
              "<a href=\"../packages/", $use->{"package"}->{"docfilename"},
              "\">", $markedname, "</a></td></tr>\n";
  }
  else {
    print $handle "<tr$CCO><td colspan=\"2\">${SPDCL}use$SP_ ", $markedname,
                  "</td></tr>\n";
  }
  map { print $handle "<tr><td width=\"$iw\"></td><td>$SPDOC$_$SP_</td></tr>\n"; }
                        @{$use->{"doc"}->{"description"}};
}


# Print HTML fragment describing a generic, port or constant
# -> File handle to print to
#    Reference to hash representing the generic/port/...
sub printgenporthtml
{
  my ($handle, $gp)= @_;

  print $handle "<tr$CCO><td align=\"left\"><b>$SPTID", $gp->{"name"},
                "$SP_</b></td>\n";
  print $handle "<td align=\"center\"><i><b>$SPIO", $gp->{"direction"}, 
                "$SP_</b></i></td>" if $gp->{"direction"};
  print $handle "<td align=\"left\">", markvhdl($gp->{"subtype"}), "</td>\n";
  print $handle "<td align=\"left\">:= ", markvhdl($gp->{"value"}), "</td>\n"
        if $gp->{"value"};
  print $handle "</tr>\n";
  map { print $handle "<tr><td></td><td align=\"left\" colspan=\"3\">$SPDOC$_",
                      "$SP_</td></tr>\n" }
                        @{$gp->{"doc"}->{"description"}};
}


my $enthtmlerr= 0;

# Write the HTML documentation for an entity
# -> Reference to hash representing entity
sub entityhtml
{
  my ($ent)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"}, "entities",
                                 $ent->{"docfilename"});

  if( !open(ENT, ">$fname") ) {
    limitfileerr("Cannot create output file $fname", \$enthtmlerr);
    return;
  }
  printhtmlheader(*ENT{IO}, $ent->{"fullname"});
  print ENT "\n<h1>Entity ", $ent->{"fullname"}, "</h1>\n";
  printobjhtml(*ENT{IO}, $ent);
  printlibusehtml(*ENT{IO}, $ent);
  if( my @gens= @{$ent->{"childtype"}->{"generic"} || []} ) {
    print ENT "\n<h2>Generics</h2>\n\n<table border=\"0\" cellpadding=\"$cp\">\n";
    map { printgenporthtml(*ENT{IO}, $_) } @gens;
    print ENT "</table>\n\n";
  }
  if( my @ports= @{$ent->{"childtype"}->{"port"} || []} ) {
    print ENT "\n<h2>Ports</h2>\n\n<table border=\"0\" cellpadding=\"$cp\">\n";
    map { printgenporthtml(*ENT{IO}, $_) } @ports;
    print ENT "</table>\n\n";
  }
  if( @{$ent->{"architectures"}} ) {
    print ENT "\n<h2>Architectures</h2>\n\n",
                "<table border=\"0\" cellpadding=\"$cp\">\n";
    map { print ENT "<tr><td><a href=\"../architectures/",
            $_->{"docfilename"}, "\">", $_->{"name"}, "</a></td></tr>\n"; }
            @{$ent->{"architectures"}};
    print ENT "</table>\n\n";
  }
  else {
    print ENT "\n<h2>No architectures found</h2>\n\n";
  }
  if( @{$ent->{"configurations"}} ) {
    print ENT "\n<h2>Configurations</h2>\n\n",
                "<table border=\"0\" cellpadding=\"$cp\">\n";
    map { print ENT "<tr><td><a href=\"../configurations/",
            $_->{"docfilename"}, "\">", $_->{"name"}, "</a></td></tr>\n"; }
            @{$ent->{"configurations"}};
    print ENT "</table>\n\n";
  }
  printhtmlfooter(*ENT{IO});
  close ENT;
}


# Print description and attributes of component, instance, process, procedure
# or function
# -> File handle to print to
#    Reference to hash representing object
sub printcommonhtml
{
  my ($handle, $obj)= @_;
  my $ind= "<td width=\"$iw\"></td>";

  map { print $handle "<tr>$ind<td colspan=\"4\">$SPDOC$_$SP_</td></tr>\n" }
                        @{$obj->{"doc"}->{"description"}};
  if( $obj->{"attributes"} && keys(%{$obj->{"attributes"}}) ) {
    print $handle "<tr>$ind<td colspan=\"4\">Attributes:</td></tr>\n",
                  "<tr>$ind$ind<td colspan=\"3\">";
    printattrhtml($handle, $obj);
    print $handle "</td></tr>\n";
  }
}


# Print HTML table describing an object's attributes and their descriptions
# -> File handle to print to
#    Reference to hash describing the object
sub printattrhtml
{
  my ($handle, $obj)= @_;
  my $ind= "<td width=\"$iw\"></td>";

  return unless $obj->{"attributes"} && keys(%{$obj->{"attributes"}});
  print $handle "<table border=\"0\" cellpadding=\"$cp\">\n";
  for my $attrname (keys %{$obj->{"attributes"}}) {
    my $aspec= $obj->{"attributes"}->{$attrname};
    my $attr= $aspec->{"attribute"};
    print $handle "<tr$CCO><td><b>$SPID", $aspec->{"name"},
                "$SP_</b></td><td> : ",
                ($attr->{"subtype"} || "<i>${SPNC}unknown type$SP_</i>"), 
                "</td><td> := ", markvhdl($aspec->{"value"}), "</td></tr>\n";
    if( $attr->{"doc"}->{"description"} &&
                              @{$attr->{"doc"}->{"description"}} ) {
      map { print $handle "<tr>$ind<td colspan=\"2\">$SPDOC$_$SP_</td></tr>\n" }
                @{$attr->{"doc"}->{"description"}};
    }
    if( $aspec->{"doc"}->{"description"} &&
                              @{$aspec->{"doc"}->{"description"}} ) {
      map { print $handle "<tr>$ind<td colspan=\"2\">$SPDOC$_$SP_</td></tr>\n" }
                @{$aspec->{"doc"}->{"description"}};
    }
  }
  print $handle "</table>\n";
}


# Print HTML fragment describing a component declaration
# -> File handle to print to
#    Reference to hash representing the component declaration
sub printcomphtml
{
  my ($handle, $comp)= @_;
  my $ind= "<td width=\"$iw\"></td>";

  print $handle "<tr$CCO><td colspan=\"5\"><b><a name=\"",
                $labels{"component"}, $comp->{"name"}, "\">$SPTID",
                $comp->{"name"}, "$SP_</a></b></td></tr>\n";
  printcommonhtml($handle, $comp);
  print $handle "<tr>$ind<td colspan=\"4\">",
                "Default binding: $SPCO<a href=\"../entities/",
                $comp->{"binding"}->{"docfilename"}, "\">$SPID", 
                $comp->{"binding"}->{"fullname"}, "$SP_</a>$SP_</td></tr>\n"
        if $comp->{"binding"};
}


# Print HTML fragment describing all function and procedure declarations of a
# library unit, in the order in which they appear in the source.
# -> File handle to print to
#    Reference to hash representing the top-level declaration (library unit)
sub printfuncprochtml
{
  my ($handle, $obj)= @_;
  my @funcprocs;
  my @headwords;
  my $headline;

  @funcprocs= @{$obj->{"childtype"}->{"funcproc"} || []};
  return unless @funcprocs;
  push @headwords, "functions" if $obj->{"childtype"}->{"function"} &&
                                 @{$obj->{"childtype"}->{"function"}};
  push @headwords, "procedures" if $obj->{"childtype"}->{"procedure"} &&
                                  @{$obj->{"childtype"}->{"procedure"}};
  $headline= ucfirst join " and ", @headwords;
  print $handle "\n<h2>$headline</h2>\n\n<table border=\"0\" cellpadding=\"$cp\">\n";
  map { printfunchtml($handle, $_) } @funcprocs;
  print $handle "</table>\n\n";
}


# Print HTML fragment describing a function or procedure declaration
# -> File handle to print to
#    Reference to hash representing the function/procedure
sub printfunchtml
{
  my ($handle, $func)= @_;
  my $ind= "<td width=\"$iw\"></td>";
  my $label= $labels{$func->{"type"}} . $func->{"name"};
  my $arglist= $func->{"parlist"} ?
                " (" . markvhdl($func->{"parlist"}) . ")" : "";

  print $handle "<tr$CCO><td colspan=\"5\">$SPWD", $func->{"type"},
                "$SP_ <b><a name=\"$label\">$SPTID",
                $func->{"name"}, "$SP_</a></b>", $arglist,
                ($func->{"subtype"}? " ${SPWD}return$SP_ " .
                                markvhdl($func->{"subtype"}) : ""),
        "</td></tr>\n";
  print $handle "<tr$CCO>$ind<td colspan=\"4\"><b>${SPWD}impure$SP_</b></td></tr>\n"
        if $func->{"pure"} && $func->{"pure"} eq "impure";
  printcommonhtml($handle, $func);
}


# Print HTML fragment describing a type declaration
# -> File handle to print to
#    Reference to hash describing the type declaration
sub printtypehtml
{
  my ($handle, $type)= @_;

  print $handle "<tr$CCO><td>$SPDCL", ($type->{"sub"}? "subtype": "type"),
                "$SP_</td><td><b>$SPTID", $type->{"name"}, "$SP_</b></td>",
                "<td>${SPWD}is$SP_</td>\n<td>";
  if( $type->{"type"} eq "type" ) {
    print $handle markvhdl($type->{"subtype"}), "</td></tr>\n";
  }
  elsif( $type->{"type"} eq "record" ) {
    print $handle "${SPWD}record$SP_...</td></tr>\n";
  }
  elsif( $type->{"type"} eq "units" ) {
    print $handle markvhdl($type->{"subtype"}), " ${SPWD}units$SP_ $SPID",
                  $type->{"baseunit"}, "$SP_</td></tr>\n";
  }
  elsif( $type->{"type"} =~ /^protected/i ) {
    print $handle "${SPWD}protected$SP_...</td></tr>\n";
  }
  else {
    print $handle "???</td></tr>\n";
  }
  map { print $handle "<tr><td></td><td colspan=\"3\">$SPDOC$_$SP_</td></tr>\n"; }
                        @{$type->{"doc"}->{"description"}};
}


# Print HTML fragment describing one of the constructs surrounding a process or
# instantiation
# -> File handle to print to
#    Reference to hash representing declarative item (usually a generate or
#    block statement)
sub printtracehtml
{
  my ($handle, $trc)= @_;
  my $ind= "<td width=\"$iw\"></td>";

  if( $trc->{"type"} eq "generate" ) {
    print $handle "<tr$CCO>$ind$ind<td colspan=\"3\"><b>$SPID", $trc->{"name"},
        "$SP_</b> : $SPWD", $trc->{"subtype"}, "$SP_ ",
        markvhdl($trc->{"parameters"}), " ${SPWD}generate$SP_</td></tr>\n";
  }
  elsif( $trc->{"type"} eq "block" ) {
    my $guard= $trc->{"guard"} ? "( " . markvhdl($trc->{"guard"}) . " )" : "";
    print $handle "<tr$CCO>$ind$ind<td colspan=\"3\"><b>$SPID", $trc->{"name"},
        "$SP_</b> : ${SPWD}block$SP_ ", $guard, "</td></tr>\n";
  }
  else {
    print $handle "<tr$CCO>$ind$ind<td colspan=\"3\">$SPWD", $trc->{"type"},
               "$SP_ <b>", ($trc->{"name"} ? $SPID.$trc->{"name"}.$SP_ :
                                            "<i>${SPNC}unnamed$SP_</i>"),
               "</b></td></tr>\n";
  }
  map { print $handle "<tr>$ind$ind$ind<td colspan=\"2\">$SPDOC$_$SP_</td></tr>\n" }
                        @{$trc->{"doc"}->{"description"}};
}


# Print HTML fragment describing a process
# -> File handle to print to
#    Reference to array containing the path to the process
sub printprochtml
{
  my ($handle, $path)= @_;
  my $proc= $$path[$#$path];
  my $ind= "<td width=\"$iw\"></td>";

  print $handle "<tr$CCO><td colspan=\"5\"><b>", ($proc->{"name"} ?
            $SPTID.$proc->{"name"}.$SP_ : "<i>${SPNC}unnamed$SP_</i>"), "</b>",
  ($proc->{"sensitivity"}? " (" . markvhdl($proc->{"sensitivity"}) . ")" : ""), 
          "</td></tr>\n";
  print $handle "<tr$CCO>$ind<td colspan=\"4\"><b>${SPWD}postponed$SP_</b></td></tr>\n"
        if $proc->{"postponed"};
  printcommonhtml($handle, $proc);
  if( $#$path ) {
    print $handle "<tr>$ind<td colspan=\"4\">This process is inside the " .
                "following construct", ($#$path>1? "s":""), ":</td></tr>\n";
    map printtracehtml($handle, $_), @$path[0..$#$path-1];
  }
}



# Print HTML fragment describing an instantiation
# -> File handle to print to
#    Reference to array containing the path to the instance
sub printinsthtml
{
  my ($handle, $path)= @_;
  my $inst= $$path[$#$path];
  my $ind= "<td width=\"$iw\"></td>";

  print $handle "<tr$CCO><td colspan=\"5\"><b><a name=\"", $labels{"instance"},
              $inst->{"name"}, "\">$SPTID", $inst->{"name"}, "$SP_</a></b> : ";
  if( $inst->{"subtype"} eq "configuration" ) {
    print $handle "${SPWD}configuration$SP_ ";
    if( $inst->{"binding"} ) {
      print $handle "<a href=\"../configurations/",
                $inst->{"binding"}->{"docfilename"}, "\">$SPID",
                $inst->{"objname"}, "$SP_</a></td></tr>\n";
    }
    else {
      print $handle $SPID, $inst->{"objname"}, "$SP_</td></tr>\n";
    }
  }
  elsif( $inst->{"subtype"} eq "entity" ) {
    print $handle "${SPDCL}entity$SP_ ";
    if( $inst->{"binding"} ) {
      print $handle "<a href=\"../entities/",
                $inst->{"binding"}->{"docfilename"}, "\">$SPID",
                $inst->{"objname"}, "$SP_</a>";
    }
    else {
      print $handle $inst->{"objname"};
    }
    if( $inst->{"bindarch"} ) {
      print $handle " (<a href=\"../architectures/",
                    $inst->{"bindarch"}->{"docfilename"}, "\">$SPID",
                    $inst->{"archname"}, "$SP_</a>)";
    }
    elsif( $inst->{"archname"} ) {
      print $handle " ($SPID", $inst->{"archname"}, "$SP_)";
    }
    print $handle "</td></tr>\n";
  }
  elsif( $inst->{"component"} ) {
    print $handle "<a href=\"", $inst->{"component"}->{"doclink"}, "\">$SPID",
                  $inst->{"objname"}, "$SP_</a></td></tr>\n";
  }
  else {
    print $handle $SPID, $inst->{"objname"}, "$SP_</td></tr>\n";
  }
  printcommonhtml($handle, $inst);
  if( $inst->{"genericmap"} && @{$inst->{"genericmap"}} ) {
    my @gmap= @{$inst->{"genericmap"}};
    print $handle "<tr>$ind<td colspan=\"4\">Generic map:</td></tr>\n",
                  "<tr>$ind$ind<td colspan=\"3\"><table border=\"0\"$CCO>\n";
    map { print $handle "  <tr><td>$SPID", $$_[0], "$SP_</td><td> => ",
                              markvhdl($$_[1]), "</td></tr>\n"; } @gmap;
    print $handle "</table></td></tr>\n";
  }
  # Now for explicit binding of component instances
  if( $inst->{"subtype"} eq "component" &&
      ((my $bind= $inst->{"binding"}) || $inst->{"bindname"}) ) {
    if( $bind ) {
      print $handle "<tr>$ind<td colspan=\"4\">Binding: $SPCO<a href=\"",
      ($bind->{"type"} eq "entity" ?  "../entities/" : "../configurations/"),
          $bind->{"docfilename"}, "\">$SPID", $bind->{"fullname"},
          "$SP_</a>";
    }
    else {
      print $handle "<tr>$ind<td colspan=\"4\">Binding: $SPCO$SPID",
                      $inst->{"bindname"}, "$SP_";
    }
    if( $inst->{"archname"} ) {
      if( $inst->{"bindarch"} ) {
        print $handle " (<a href=\"../architectures/",
                      $inst->{"bindarch"}->{"docfilename"}, "\">$SPID",
                      $inst->{"archname"}, "$SP_</a>)";
      }
      else {
        print $handle " ($SPID", $inst->{"archname"}, "$SP_)";
      }
    }
    print $handle "$SP_</td></tr>\n";
    map { print $handle "<tr>$ind$ind<td colspan=\"3\">$SPDOC$_$SP_</td></tr>\n" }
                        @{$inst->{"binddoc"}};
    if( $inst->{"bindgen"} ) {
      my $map= $inst->{"bindgen"}->{"map"};
      print $handle "<tr>$ind$ind<td colspan=\"3\">Generic map:</td></tr>\n",
                "<tr>$ind$ind$ind<td colspan=\"2\"><table border=\"0\"$CCO>\n";
      map { print $handle "  <tr><td>$SPID", $$_[0], "$SP_</td><td> => ",
                                markvhdl($$_[1]), "</td></tr>\n"; } @$map;
      print $handle "</table></td></tr>\n";
    }
  }
  if( $#$path ) {
    print $handle "<tr>$ind<td colspan=\"4\">This instantiation is inside the "
                . "following construct", ($#$path>1? "s":""), ":</td></tr>\n";
    map printtracehtml($handle, $_), @$path[0..$#$path-1];
  }
}


my $archhtmlerr= 0;

# Write the HTML documentation for an architecture
# -> Reference to hash representing architecture
sub architecturehtml
{
  my ($arch)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"}, "architectures",
                                 $arch->{"docfilename"});
  my $ent= $arch->{"entity"};
  my $headname= $arch->{"name"} . " of " . $arch->{"objname"};

  if( !open(ARCH, ">$fname") ) {
    limitfileerr("Cannot create output file $fname", \$archhtmlerr);
    return;
  }
  printhtmlheader(*ARCH{IO}, $headname);
  if( $ent ) {
    print ARCH "\n<h1>Architecture ", $arch->{"name"}, 
          " of <a href=\"../entities/", $ent->{"docfilename"},
          "\">", $ent->{"fullname"}, "</a></h1>\n\n";
  }
  else {
    print ARCH "\n<h1>Architecture ", $arch->{"name"}, " of ", 
          $arch->{"objname"}, "</a></h1>\n\n";
  }
  printobjhtml(*ARCH{IO}, $arch);
  printlibusehtml(*ARCH{IO}, $arch);
  if( my @types= grep($_->{"type"} =~ /^(?:type|subtype|record|units|protected|
                        protectedbody)$/ix, @{$arch->{"children"}}) ) {
    print ARCH "\n<h2>Type declarations</h2>\n\n<table border=\"0\" cellpadding=\"$cp\">\n";
    map { printtypehtml(*ARCH{IO}, $_) } @types;
    print ARCH "</table>\n\n";
  }
  if( my @consts= @{$arch->{"childtype"}->{"constant"} || []} ) {
    print ARCH "\n<h2>Constants</h2>\n\n<table border=\"0\" cellpadding=\"$cp\">\n";
    map { printgenporthtml(*ARCH{IO}, $_) } @consts;
    print ARCH "</table>\n\n";
  }
  printfuncprochtml(*ARCH{IO}, $arch);
  if( my @comps= @{$arch->{"childtype"}->{"component"} || []} ) {
    print ARCH "\n<h2>Component declarations</h2>\n\n<table border=\"0\" " .
                "cellpadding=\"$cp\">\n";
    map { printcomphtml(*ARCH{IO}, $_) } @comps;
    print ARCH "</table>\n\n";
  }
  if( my @procs= trace_all($arch, "type", "process") ) {
    print ARCH "\n<h2>Processes</h2>\n\n<table border=\"0\" " .
                "cellpadding=\"$cp\">\n";
    map { printprochtml(*ARCH{IO}, $_) } @procs;
    print ARCH "</table>\n\n";
  }
  if( my @insts= trace_all($arch, "type", "instance") ) {
    print ARCH "\n<h2>Instantiations</h2>\n\n<table border=\"0\" " .
                "cellpadding=\"$cp\">\n";
    map { printinsthtml(*ARCH{IO}, $_) } @insts;
    print ARCH "</table>\n\n";
  }
  printhtmlfooter(*ARCH{IO});
  close ARCH;
}


# Prints one level of the hierarchy of for...use statements in a configuration
# and recursively calls itself to print the deeper levels
# -> File handle to print to
#    Reference to array of references to hashes representing for statements at
#    the same level
#    Current depth in the hierarchy (for indentation)
#    Maximal depth (for colspan attribute of <td> tag)
sub printconfightml
{
  my ($handle, $fors, $curdepth, $maxdepth)= @_;
  my $ind1= "<td width=\"$iw\"></td>";
  my $ind= $ind1 x $curdepth;
  my $span= $maxdepth - $curdepth + 3;

  for my $for (@$fors) {
    print $handle "<tr$CCO>$ind<td colspan=\"", $span, "\">${SPWD}for$SP_ <b>";
    if( $for->{"subtype"} eq "architecture" ) {
      if( $for->{"object"} && $for->{"object"}->{"type"} eq "architecture" ) {
        print $handle "<a href=\"../architectures/",
                $for->{"object"}->{"docfilename"}, "\">$SPID",
                $for->{"objname"}, "$SP_</a></b></td></tr>\n";
      }
      else {
        print $handle $SPID, $for->{"objname"}, "$SP_</b></td></tr>\n";
      }
      map { print $handle "<tr>$ind$ind1<td colspan=\"", $span-1, "\">$SPDOC",
                   "$_$SP_</td></tr>\n" }    @{$for->{"doc"}->{"description"}};
    }
    else {
      my $comp;
      my $use;
      if( @{$for->{"objnames"}}==1 && ($for->{"objnames"}->[0] eq "all" ||
                                $for->{"objnames"}->[0] eq "others") ) {
        print $handle $SPWD, $for->{"objnames"}->[0], $SP_;
        $comp= $for->{"objects"}->[0]->{"component"}
                if $for->{"objects"} && @{$for->{"objects"}};
      }
      elsif( $for->{"objects"} && @{$for->{"objects"}} ) {
        print $handle join("</b>, <b>", map("<a href=\"" . $_->{"doclink"} .
              "\">$SPID" . $_->{"name"} . "$SP_</a>", @{$for->{"objects"}}));
        $comp= $for->{"objects"}->[0]->{"component"};
      }
      else {
        print $handle $SPID, join("$SP_</b>, <b>$SPID", @{$for->{"objnames"}}),
                      $SP_;
      }
      if( $comp ) {
        print $handle "</b> : <a href=\"", $comp->{"doclink"}, "\">$SPID",
                      $for->{"objtype"}, "$SP_</a>";
      }
      else {
        print $handle "</b> : $SPID", $for->{"objtype"}, $SP_;
      }
      if( $use= $for->{"use"} ) {
        if( $for->{"binding"} ) {
          print $handle " ${SPWD}use$SP_ $SPDCL", $use->{"subtype"},
                "$SP_ <a href=\"../",
              ($use->{"subtype"} eq "entity"? "entities/" : "configurations/"),
                $for->{"binding"}->{"docfilename"}, "\">$SPID", $use->{"name"},
                "$SP_</a>";
          if( $for->{"bindarch"} ) {
            print $handle " (<a href=\"../architectures/",
                          $for->{"bindarch"}->{"docfilename"}, "\">$SPID",
                          $for->{"archname"}, "$SP_</a>)</td>$SP_</tr>\n";
          }
          elsif( $use->{"archname"} ) {
           print $handle " ($SPID", $use->{"archname"}, "$SP_)</td>$SP_</tr>\n";
          }
        }
        else {
          print $handle " use ", $use->{"subtype"}, " ", $use->{"name"},
            ($use->{"archname"}? "($SPID" . $use->{"archname"} . "$SP_)" : ""),
                "</td>$SP_</tr>\n";
        }
      }
      else {
        print $handle "</td>$SP_</tr>\n";
      }
      map { print $handle "<tr>$ind$ind1<td colspan=\"", $span-1, "\">$SPDOC",
                   "$_$SP_</td></tr>\n" }    @{$for->{"doc"}->{"description"}};
      map { print $handle "<tr>$ind$ind1<td colspan=\"", $span-1, "\">$SPDOC",
           "$_$SP_</td></tr>\n" }    @{$for->{"use"}->{"doc"}->{"description"}};
      if( $for->{"bindgen"} ) {
        my $map= $for->{"bindgen"}->{"map"};
        print $handle "<tr>$ind$ind1<td colspan=\"", $span-1,
                "\">Generic map:</td></tr>\n<tr>$ind$ind1$ind1<td colspan=\"",
                $span-2, "\"><table border=\"0\"$CCO>\n";
        map { print $handle "  <tr><td>$SPID", $$_[0], "$SP_</td><td> => ",
                                  markvhdl($$_[1]), "</td></tr>\n"; } @$map;
        print $handle "</table></td></tr>\n";
      }
    }
    my @nextfors= find_children($for, "type", "for");
    printconfightml($handle, \@nextfors, $curdepth+1, $maxdepth);
  }
}


my $confhtmlerr= 0;

# Write the HTML documentation for a configuration
# -> Reference to hash representing configuration
sub configurationhtml
{
  my ($conf)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"}, "configurations",
                                 $conf->{"docfilename"});
  my $ent= $conf->{"entity"};
  my $headname= $conf->{"name"} . " of " . $conf->{"objname"};
  my $maxdepth;
  my @topfors;

  if( !open(CONF, ">$fname") ) {
    limitfileerr("Cannot create output file $fname", \$confhtmlerr);
    return;
  }
  printhtmlheader(*CONF{IO}, $headname);
  if( $ent ) {
    print CONF "\n<h1>Configuration ", $conf->{"name"}, 
          " of <a href=\"../entities/", $ent->{"docfilename"},
          "\">", $ent->{"fullname"}, "</a></h1>\n\n";
  }
  else {
    print CONF "\n<h1>Configuration ", $conf->{"name"}, " of ", 
          $conf->{"objname"}, "</a></h1>\n\n";
  }
  printobjhtml(*CONF{IO}, $conf);
  printlibusehtml(*CONF{IO}, $conf);
  print CONF "\n<h2>Configuration</h2>\n\n<table border=\"0\" ",
                "cellpadding=\"$cp\">\n";
  $maxdepth= max_depth($conf);
  @topfors= @{$conf->{"childtype"}->{"for"} || []};
  printconfightml(*CONF{IO}, \@topfors, 0, $maxdepth);
  print CONF "</table>\n";
  printhtmlfooter(*CONF{IO});
  close CONF;
}


my $packhtmlerr= 0;

# Write the HTML documentation for a package or orphaned package body.  The
# documentation of functions and procedures in a package and the corresponding
# package body are concatenated and printed in the documentation of the package
# only.  To this end, the duplicate functions/procedures are removed from the
# package body hash, and their the documentation in the package is modified.
# If no declarations specific to the package body remain to be documented, the
# section about the package body is left out.
# -> Reference to hash representing package or package body
sub packagehtml
{
  my ($pack)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"}, "packages",
                                 $pack->{"docfilename"});
  my $pbody;

  if( !open(PACK, ">$fname") ) {
    limitfileerr("Cannot create output file $fname", \$packhtmlerr);
    return;
  }
  printhtmlheader(*PACK{IO}, $pack->{"fullname"});
  if( $pack->{"type"} eq "package" ) {
    $pbody= $pack->{"packagebody"};
    if( $pbody ) {
      my ($pbfuncs, $pbprocs, $pbfuncprocs);
      for my $f (@{$pbody->{"childtype"}->{"function"}}) {
        my $el= elem { packsubeq($_, $f) } @{$pack->{"childtype"}->{"function"}};
        if( $el ) {
          push @{$el->{"doc"}->{"description"}},
                    @{$f->{"doc"}->{"description"} || []};
        }
        else {
          push @$pbfuncs, $f
        }
      }
      for my $p (@{$pbody->{"childtype"}->{"procedure"}}) {
        my $el= elem { packsubeq($_, $p) } @{$pack->{"childtype"}->{"procedure"}};
        if( $el ) {
          push @{$el->{"doc"}->{"description"}},
                    @{$p->{"doc"}->{"description"} || []};
        }
        else {
          push @$pbprocs, $p;
        }
      }
      # Can't just concatenate ->{"function"} and ->{"procedure"} because we
      # want to preserve order
      for my $f (@{$pbody->{"childtype"}->{"funcproc"}}) {
        push @$pbfuncprocs, $f if elem { $_ == $f } (@$pbfuncs, @$pbprocs);
      }
      @{$pbody->{"childtype"}}{qw(function procedure funcproc)}=
                                      ($pbfuncs, $pbprocs, $pbfuncprocs);
    }
    print PACK "<h1>Package ", $pack->{"fullname"}, "</h1>\n\n";
    printobjhtml(*PACK{IO}, $pack);
    printlibusehtml(*PACK{IO}, $pack);
    if( my @types= grep($_->{"type"} =~ /^(?:type|subtype|record|units|
                      protected|protectedbody)$/ix, @{$pack->{"children"}}) ) {
      print PACK "\n<h2>Type declarations</h2>\n\n<table border=\"0\" cellpadding=\"$cp\">\n";
      map { printtypehtml(*PACK{IO}, $_) } @types;
      print PACK "</table>\n\n";
    }
    if( my @consts= @{$pack->{"childtype"}->{"constant"} || []} ) {
      print PACK "\n<h2>Constants</h2>\n\n<table border=\"0\" cellpadding=\"$cp\">\n";
      map { printgenporthtml(*PACK{IO}, $_) } @consts;
      print PACK "</table>\n\n";
    }
    printfuncprochtml(*PACK{IO}, $pack);
    if( my @comps= @{$pack->{"childtype"}->{"component"} || []} ) {
      print PACK "\n<h2>Component declarations</h2>\n\n<table border=\"0\" " .
                  "cellpadding=\"$cp\">\n";
      map { printcomphtml(*PACK{IO}, $_) } @comps;
      print PACK "</table>\n\n";
    }
    unless( $pbody ) {
      printhtmlfooter(*PACK{IO});
      close PACK;
      return;
    }
    print PACK "\n\n<hr>\n\n";
  }
  else {
    $pbody= $pack;
    $pack= undef;
  }
  unless( elem { $_->{"type"} =~ /^(?:type|subtype|record|units|protected|
   protectedbody|constant|function|procedure)$/ix } @{$pbody->{"children"}} ) {
    printhtmlfooter(*PACK{IO});
    close PACK;
    return;
  }
  print PACK "<h1>Package body ", $pbody->{"fullname"}, "</h1>\n\n";
  printobjhtml(*PACK{IO}, $pbody);
  printlibusehtml(*PACK{IO}, $pbody);
  if( my @types= grep($_->{"type"} =~ /^(?:type|subtype|record|units|protected|
                        protectedbody)$/ix, @{$pbody->{"children"}}) ) {
    print PACK "\n<h2>Type declarations</h2>\n\n<table border=\"0\" cellpadding=\"$cp\">\n";
    map { printtypehtml(*PACK{IO}, $_) } @types;
    print PACK "</table>\n\n";
  }
  if( my @consts= @{$pbody->{"childtype"}->{"constant"} || []} ) {
    print PACK "\n<h2>Constants</h2>\n\n<table border=\"0\" cellpadding=\"$cp\">\n";
    map { printgenporthtml(*PACK{IO}, $_) } @consts;
    print PACK "</table>\n\n";
  }
  printfuncprochtml(*PACK{IO}, $pbody);
  printhtmlfooter(*PACK{IO});
  close PACK;
}


my $sourcehtmlerr= 0;

# Generate the HTML page for a source file.
# -> Reference to hash representing the VHDL file
sub sourcehtml
{
  my ($file)= @_;
  my $srcfname= $file->{"name"};
  my $outfname= File::Spec->catfile($config{"outputdir"}, "sources",
                                    $file->{"docfilename"});
  my $header;

  if( !open(VHDL, $srcfname) ) {
    limitfileerr("Cannot open source file $srcfname for generating source HTML file", \$sourcehtmlerr);
    return;
  }
  if( !open(SRCHTML, ">$outfname") ) {
    limitfileerr("Cannot create output file $outfname", \$sourcehtmlerr);
    close VHDL;
    return;
  }
  printhtmlheader(\$header, $file->{"name"});
  $header =~ s!(?=</head>)!<<EOF!ie;
    <script type="text/javascript" src="../style/$requisites{synjava1}"></script>
    <script type="text/javascript" src="../style/$requisites{synjava2}"></script>
    <link type="text/css" rel="stylesheet" href="../style/$requisites{synstyle1}">
    <link type="text/css" rel="stylesheet" href="../style/$requisites{synstyle2}">
    <script type="text/javascript">SyntaxHighlighter.all();</script>
EOF
  print SRCHTML $header;
  print SRCHTML "\n<h1>Source file ", $file->{"name"}, "</h1>\n";
  print SRCHTML "\n<p><a href=\"", ($file->{"link"} =~ /^\w+:\/\// ? "":"../"),
                                $file->{"link"}, "\">Link to file</a></p>\n";
  print SRCHTML "<pre class=\"brush: vhdl;\">\n";
  while( <VHDL> )
  {
    s/&/&amp;/g;
    s/"/&quot;/g;
    s/</&lt;/g;
    s/>/&gt;/g;
    print SRCHTML $_;
  }
  print SRCHTML "</pre>\n";
  printhtmlfooter(*SRCHTML{IO});
  close SRCHTML;
  close VHDL;
}


# Generate the HTML page listing entities, architectures and configurations
# -> Reference to array of hash references representing entities
#    Reference to array of hash references representing architectures not
#    associated with any entity (known to us)
#    Reference to array of hash references representing configurations not
#    associated with any entity (known to us)
#    Flag indicating that there are configurations at all
sub entitylisthtml
{
  my ($ents, $oarchs, $oconfs, $haveconfs)= @_;
  my @list;
  my $fname= File::Spec->catfile($config{"outputdir"},
                                $config{"prefix"} . "entities.html");
  my $ind= "<td width=\"$iw\"></td>";

  if( !open(LIST, ">$fname") ) {
    print STDERR "Cannot create output file $fname - $!\n";
    return;
  }
  for my $oa (@$oarchs) {
    if( my ($elem)= grep(lc($_->{"name"}) eq lc($oa->{"objname"}), @list) ) {
      push @{$elem->{"architectures"}}, $oa;
    }
    else {
      push @list, { "name", $oa->{"objname"}, "architectures", [ $oa ] };
    }
  }
  for my $oc (@$oconfs) {
    if( my ($elem)= grep(lc($_->{"name"}) eq lc($oc->{"objname"}), @list) ) {
      push @{$elem->{"configurations"}}, $oc;
    }
    else {
      push @list, { "name", $oc->{"objname"}, "configurations", [ $oc ] };
    }
  }
  push @list, (map { "name", $_->{"fullname"}, "entity", $_, 
                     "architectures", $_->{"architectures"},
                     "configurations", $_->{"configurations"} }, @$ents);
  @list= sort { $a->{"name"} cmp $b->{"name"} } @list;
  printhtmlheader(*LIST{IO}, "Entities, Architectures and Configurations", 1);
  print LIST "\n<h1>List of entities", ($haveconfs?
     ", architectures and configurations" : " and architectures"), "</h1>\n";
  if( !@list ) {
    print LIST "\n<p>No entities, architectures or configurations were ",
                "found.</p>\n";
    printhtmlfooter(*LIST{IO});
    close LIST;
    return;
  }
  elsif( $haveconfs ) {
    print LIST "\n<p>Configurations are given in <i>italics</i>.</p>\n";
  }
  print LIST "\n\n<table border=\"0\" cellpadding=\"$cp\">\n";
  for my $item (@list) {
    if( $item->{"entity"} ) {
      print LIST "<tr><td colspan=\"2\"><a href=\"entities/",
                $item->{"entity"}->{"docfilename"}, 
                "\"><b>", $item->{"name"}, "</b></a></td>";
      if( my $brief= ($item->{"entity"}->{"doc"}->{"brief"} ||
                      $item->{"entity"}->{"doc"}->{"short"}) ) {
        print LIST "<td>$brief</td>\n";
      }
      print LIST "</tr>\n";
    }
    else {
      print LIST "<tr><td colspan=\"2\"><b>", $item->{"name"}, "</b></td></tr>\n";
    }
    for my $arch (@{$item->{"architectures"}}) {
      print LIST "<tr>$ind<td><a href=\"architectures/",$arch->{"docfilename"},
                 "\">", $arch->{"name"}, "</a></td>";
      if( my $brief= ($arch->{"doc"}->{"brief"} ||
                      $arch->{"doc"}->{"short"}) ) {
        print LIST "<td>$brief</td>\n";
      }
      print LIST "</tr>\n";
    }
    for my $conf (@{$item->{"configurations"}}) {
      print LIST "<tr>$ind<td><a href=\"configurations/",
            $conf->{"docfilename"}, "\"><i>", $conf->{"name"}, "</i></a></td>";
      if( my $brief= ($conf->{"doc"}->{"brief"} ||
                      $conf->{"doc"}->{"short"}) ) {
        print LIST "<td>$brief</td>\n";
      }
      print LIST "</tr>\n";
    }
  }
  print LIST "</table>\n\n";
  printhtmlfooter(*LIST{IO});
  close LIST;
}


# Generate the HTML page listing packages
# -> Reference to array of hash references representing packages
#    Reference to array of hash references representing package bodies not
#    associated with any package (known to us), or undef
sub packagelisthtml
{
  my ($packs, $opbodies)= @_;
  my @list;
  my $fname= File::Spec->catfile($config{"outputdir"},
                                $config{"prefix"} . "packages.html");

  if( !open(LIST, ">$fname") ) {
    print STDERR "Cannot create output file $fname - $!\n";
    return;
  }
  printhtmlheader(*LIST{IO}, "Packages", 1);
  if( !@$packs && (!$opbodies || !@$opbodies) ) {
    print LIST "\n<h1>List of packages</h1>\n\n";
    print LIST "<p>No packages were found.</p>\n";
    printhtmlfooter(*LIST{IO});
    close LIST;
    return;
  }
  if( @$packs ) {
    print LIST "\n<h1>List of packages</h1>\n\n";
    for my $pack (@$packs) {
      print LIST "<p><a href=\"packages/", $pack->{"docfilename"}, "\">",
                  $pack->{"fullname"}, "</a></p>\n";
    }
  }
  if( $opbodies && @$opbodies ) {
    print LIST "\n<h1>List of orphaned package bodies</h1>\n\n";
    for my $pbody (@$opbodies) {
      print LIST "<p><a href=\"packages/", $pbody->{"docfilename"}, "\">",
                  $pbody->{"fullname"}, "</a></p>\n";
    }
  }
  printhtmlfooter(*LIST{IO});
  close LIST;
}


# Prints an HTML fragment describing one node in the instantiation hierarchy
# and recursively calls itself to print the children
# -> File handle to print to
#    Reference to the hash representing the hierarchy node
#    Reference to an array containing hash references of the parent nodes from
#    bottom to top, to avoid infinite loops in the case of recursive
#    instantiations
#    Maximum depth of the tree
#    (optional) If !=0, do not recurse beyond instantiations given in one
#    architecture or configuration
sub printhiernodehtml
{
  my ($handle, $node, $trace, $maxdepth, $notdeep)= @_;
  my $real= $node->{"proxy"} || $node;
  my $nodehtml;
  my $brief;
  my $recursion= 0;

#  $nodehtml .= "<table border=\"0\"><tr><td>";
  if( grep($_ == $real, @$trace) ) {
    $recursion= 1;
  }
  elsif( ($real->{"architecture"} &&
       ($brief= $real->{"architecture"}->{"doc"}->{"brief"} ||
                $real->{"architecture"}->{"doc"}->{"short"}))
        || ($real->{"entity"} &&
       ($brief= $real->{"entity"}->{"doc"}->{"brief"} ||
                $real->{"entity"}->{"doc"}->{"short"})) ) {
  }
  if( $real->{"entname"} ) {
    $nodehtml .= "<a href=\"entities/" . $real->{"entity"}->{"docfilename"} .
                  "\">"
      if $real->{"entity"};
    $nodehtml .= "<b>" . $real->{"entname"} . "</b>";
    $nodehtml .= "</a>"
      if $real->{"entity"};
  }
  if( $real->{"archname"} ) {
    $nodehtml .= "&nbsp;";
    $nodehtml .= "<a href=\"architectures/" .
                  $real->{"architecture"}->{"docfilename"} . "\">"
      if $real->{"architecture"};
    $nodehtml .= "(" . $real->{"archname"} . ")";
    $nodehtml .= "</a>"
      if $real->{"architecture"};
  }
  if( $node->{"confname"} ) {
    $nodehtml .= "&nbsp;";
    $nodehtml .= "<a href=\"configurations/" .
                  $node->{"configuration"}->{"docfilename"} . "\">"
      if $node->{"configuration"};
    $nodehtml .= "[<i>" . $node->{"confname"} . "</i>]";
    $nodehtml .= "</a>"
      if $node->{"configuration"};
  }
  $node->{"done"}= 1;
  $real->{"done"}= 1;
  if( $recursion ) {
    print $handle <<EOF;
<dd><table border="0"><tr><td><img src="style/$requisites{leafimg}">&nbsp;</td>
    <td>$nodehtml ... (recursion)</td></tr></table></dd>
EOF
    return;
  }
  if( $brief ) {
    $nodehtml .= "</td><td width=\"10\"></td><td> $brief";
  }
  if( ! $real->{"children"} || ! @{$real->{"children"}} ||
      ( $notdeep && @$trace &&
    # Instantiation overview: do not descend past 1st level for architectures;
    # stop at architecture or different configuration for configurations
        ($node->{"proxy"} || !$$trace[0]->{"confname"} ||
          $$trace[0]->{"confname"} ne ($node->{"confname"} || "")) ) ) {
    print $handle <<EOF;
<dd><table border=\"0\"><tr><td><img src="style/$requisites{leafimg}">&nbsp;</td>
    <td>$nodehtml</td></tr></table></dd>
EOF
    return;
  }
  print $handle <<EOF;
<dd><table border="0"><tr><td><img src="style/$requisites{nodeimg}"><img src="style/$requisites{subtrimg}">&nbsp;</td>
    <td>$nodehtml</td></tr></table> <dl>
EOF
  unshift @$trace, $real;
  for my $child (@{$real->{"children"}}) {
    printhiernodehtml($handle, $child, $trace, $maxdepth, $notdeep);
  }
  shift @$trace;
  print $handle "</dl></dd>\n";
}


# Generate the HTML page of the instantiation overview
# -> Reference to array containing hierarchy nodes of architectures and
#    configurations
#    Flag indicating that there are configurations at all
sub instantiationhtml
{
  my ($hier, $haveconfs)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"},
                                $config{"prefix"} . "instantiations.html");
  my $header;
  my $maxdepth;

  if( !open(INST, ">$fname") ) {
    print STDERR "Cannot create output file $fname - $!\n";
    return;
  }
  printhtmlheader(\$header, "Instantiation overview", 1);
  $header =~ s!(?=</head>)!<<EOF!ie;
    <link type="text/css" rel="stylesheet" href="style/treeview.css">
    <script type="text/javascript" src="style/treeview.js"></script>
EOF
  $header =~ s!<body>!<<EOF!ie;
<body
  onload="treeMenu_init(document.getElementById('treeview'), unescape(window.name).split(',')[0]);"
  onunload="window.name = escape(treeMenu_store(document.getElementById('treeview')))" >
EOF
  print INST $header;
  print INST "\n<h1>Instantiation overview</h1>\n\n";
  print INST "\n<p>Configurations are given in brackets and in <i>italics</i>.</p>\n\n"
        if $haveconfs;
  print INST <<EOF;

<p>Click on <img src="style/$requisites{nodeimg}"> to open or close one level,
on <img src="style/$requisites{subtrimg}"> to open or close all levels (only
for configurations).
<span onclick="treeMenu_closeOrOpenAll(document.getElementById('treeview'), false);"><b>Open all</b></span> /
<span onclick="treeMenu_closeOrOpenAll(document.getElementById('treeview'), true);"><b>Close all</b></span></p>

<dl id="treeview">
EOF
  $maxdepth= 0;
  for my $node (@$hier) {
    next unless $node->{"confname"};
    my $thismax= hier_max_depth($node);
    $maxdepth= $thismax if $maxdepth < $thismax;
  }
  for my $node (@$hier) {
    printhiernodehtml(*INST{IO}, $node, [], $maxdepth, 1);
  }
  print INST "</dl>\n\n";
  printhtmlfooter(*INST{IO});
  close INST;
}


# Generate the HTML page of the instantiation hierarchy
# -> Reference to array containing hierarchy nodes of architectures and
#    configurations
#    Flag indicating that there are configurations at all
sub hierarchyhtml
{
  my ($hier, $haveconfs)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"},
                                $config{"prefix"} . "hierarchy.html");
  my $header;
  my $maxdepth;

  if( !open(HIER, ">$fname") ) {
    print STDERR "Cannot create output file $fname - $!\n";
    return;
  }
  printhtmlheader(\$header, "Instantiation hierarchy", 1);
  $header =~ s!(?=</head>)!<<EOF!ie;
    <link type="text/css" rel="stylesheet" href="style/treeview.css">
    <script type="text/javascript" src="style/treeview.js"></script>
EOF
  $header =~ s!<body>!<<EOF!ie;
<body
  onload="treeMenu_init(document.getElementById('treeview'), unescape(window.name).split(',')[0]);"
  onunload="window.name = escape(treeMenu_store(document.getElementById('treeview')))" >
EOF
  print HIER $header;
  print HIER "\n<h1>Instantiation hierarchy</h1>\n\n";
  print HIER "\n<p>Configurations are given in brackets and in <i>italics</i>.</p>\n\n"
        if $haveconfs;
  print HIER <<EOF;

<p>Click on <img src="style/$requisites{nodeimg}"> to open or close one level,
on <img src="style/$requisites{subtrimg}"> to open or close all levels.
<span onclick="treeMenu_closeOrOpenAll(document.getElementById('treeview'), false);"><b>Open all</b></span> /
<span onclick="treeMenu_closeOrOpenAll(document.getElementById('treeview'), true);"><b>Close all</b></span></p>

<dl id="treeview">
EOF
  my @topmods= grep !$_->{"instantiated"}, @$hier;
  $maxdepth= 0;
  for my $node (@topmods) {
    my $thismax= hier_max_depth($node);
    $maxdepth= $thismax if $maxdepth < $thismax;
  }
  for my $node (@topmods) {
    printhiernodehtml(*HIER{IO}, $node, [], $maxdepth);
  }
  my @leftovers= grep !$_->{"done"}, @$hier;
  for my $node (@leftovers) {
    printhiernodehtml(*HIER{IO}, $node, [], $maxdepth);
  }
  print HIER "</dl>\n\n";
  printhtmlfooter(*HIER{IO});
  close HIER;
}


# Generate list of source files with links to their HTML files.
# -> Reference to array of hashes representing VHDL source files
sub sourcelisthtml
{
  my ($sources)= @_;
  my $fname= File::Spec->catfile($config{"outputdir"},
                                $config{"prefix"} . "sources.html");

  if( !open(SOURCE, ">$fname") ) {
    print STDERR "Cannot create output file $fname - $!\n";
    return;
  }
  printhtmlheader(*SOURCE{IO}, "Source file overview", 1);
  print SOURCE "\n<h1>Source file overview</h1>\n";
  print SOURCE "\n<p>The file paths link to HTML pages showing the sources; the links in brackets point to the actual source files.</p>\n";
  my @srclist= sort { $a->{"name"} cmp $b->{"name"} } @$sources;
  print SOURCE "\n<table border=\"0\">\n";
  for my $file (@srclist) {
    print SOURCE "<tr><td><a href=\"sources/", $file->{"docfilename"}, "\">",
                $file->{"name"}, "</a>&nbsp;&nbsp;&nbsp;</td><td><a href=\"",
                $file->{"link"}, "\">[source file]</a></td></tr>\n";
  }
  print SOURCE "</table>\n";
  printhtmlfooter(*SOURCE{IO});
  close LIST;
}


##############################################################################
##############################################################################
####                    Main program
##############################################################################
##############################################################################

my @vhdlfiles= @{parseargv(\@ARGV)};

if( $config{"benchmark"} ) {
  eval { require Time::HiRes; };
  if( $@ ) {
    print STDERR "Module Time::HiRes is required for --benchmark.  Aborting.\n";
    exit 1;
  }
}

$config{"absoutputdir"}= mycanonpath($config{"outputdir"});

if( uniq_files(\@vhdlfiles) ) {
  print STDERR "Warning: Duplicate source file names were removed.\n";
}

unless( @vhdlfiles ) {
  print "No source files given - nothing to be done.\n"
        unless $config{"quiet"};
  exit;
}

prepareoutput();


# This is the only data structure relating to declarative items which does not
# conform to our canonical format (see parsefile()).  %libraries is a hash
# mapping the library name to an array reference containing all (top-level)
# declarations in that library.
my %libraries;

{
my %docfilenames;

for my $file (@vhdlfiles) {
  parsefile($file);
  push @{$libraries{lc($file->{"libname"})}}, @{$file->{"children"}};
  my $trunkname;
  (undef, undef, $trunkname)= File::Spec->splitpath($file->{"name"});
  $trunkname =~ s/\.[^\.]*$//;
  $file->{"link"}= sourcelink($file->{"name"});
  $file->{"docfilename"}= $config{"prefix"} . $trunkname . ".html";
  push @{$docfilenames{$file->{"docfilename"}}}, $file;
}

# Disambiguate duplicate source HTML file names
for my $docfiles (values %docfilenames) {
  next if @$docfiles == 1;
  for my $file (@$docfiles) {
    my $suffix= substr(Digest::MD5::md5_hex($file->{"name"}), 0, 8);
    $file->{"docfilename"} =~ s/\.html$/_$suffix.html/i;
  }
}

}

print "Scrunching and twisting everything together...\n" unless $config{"quiet"};
benchmark() if $config{"benchmark"};

my @entities;
my @architectures;
my @configurations;
my @packages;
my @packagebodies;
my $duplicate= 0;

# Build entity, architecture, configuration and package lists
for my $lib (keys(%libraries)) {
  my $decls= $libraries{$lib};
  for (@$decls) {       # create these entries to avoid "undefined" warnings
    $_->{"allinstances"} ||= [];
    $_->{"allprocesses"} ||= [];
  }
  my @ents= grep $_->{"type"} eq "entity", @$decls;
  $duplicate += uniq_objs(\@ents);
  my @archs= grep $_->{"type"} eq "architecture", @$decls;
  $duplicate += uniq_objs(\@archs);
  my @confs= grep $_->{"type"} eq "configuration", @$decls;
  $duplicate += uniq_objs(\@confs);
  my @packs= grep $_->{"type"} eq "package", @$decls;
  $duplicate += uniq_objs(\@packs);
  my @pbods= grep $_->{"type"} eq "packagebody", @$decls;
  $duplicate += uniq_objs(\@pbods);
  map { $_->{"fullname"}= $lib . "." . $_->{"name"}; } @ents;
  for my $ac (@archs, @confs) {
    $ac->{"libname"} = $lib;
    next if $ac->{"objname"} =~ /\..*\./ || 
  ($ac->{"objname"} =~ /^([^.\s]+)\s*\./ && grep($_ eq $1, keys(%libraries)));
    $ac->{"objname"}= $lib . "." . $ac->{"objname"};
  }
  for my $pack (@packs, @pbods) {
    $pack->{"libname"} = $lib;
    $pack->{"fullname"}= $lib . "." . $pack->{"name"};
  }
  add_selnames($lib, @ents, @archs, @confs, @packs, @pbods);
  push @entities, @ents;
  push @architectures, @archs;
  push @configurations, @confs;
  push @packages, @packs;
  push @packagebodies, @pbods;
}

print STDERR "Warning: Duplicate declarations were discarded.\n" if $duplicate;


for my $ent (@entities)
{
  # Assign architectures to entities
  # Important - even if there are none, @{$ent->{"architectures"}} exists
  @{$ent->{"architectures"}}= 
            grep lc($_->{"objname"}) eq lc($ent->{"fullname"}), @architectures;
  map $_->{"entity"}= $ent, @{$ent->{"architectures"}};

  # Assign configurations to entities
  # Important - even if there are none, @{$ent->{"configurations"}} exists
  @{$ent->{"configurations"}}= 
          grep lc($_->{"objname"}) eq lc($ent->{"fullname"}), @configurations;
  map $_->{"entity"}= $ent, @{$ent->{"configurations"}};

  # Assign @generic and @port docs to their declarations if legacy mode is on
  if( $config{"compat"} )
  {
    my @gens= @{$ent->{"childtype"}->{"generic"} || []};
    my @ports= @{$ent->{"childtype"}->{"port"} || []};
    if( @gens ) {
      # Copy generic documentation from the entity docs to its generic(s)
      for my $docname (keys(%{$ent->{"doc"}->{"generic"}})) {
        my ($subject)= grep $_->{"name"} eq $docname, @gens;
        if( !$subject ) {
          print STDERR "Spurious \@generic referring to non-existing generic ",
                        "$docname of entity ", $ent->{"name"}, " in file ",
                        $ent->{"filename"}, "\n";
          next;
        }
        unshift @{$subject->{"doc"}->{"description"}},
                    $ent->{"doc"}->{"generic"}->{$docname};
      }
    }
    if( @ports ) {
      # Copy port documentation from the entity docs to its port(s)
      for my $docname (keys(%{$ent->{"doc"}->{"port"}})) {
        my ($subject)= grep $_->{"name"} eq $docname, @ports;
        if( !$subject ) {
          print STDERR "Spurious \@port referring to non-existing port ",
                        "$docname of entity ", $ent->{"name"}, " in file ",
                        $ent->{"filename"}, "\n";
          next;
        }
        unshift @{$subject->{"doc"}->{"description"}},
                    $ent->{"doc"}->{"port"}->{$docname};
      }
    }
  }

  # Match attribute specifications to declarations and to targets
  match_attributes($ent);
  # HTML file name
  $ent->{"docfilename"}= $config{"prefix"} . $ent->{"fullname"} . ".html";
}



my @orphanedarchs;

for my $arch (@architectures) {
  # Build list of architectures we do not know the entity of
  push @orphanedarchs, $arch unless $arch->{"entity"};
  # Match attribute specifications to declarations and to targets
  match_attributes($arch);
  # HTML file name
  $arch->{"docfilename"}= $config{"prefix"} . $arch->{"objname"} . "-" .
                          $arch->{"name"} . ".html";
  for my $child (@{$arch->{"children"}}, @{$arch->{"allinstances"}}) {
    if( $labels{$child->{"type"}} ) {
      $child->{"doclink"}= "../architectures/" . $arch->{"docfilename"} . "#"
                            . $labels{$child->{"type"}} . $child->{"name"};
    }
  }
}



my @orphanedconfs;

for my $conf (@configurations) {
  # Build list of configurations we do not know the entity of
  push @orphanedconfs, $conf unless $conf->{"entity"};
  # HTML file name
  $conf->{"docfilename"}= $config{"prefix"} . $conf->{"objname"} . "-" .
                          $conf->{"name"} . ".html";
  # Now assign objects to the use statements
  resolve_configuration($conf, \%libraries);
}


for my $pack (@packages)
{
  # Assign body to package
  for my $pbod (@packagebodies) {
    if( lc($pack->{"fullname"}) eq lc($pbod->{"fullname"}) ) {
      $pack->{"packagebody"}= $pbod;
      $pbod->{"package"}= $pack;
      last;
    }
  }
  # HTML file name
  $pack->{"docfilename"}= $config{"prefix"} . $pack->{"fullname"} . ".html";
  # Create full name and HTML link (where applicable) for declarative items in
  # package
  for my $child (@{$pack->{"children"}}) {
    $child->{"fullname"}= $pack->{"fullname"} . "." . $child->{"name"};
    if( $labels{$child->{"type"}} ) {
      $child->{"doclink"}= "../packages/" . $pack->{"docfilename"} . "#" .
                                $labels{$child->{"type"}} . $child->{"name"};
    }
  }
  # Match attribute specifications to declarations and to targets
  match_attributes($pack);
  # Add component declarations to selected name table
  add_selnames($pack->{"fullname"}, @{$pack->{"childtype"}->{"component"}});
  # Find default bindings for components declared in the package
  map { $_->{"binding"}= find_selname($_->{"name"}, "entity",
                            $pack->{"fullname"}); }
            @{$pack->{"childtype"}->{"component"}};
}


my @orphanedpbodies;

for my $pbody (@packagebodies)
{
  # Build list of package bodies we didn't find a package for
  push @orphanedpbodies, $pbody unless $pbody->{"package"};
  # Match attribute specifications to declarations and to targets
  match_attributes($pbody);
  # HTML file name
  $pbody->{"docfilename"}= $config{"prefix"} . $pbody->{"fullname"} . ".html";
}

for my $opb (@orphanedpbodies)
{
  # Find default bindings for components declared in the package
  map { $_->{"binding"}= find_selname($_->{"name"}, "entity",
                            $opb->{"fullname"}); }
              @{$opb->{"childtype"}->{"component"}};
  # Create full name and HTML link (where applicable) for declarative items in
  # package body, since we do not have a package to match
  for my $child (@{$opb->{"children"}}) {
    $child->{"fullname"}= $opb->{"fullname"} . "." . $child->{"name"};
    if( $labels{$child->{"type"}} ) {
      $child->{"doclink"}= "../packages/" . $opb->{"docfilename"} . "#" .
                                $labels{$child->{"type"}} . $child->{"name"};
    }
  }
  # Add component declarations to selected name table
  add_selnames($opb->{"fullname"}, @{$opb->{"childtype"}->{"component"}});
}



# Now take care of locally specified bindings and generic maps of instances.
# Nested configurations will be tackled below.
for my $file (@vhdlfiles)
{
  my @fuses= grep $_->{"subtype"} eq "package", @{$file->{"uses"}};
  for my $useclause (@fuses) {
    next unless $useclause->{"name"} =~ /^([^.\s]+\s*\.\s*[^.\s]+)/;
    my $pack= $1;
    $useclause->{"package"}= find_selname($pack, "package", $file->{"libname"});
    next unless $useclause->{"package"};
    next if $useclause->{"name"} =~ /\ball$/i;
    $useclause->{"name"} =~ /^$pack\s*\.\s*([^.\s]+)/;
    ($useclause->{"object"})= find_children($useclause->{"package"}, "name", $1);
  }
}

for my $arch (@architectures, @orphanedarchs)
{
  my @topuses= reverse grep $_->{"subtype"} eq "package", @{$arch->{"uses"}};
  my @comps= @{$arch->{"childtype"}->{"component"} || []};
  # Assign default binding to component declarations
  map { $_->{"binding"}= find_selname($_->{"name"}, "entity",
                                      $arch->{"libname"}); } @comps;
  my @noncompinsts;
bindcompinst:
  for my $inst (@{$arch->{"allinstances"}}) {
    if( $inst->{"subtype"} ne "component" ) {
      push @noncompinsts, $inst;
      next;
    }
    # Match component instances to component declarations.
    # First try local component declarations:
    $inst->{"component"}=
              elem { lc($_->{"name"}) eq lc($inst->{"objname"}) } @comps;
    # If there is no matching local component declaration, we have to find
    # one in one of the packages.  If the bare name is unique, we choose that
    # component.
    $inst->{"component"}= find_selname($inst->{"objname"}, "component")
        unless $inst->{"component"};
    # If not, try selected names according to use clauses.
    if( defined($inst->{"component"}) && $inst->{"component"} == 0 ) {
      for my $useclause (@topuses) {
        my $name= merge_selname($useclause->{"name"}, $inst->{"objname"});
        next unless $name;
        $inst->{"component"}= find_selname($name, "component");
        last if $inst->{"component"};
      }
    }
    # This procedure has the illogical side effect that an ambiguous component
    # instantiation will be shown as unresolved if no matching use clause is
    # found.
    # Now we tackle binding indications in the blocks enclosing the
    # instantiation.
    for my $use (reverse @{$inst->{"uses"}}) {
      next if $use->{"subtype"} eq "package";
      my $for= $use->{"for"};
      next unless $for && lc($for->{"objtype"}) eq lc($inst->{"objname"}) &&
            ( lc($for->{"objnames"}->[0]) eq "all" ||
            elem { lc($_) eq lc($inst->{"name"}) } @{$for->{"objnames"}} );
      @{$inst->{"binddoc"}}= @{$for->{"doc"}->{"description"}}
          if $for->{"doc"}->{"description"};
      push @{$inst->{"binddoc"}}, @{$use->{"doc"}->{"description"}}
                  if $use->{"doc"}->{"description"};
# TODO: handle open bindings, also in docs
#     next bindcompinst if $use->{"subtype"} eq "open";
      $inst->{"bindname"}= $use->{"name"};
      $inst->{"binding"}= find_selname($use->{"name"},
                              $use->{"subtype"}, $arch->{"libname"});
      if( $inst->{"binding"} ) {
        if( $use->{"archname"} ) {
          $inst->{"archname"}= $use->{"archname"};
          $inst->{"bindarch"}= elem { $_->{"name"} eq $use->{"archname"} }
                                @{$inst->{"binding"}->{"architectures"}};
        }
        elsif( @{$inst->{"binding"}->{"architectures"}} ) {
          $inst->{"bindarch"}= $inst->{"binding"}->{"architectures"}->[0];
          $inst->{"archname"}= $inst->{"bindarch"}->{"name"};
        }
      }
      elsif( $use->{"archname"} ) {
        $inst->{"archname"}= $use->{"archname"};
        my @candidates= grep $_->{"name"} eq $inst->{"archname"} &&
                  $_->{"objname"} eq $inst->{"objname"}, @orphanedarchs;
        $inst->{"bindarch"}= elem( sub { $_->{"libname"} eq
                        $arch->{"libname"} }, @candidates) || $candidates[0];
      }
      $inst->{"bindgen"}= $use->{"genericmap"};
      next bindcompinst;
    }
    # Without an explicit binding specification we bind to the binding of the
    # matching component declaration, if any.
    if( $inst->{"component"} ) {
      $inst->{"binding"}= $inst->{"component"}->{"binding"};
    }
    # Aaargh... the component is not even declared.  Sloppy designer!  So we
    # resolve the instantiation by name.
    else {
      $inst->{"binding"}= find_selname($inst->{"objname"}, "entity",
                                          $arch->{"libname"});
    }
    if( $inst->{"binding"} && @{$inst->{"binding"}->{"architectures"}} ) {
      $inst->{"bindarch"}= $inst->{"binding"}->{"architectures"}->[0];
      $inst->{"archname"}= $inst->{"bindarch"}->{"name"};
    }
  }

  for my $inst (@noncompinsts) {
    $inst->{"binding"}= find_selname($inst->{"objname"}, $inst->{"subtype"});
    # If the name is abiguous, go looking in current library and use clauses.
    if( defined($inst->{"binding"}) && $inst->{"binding"} == 0 ) {
      $inst->{"binding"}= find_selname($inst->{"objname"}, $inst->{"subtype"},
                                        $arch->{"libname"});
      unless( $inst->{"binding"} ) {
# TODO: do entity and configuration declarations even exist in packages?
        for my $useclause (@topuses) {
          my $name= merge_selname($useclause->{"name"}, $inst->{"name"});
          next unless $name;
          $inst->{"binding"}= find_selname($name, $inst->{"subtype"});
          last if $inst->{"binding"};
        }
      }
    }
    next unless $inst->{"subtype"} eq "entity";
    if( $inst->{"binding"} ) {
      if( $inst->{"archname"} ) {
        $inst->{"bindarch"}= elem { $_->{"name"} eq $inst->{"archname"} }
                                @{$inst->{"binding"}->{"architectures"}};
      }
      elsif( @{$inst->{"binding"}->{"architectures"}} ) {
        $inst->{"bindarch"}= $inst->{"binding"}->{"architectures"}->[0];
        $inst->{"archname"}= $inst->{"bindarch"}->{"name"};
      }
    }
    elsif( $inst->{"archname"} ) {
      my @candidates= grep $_->{"name"} eq $inst->{"archname"} &&
                      $_->{"objname"} eq $inst->{"objname"}, @orphanedarchs;
      $inst->{"bindarch"}= elem(sub { $_->{"libname"} eq $arch->{"libname"} },
                                    @candidates) || $candidates[0];
    }
  }
}


# The following data structures represent the instantiation hierarchy.  They
# also form a tree structure like our hashes representing declarative items,
# but have a different format.  The hashes representing hierarchy nodes may
# have the entries "architecture", "entity", "configuration", "archname",
# "entname" and "confname".  (Other entries serve to indicate whether the
# node's object is itself instantiated somewhere, or to reference other nodes).
# The tree structure is formed by having a "children" entry referencing an
# array of hash references, as with the declarative items.
my @hierarchy;
my @ahier;

# Create instantiation hierarchy nodes representing architectures:
for my $arch (@architectures) {
  my $node= { "entname" => $arch->{"objname"}, "entity" => $arch->{"entity"},
              "architecture" => $arch, "archname" => $arch->{"name"} };
  push @hierarchy, $node;
  push @ahier, $node;
  $node->{"children"}= [];
  for my $inst (@{$arch->{"allinstances"}}) {
    if( $inst->{"subtype"} eq "configuration" || ($inst->{"binding"} &&
        $inst->{"binding"}->{"type"} eq "configuration") ) {
      my $new;
      if( $inst->{"binding"} ) {
        $new= { "configuration" => $inst->{"binding"},
                "confname" => ($inst->{"subtype"} eq "configuration"?
                          $inst->{"objname"} : $inst->{"binding"}->{"name"}) };
      }
      else {
        $new= { "confname" => $inst->{"objname"} };
      }
      push @{$node->{"children"}}, $new
        unless grep_hier($new, $node->{"children"});
    }
    else {
      my $new;
      if( $inst->{"binding"} ) {
        $new= { "entity" => $inst->{"binding"}, "entname"=> $inst->{"bindname"},
                "architecture" => $inst->{"bindarch"}, 
                "archname" => $inst->{"archname"} };
      }
      else {
        $new= { "entname" => $inst->{"bindname"} || $inst->{"objname"},
                "archname" => $inst->{"archname"} };
      }
      push @{$node->{"children"}}, $new
        unless grep_hier($new, $node->{"children"});
    }
  }
}

# Create instantiation hierarchy nodes representing configurations:
my @chier= map +{ "configuration" => $_, "confname" => $_->{"name"} },
                @configurations;
push @hierarchy, @chier;
# Build sub-hierarchy of configuration:
map { configure_hierarchy($_, \@ahier, \@chier); } @chier;

# Match architectures' instantiations to nodes:
for my $anode (@ahier) {
  for my $child (@{$anode->{"children"}}) {
    my ($cnode)= grep_hier($child, \@hierarchy);
    if( $cnode ) {
      $child= $cnode;
      $cnode->{"instantiated"}= 1;
    }
  }
}

@hierarchy= sort hier_sort_cmp @hierarchy;

benchmark("to process") if $config{"benchmark"};


# Now generate documentation

print "Generating docs...\n" unless $config{"quiet"};
benchmark() if $config{"benchmark"};

# Find targets of cross references, if any
for my $obj (@entities, @architectures, @configurations, @packages,
                @packagebodies) {
  next unless $obj->{"doc"}->{"see"};
  resolve_seealso($obj->{"doc"}->{"see"}, \%libraries,
                $obj->{"file"}->{"libname"});
}

entitylisthtml(\@entities, \@orphanedarchs, \@orphanedconfs, scalar(@configurations));
packagelisthtml(\@packages, \@orphanedpbodies);
instantiationhtml(\@hierarchy, scalar(@chier));
hierarchyhtml(\@hierarchy, scalar(@chier));
sourcelisthtml(\@vhdlfiles);

for my $ent (@entities) {
  entityhtml($ent);
}

for my $conf (@configurations) {
  configurationhtml($conf);
}

for my $arch (@architectures) {
  architecturehtml($arch);
}

for my $pack (@packages, @orphanedpbodies) {
  packagehtml($pack);
}

for my $file (@vhdlfiles) {
  sourcehtml($file);
}

benchmark("to generate HTML") if $config{"benchmark"};

exit 0;

